"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdfjs-dist/legacy/build/pdf.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pdfjs-dist/legacy/build/pdf.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   CSSConstants: () => (/* binding */ CSSConstants),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   applyOpacity: () => (/* binding */ applyOpacity),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   findContrastColor: () => (/* binding */ findContrastColor),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getRGB: () => (/* binding */ getRGB),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   renderRichText: () => (/* binding */ renderRichText),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /**\n * pdfjsVersion = 5.4.296\n * pdfjsBuild = f56dc8601\n */ /******/ var __webpack_modules__ = {\n    /***/ 34: /***/ (module, __unused_webpack_exports, __nested_webpack_require_947__)=>{\n        var isCallable = __nested_webpack_require_947__(4901);\n        module.exports = function(it) {\n            return typeof it == \"object\" ? it !== null : isCallable(it);\n        };\n    /***/ },\n    /***/ 81: /***/ (module, __unused_webpack_exports, __nested_webpack_require_1215__)=>{\n        var call = __nested_webpack_require_1215__(9565);\n        var aCallable = __nested_webpack_require_1215__(9306);\n        var anObject = __nested_webpack_require_1215__(8551);\n        var tryToString = __nested_webpack_require_1215__(6823);\n        var getIteratorMethod = __nested_webpack_require_1215__(851);\n        var $TypeError = TypeError;\n        module.exports = function(argument, usingIterator) {\n            var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n            if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n            throw new $TypeError(tryToString(argument) + \" is not iterable\");\n        };\n    /***/ },\n    /***/ 116: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_1962__)=>{\n        var $ = __nested_webpack_require_1962__(6518);\n        var call = __nested_webpack_require_1962__(9565);\n        var iterate = __nested_webpack_require_1962__(2652);\n        var aCallable = __nested_webpack_require_1962__(9306);\n        var anObject = __nested_webpack_require_1962__(8551);\n        var getIteratorDirect = __nested_webpack_require_1962__(1767);\n        var iteratorClose = __nested_webpack_require_1962__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_1962__(4549);\n        var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"find\", TypeError);\n        // `Iterator.prototype.find` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.find\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: findWithoutClosingOnEarlyError\n        }, {\n            find: function find(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value, stop) {\n                    if (predicate(value, counter++)) return stop(value);\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).result;\n            }\n        });\n    /***/ },\n    /***/ 283: /***/ (module, __unused_webpack_exports, __nested_webpack_require_3597__)=>{\n        var uncurryThis = __nested_webpack_require_3597__(9504);\n        var fails = __nested_webpack_require_3597__(9039);\n        var isCallable = __nested_webpack_require_3597__(4901);\n        var hasOwn = __nested_webpack_require_3597__(9297);\n        var DESCRIPTORS = __nested_webpack_require_3597__(3724);\n        var CONFIGURABLE_FUNCTION_NAME = __nested_webpack_require_3597__(350).CONFIGURABLE;\n        var inspectSource = __nested_webpack_require_3597__(3706);\n        var InternalStateModule = __nested_webpack_require_3597__(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var $String = String;\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        var stringSlice = uncurryThis(\"\".slice);\n        var replace = uncurryThis(\"\".replace);\n        var join = uncurryThis([].join);\n        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {\n            return defineProperty(function() {}, \"length\", {\n                value: 8\n            }).length !== 8;\n        });\n        var TEMPLATE = String(String).split(\"String\");\n        var makeBuiltIn = module.exports = function(value, name, options) {\n            if (stringSlice($String(name), 0, 7) === \"Symbol(\") {\n                name = \"[\" + replace($String(name), /^Symbol\\(([^)]*)\\).*$/, \"$1\") + \"]\";\n            }\n            if (options && options.getter) name = \"get \" + name;\n            if (options && options.setter) name = \"set \" + name;\n            if (!hasOwn(value, \"name\") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n                if (DESCRIPTORS) defineProperty(value, \"name\", {\n                    value: name,\n                    configurable: true\n                });\n                else value.name = name;\n            }\n            if (CONFIGURABLE_LENGTH && options && hasOwn(options, \"arity\") && value.length !== options.arity) {\n                defineProperty(value, \"length\", {\n                    value: options.arity\n                });\n            }\n            try {\n                if (options && hasOwn(options, \"constructor\") && options.constructor) {\n                    if (DESCRIPTORS) defineProperty(value, \"prototype\", {\n                        writable: false\n                    });\n                // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n                } else if (value.prototype) value.prototype = undefined;\n            } catch (error) {}\n            var state = enforceInternalState(value);\n            if (!hasOwn(state, \"source\")) {\n                state.source = join(TEMPLATE, typeof name == \"string\" ? name : \"\");\n            }\n            return value;\n        };\n        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n        // eslint-disable-next-line no-extend-native -- required\n        Function.prototype.toString = makeBuiltIn(function toString() {\n            return isCallable(this) && getInternalState(this).source || inspectSource(this);\n        }, \"toString\");\n    /***/ },\n    /***/ 350: /***/ (module, __unused_webpack_exports, __nested_webpack_require_6788__)=>{\n        var DESCRIPTORS = __nested_webpack_require_6788__(3724);\n        var hasOwn = __nested_webpack_require_6788__(9297);\n        var FunctionPrototype = Function.prototype;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n        var EXISTS = hasOwn(FunctionPrototype, \"name\");\n        // additional protection from minified / mangled / dropped function names\n        var PROPER = EXISTS && (function something() {}).name === \"something\";\n        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, \"name\").configurable);\n        module.exports = {\n            EXISTS: EXISTS,\n            PROPER: PROPER,\n            CONFIGURABLE: CONFIGURABLE\n        };\n    /***/ },\n    /***/ 397: /***/ (module, __unused_webpack_exports, __nested_webpack_require_7667__)=>{\n        var getBuiltIn = __nested_webpack_require_7667__(7751);\n        module.exports = getBuiltIn(\"document\", \"documentElement\");\n    /***/ },\n    /***/ 421: /***/ (module)=>{\n        module.exports = {};\n    /***/ },\n    /***/ 456: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_7972__)=>{\n        var $ = __nested_webpack_require_7972__(6518);\n        var globalThis1 = __nested_webpack_require_7972__(4576);\n        var uncurryThis = __nested_webpack_require_7972__(9504);\n        var anUint8Array = __nested_webpack_require_7972__(4154);\n        var notDetached = __nested_webpack_require_7972__(5169);\n        var numberToString = uncurryThis(1.1.toString);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.toHex || !function() {\n            try {\n                var target = new Uint8Array1([\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255\n                ]);\n                return target.toHex() === \"ffffffffffffffff\";\n            } catch (error) {\n                return false;\n            }\n        }();\n        // `Uint8Array.prototype.toHex` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toHex: function toHex() {\n                anUint8Array(this);\n                notDetached(this.buffer);\n                var result = \"\";\n                for(var i = 0, length = this.length; i < length; i++){\n                    var hex = numberToString(this[i], 16);\n                    result += hex.length === 1 ? \"0\" + hex : hex;\n                }\n                return result;\n            }\n        });\n    /***/ },\n    /***/ 507: /***/ (module, __unused_webpack_exports, __nested_webpack_require_9659__)=>{\n        var call = __nested_webpack_require_9659__(9565);\n        module.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {\n            var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;\n            var next = record.next;\n            var step, result;\n            while(!(step = call(next, iterator)).done){\n                result = fn(step.value);\n                if (result !== undefined) return result;\n            }\n        };\n    /***/ },\n    /***/ 531: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_10218__)=>{\n        var $ = __nested_webpack_require_10218__(6518);\n        var call = __nested_webpack_require_10218__(9565);\n        var aCallable = __nested_webpack_require_10218__(9306);\n        var anObject = __nested_webpack_require_10218__(8551);\n        var getIteratorDirect = __nested_webpack_require_10218__(1767);\n        var getIteratorFlattenable = __nested_webpack_require_10218__(8646);\n        var createIteratorProxy = __nested_webpack_require_10218__(9462);\n        var iteratorClose = __nested_webpack_require_10218__(9539);\n        var IS_PURE = __nested_webpack_require_10218__(6395);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_10218__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_10218__(4549);\n        var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"flatMap\", function() {});\n        var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"flatMap\", TypeError);\n        var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var mapper = this.mapper;\n            var result, inner;\n            while(true){\n                if (inner = this.inner) try {\n                    result = anObject(call(inner.next, inner.iterator));\n                    if (!result.done) return result.value;\n                    this.inner = null;\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                result = anObject(call(this.next, iterator));\n                if (this.done = !!result.done) return;\n                try {\n                    this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n            }\n        });\n        // `Iterator.prototype.flatMap` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.flatmap\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            flatMap: function flatMap(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper: mapper,\n                    inner: null\n                });\n            }\n        });\n    /***/ },\n    /***/ 616: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13080__)=>{\n        var fails = __nested_webpack_require_13080__(9039);\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es/no-function-prototype-bind -- safe\n            var test = (function() {}).bind();\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n        });\n    /***/ },\n    /***/ 655: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13554__)=>{\n        var classof = __nested_webpack_require_13554__(6955);\n        var $String = String;\n        module.exports = function(argument) {\n            if (classof(argument) === \"Symbol\") throw new TypeError(\"Cannot convert a Symbol value to a string\");\n            return $String(argument);\n        };\n    /***/ },\n    /***/ 679: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13935__)=>{\n        var isPrototypeOf = __nested_webpack_require_13935__(1625);\n        var $TypeError = TypeError;\n        module.exports = function(it, Prototype) {\n            if (isPrototypeOf(Prototype, it)) return it;\n            throw new $TypeError(\"Incorrect invocation\");\n        };\n    /***/ },\n    /***/ 684: /***/ (module)=>{\n        // Should throw an error on invalid iterator\n        // https://issues.chromium.org/issues/336839115\n        module.exports = function(methodName, argument) {\n            // eslint-disable-next-line es/no-iterator -- required for testing\n            var method = typeof Iterator == \"function\" && Iterator.prototype[methodName];\n            if (method) try {\n                method.call({\n                    next: null\n                }, argument).next();\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 741: /***/ (module)=>{\n        var ceil = Math.ceil;\n        var floor = Math.floor;\n        // `Math.trunc` method\n        // https://tc39.es/ecma262/#sec-math.trunc\n        // eslint-disable-next-line es/no-math-trunc -- safe\n        module.exports = Math.trunc || function trunc(x) {\n            var n = +x;\n            return (n > 0 ? floor : ceil)(n);\n        };\n    /***/ },\n    /***/ 757: /***/ (module, __unused_webpack_exports, __nested_webpack_require_15281__)=>{\n        var getBuiltIn = __nested_webpack_require_15281__(7751);\n        var isCallable = __nested_webpack_require_15281__(4901);\n        var isPrototypeOf = __nested_webpack_require_15281__(1625);\n        var USE_SYMBOL_AS_UID = __nested_webpack_require_15281__(7040);\n        var $Object = Object;\n        module.exports = USE_SYMBOL_AS_UID ? function(it) {\n            return typeof it == \"symbol\";\n        } : function(it) {\n            var $Symbol = getBuiltIn(\"Symbol\");\n            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n        };\n    /***/ },\n    /***/ 851: /***/ (module, __unused_webpack_exports, __nested_webpack_require_15899__)=>{\n        var classof = __nested_webpack_require_15899__(6955);\n        var getMethod = __nested_webpack_require_15899__(5966);\n        var isNullOrUndefined = __nested_webpack_require_15899__(4117);\n        var Iterators = __nested_webpack_require_15899__(6269);\n        var wellKnownSymbol = __nested_webpack_require_15899__(8227);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module.exports = function(it) {\n            if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, \"@@iterator\") || Iterators[classof(it)];\n        };\n    /***/ },\n    /***/ 944: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(options) {\n            var alphabet = options && options.alphabet;\n            if (alphabet === undefined || alphabet === \"base64\" || alphabet === \"base64url\") return alphabet || \"base64\";\n            throw new $TypeError(\"Incorrect `alphabet` option\");\n        };\n    /***/ },\n    /***/ 1072: /***/ (module, __unused_webpack_exports, __nested_webpack_require_16873__)=>{\n        var internalObjectKeys = __nested_webpack_require_16873__(1828);\n        var enumBugKeys = __nested_webpack_require_16873__(8727);\n        // `Object.keys` method\n        // https://tc39.es/ecma262/#sec-object.keys\n        // eslint-disable-next-line es/no-object-keys -- safe\n        module.exports = Object.keys || function keys(O) {\n            return internalObjectKeys(O, enumBugKeys);\n        };\n    /***/ },\n    /***/ 1103: /***/ (module)=>{\n        module.exports = function(exec) {\n            try {\n                return {\n                    error: false,\n                    value: exec()\n                };\n            } catch (error) {\n                return {\n                    error: true,\n                    value: error\n                };\n            }\n        };\n    /***/ },\n    /***/ 1108: /***/ (module, __unused_webpack_exports, __nested_webpack_require_17735__)=>{\n        var classof = __nested_webpack_require_17735__(6955);\n        module.exports = function(it) {\n            var klass = classof(it);\n            return klass === \"BigInt64Array\" || klass === \"BigUint64Array\";\n        };\n    /***/ },\n    /***/ 1148: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_18059__)=>{\n        var $ = __nested_webpack_require_18059__(6518);\n        var call = __nested_webpack_require_18059__(9565);\n        var iterate = __nested_webpack_require_18059__(2652);\n        var aCallable = __nested_webpack_require_18059__(9306);\n        var anObject = __nested_webpack_require_18059__(8551);\n        var getIteratorDirect = __nested_webpack_require_18059__(1767);\n        var iteratorClose = __nested_webpack_require_18059__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_18059__(4549);\n        var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"every\", TypeError);\n        // `Iterator.prototype.every` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.every\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: everyWithoutClosingOnEarlyError\n        }, {\n            every: function every(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return !iterate(record, function(value, stop) {\n                    if (!predicate(value, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    /***/ },\n    /***/ 1181: /***/ (module, __unused_webpack_exports, __nested_webpack_require_19702__)=>{\n        var NATIVE_WEAK_MAP = __nested_webpack_require_19702__(8622);\n        var globalThis1 = __nested_webpack_require_19702__(4576);\n        var isObject = __nested_webpack_require_19702__(34);\n        var createNonEnumerableProperty = __nested_webpack_require_19702__(6699);\n        var hasOwn = __nested_webpack_require_19702__(9297);\n        var shared = __nested_webpack_require_19702__(7629);\n        var sharedKey = __nested_webpack_require_19702__(6119);\n        var hiddenKeys = __nested_webpack_require_19702__(421);\n        var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n        var TypeError1 = globalThis1.TypeError;\n        var WeakMap1 = globalThis1.WeakMap;\n        var set, get, has;\n        var enforce = function(it) {\n            return has(it) ? get(it) : set(it, {});\n        };\n        var getterFor = function(TYPE) {\n            return function(it) {\n                var state;\n                if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                    throw new TypeError1(\"Incompatible receiver, \" + TYPE + \" required\");\n                }\n                return state;\n            };\n        };\n        if (NATIVE_WEAK_MAP || shared.state) {\n            var store = shared.state || (shared.state = new WeakMap1());\n            /* eslint-disable no-self-assign -- prototype methods protection */ store.get = store.get;\n            store.has = store.has;\n            store.set = store.set;\n            /* eslint-enable no-self-assign -- prototype methods protection */ set = function(it, metadata) {\n                if (store.has(it)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                store.set(it, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return store.get(it) || {};\n            };\n            has = function(it) {\n                return store.has(it);\n            };\n        } else {\n            var STATE = sharedKey(\"state\");\n            hiddenKeys[STATE] = true;\n            set = function(it, metadata) {\n                if (hasOwn(it, STATE)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                createNonEnumerableProperty(it, STATE, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return hasOwn(it, STATE) ? it[STATE] : {};\n            };\n            has = function(it) {\n                return hasOwn(it, STATE);\n            };\n        }\n        module.exports = {\n            set: set,\n            get: get,\n            has: has,\n            enforce: enforce,\n            getterFor: getterFor\n        };\n    /***/ },\n    /***/ 1291: /***/ (module, __unused_webpack_exports, __nested_webpack_require_22399__)=>{\n        var trunc = __nested_webpack_require_22399__(741);\n        // `ToIntegerOrInfinity` abstract operation\n        // https://tc39.es/ecma262/#sec-tointegerorinfinity\n        module.exports = function(argument) {\n            var number = +argument;\n            // eslint-disable-next-line no-self-compare -- NaN check\n            return number !== number || number === 0 ? 0 : trunc(number);\n        };\n    /***/ },\n    /***/ 1385: /***/ (module, __unused_webpack_exports, __nested_webpack_require_22887__)=>{\n        var iteratorClose = __nested_webpack_require_22887__(9539);\n        module.exports = function(iters, kind, value) {\n            for(var i = iters.length - 1; i >= 0; i--){\n                if (iters[i] === undefined) continue;\n                try {\n                    value = iteratorClose(iters[i].iterator, kind, value);\n                } catch (error) {\n                    kind = \"throw\";\n                    value = error;\n                }\n            }\n            if (kind === \"throw\") throw value;\n            return value;\n        };\n    /***/ },\n    /***/ 1548: /***/ (module, __unused_webpack_exports, __nested_webpack_require_23520__)=>{\n        var globalThis1 = __nested_webpack_require_23520__(4576);\n        var fails = __nested_webpack_require_23520__(9039);\n        var V8 = __nested_webpack_require_23520__(9519);\n        var ENVIRONMENT = __nested_webpack_require_23520__(4215);\n        var structuredClone1 = globalThis1.structuredClone;\n        module.exports = !!structuredClone1 && !fails(function() {\n            // prevent V8 ArrayBufferDetaching protector cell invalidation and performance degradation\n            // https://github.com/zloirock/core-js/issues/679\n            if (ENVIRONMENT === \"DENO\" && V8 > 92 || ENVIRONMENT === \"NODE\" && V8 > 94 || ENVIRONMENT === \"BROWSER\" && V8 > 97) return false;\n            var buffer = new ArrayBuffer(8);\n            var clone = structuredClone1(buffer, {\n                transfer: [\n                    buffer\n                ]\n            });\n            return buffer.byteLength !== 0 || clone.byteLength !== 8;\n        });\n    /***/ },\n    /***/ 1549: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_24529__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_24529__(6632);\n    /***/ },\n    /***/ 1625: /***/ (module, __unused_webpack_exports, __nested_webpack_require_24699__)=>{\n        var uncurryThis = __nested_webpack_require_24699__(9504);\n        module.exports = uncurryThis({}.isPrototypeOf);\n    /***/ },\n    /***/ 1689: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_24919__)=>{\n        var $ = __nested_webpack_require_24919__(6518);\n        var globalThis1 = __nested_webpack_require_24919__(4576);\n        var apply = __nested_webpack_require_24919__(8745);\n        var slice = __nested_webpack_require_24919__(7680);\n        var newPromiseCapabilityModule = __nested_webpack_require_24919__(6043);\n        var aCallable = __nested_webpack_require_24919__(9306);\n        var perform = __nested_webpack_require_24919__(1103);\n        var Promise1 = globalThis1.Promise;\n        var ACCEPT_ARGUMENTS = false;\n        // Avoiding the use of polyfills of the previous iteration of this proposal\n        // that does not accept arguments of the callback\n        var FORCED = !Promise1 || !Promise1[\"try\"] || perform(function() {\n            Promise1[\"try\"](function(argument) {\n                ACCEPT_ARGUMENTS = argument === 8;\n            }, 8);\n        }).error || !ACCEPT_ARGUMENTS;\n        // `Promise.try` method\n        // https://tc39.es/ecma262/#sec-promise.try\n        $({\n            target: \"Promise\",\n            stat: true,\n            forced: FORCED\n        }, {\n            \"try\": function(callbackfn /* , ...args */ ) {\n                var args = arguments.length > 1 ? slice(arguments, 1) : [];\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                var result = perform(function() {\n                    return apply(aCallable(callbackfn), undefined, args);\n                });\n                (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);\n                return promiseCapability.promise;\n            }\n        });\n    /***/ },\n    /***/ 1698: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_26568__)=>{\n        var $ = __nested_webpack_require_26568__(6518);\n        var union = __nested_webpack_require_26568__(4204);\n        var setMethodGetKeysBeforeCloning = __nested_webpack_require_26568__(9835);\n        var setMethodAcceptSetLike = __nested_webpack_require_26568__(4916);\n        var FORCED = !setMethodAcceptSetLike(\"union\") || !setMethodGetKeysBeforeCloning(\"union\");\n        // `Set.prototype.union` method\n        // https://tc39.es/ecma262/#sec-set.prototype.union\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            union: union\n        });\n    /***/ },\n    /***/ 1701: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_27267__)=>{\n        var $ = __nested_webpack_require_27267__(6518);\n        var call = __nested_webpack_require_27267__(9565);\n        var aCallable = __nested_webpack_require_27267__(9306);\n        var anObject = __nested_webpack_require_27267__(8551);\n        var getIteratorDirect = __nested_webpack_require_27267__(1767);\n        var createIteratorProxy = __nested_webpack_require_27267__(9462);\n        var callWithSafeIterationClosing = __nested_webpack_require_27267__(6319);\n        var iteratorClose = __nested_webpack_require_27267__(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_27267__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_27267__(4549);\n        var IS_PURE = __nested_webpack_require_27267__(6395);\n        var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"map\", function() {});\n        var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"map\", TypeError);\n        var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [\n                result.value,\n                this.counter++\n            ], true);\n        });\n        // `Iterator.prototype.map` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.map\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            map: function map(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper: mapper\n                });\n            }\n        });\n    /***/ },\n    /***/ 1767: /***/ (module)=>{\n        // `GetIteratorDirect(obj)` abstract operation\n        // https://tc39.es/ecma262/#sec-getiteratordirect\n        module.exports = function(obj) {\n            return {\n                iterator: obj,\n                next: obj.next,\n                done: false\n            };\n        };\n    /***/ },\n    /***/ 1828: /***/ (module, __unused_webpack_exports, __nested_webpack_require_29874__)=>{\n        var uncurryThis = __nested_webpack_require_29874__(9504);\n        var hasOwn = __nested_webpack_require_29874__(9297);\n        var toIndexedObject = __nested_webpack_require_29874__(5397);\n        var indexOf = __nested_webpack_require_29874__(9617).indexOf;\n        var hiddenKeys = __nested_webpack_require_29874__(421);\n        var push = uncurryThis([].push);\n        module.exports = function(object, names) {\n            var O = toIndexedObject(object);\n            var i = 0;\n            var result = [];\n            var key;\n            for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n            // Don't enum bug & hidden keys\n            while(names.length > i)if (hasOwn(O, key = names[i++])) {\n                ~indexOf(result, key) || push(result, key);\n            }\n            return result;\n        };\n    /***/ },\n    /***/ 2106: /***/ (module, __unused_webpack_exports, __nested_webpack_require_30760__)=>{\n        var makeBuiltIn = __nested_webpack_require_30760__(283);\n        var defineProperty = __nested_webpack_require_30760__(4913);\n        module.exports = function(target, name, descriptor) {\n            if (descriptor.get) makeBuiltIn(descriptor.get, name, {\n                getter: true\n            });\n            if (descriptor.set) makeBuiltIn(descriptor.set, name, {\n                setter: true\n            });\n            return defineProperty.f(target, name, descriptor);\n        };\n    /***/ },\n    /***/ 2140: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31324__)=>{\n        var wellKnownSymbol = __nested_webpack_require_31324__(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var test = {};\n        test[TO_STRING_TAG] = \"z\";\n        module.exports = String(test) === \"[object z]\";\n    /***/ },\n    /***/ 2195: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31649__)=>{\n        var uncurryThis = __nested_webpack_require_31649__(9504);\n        var toString = uncurryThis({}.toString);\n        var stringSlice = uncurryThis(\"\".slice);\n        module.exports = function(it) {\n            return stringSlice(toString(it), 8, -1);\n        };\n    /***/ },\n    /***/ 2211: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31998__)=>{\n        var fails = __nested_webpack_require_31998__(9039);\n        module.exports = !fails(function() {\n            function F() {}\n            F.prototype.constructor = null;\n            // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n            return Object.getPrototypeOf(new F()) !== F.prototype;\n        });\n    /***/ },\n    /***/ 2303: /***/ (module, __unused_webpack_exports, __nested_webpack_require_32427__)=>{\n        var globalThis1 = __nested_webpack_require_32427__(4576);\n        var uncurryThis = __nested_webpack_require_32427__(9504);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var parseInt1 = globalThis1.parseInt;\n        var min = Math.min;\n        var NOT_HEX = /[^\\da-f]/i;\n        var exec = uncurryThis(NOT_HEX.exec);\n        var stringSlice = uncurryThis(\"\".slice);\n        module.exports = function(string, into) {\n            var stringLength = string.length;\n            if (stringLength % 2 !== 0) throw new SyntaxError1(\"String should be an even number of characters\");\n            var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;\n            var bytes = into || new Uint8Array1(maxLength);\n            var read = 0;\n            var written = 0;\n            while(written < maxLength){\n                var hexits = stringSlice(string, read, read += 2);\n                if (exec(NOT_HEX, hexits)) throw new SyntaxError1(\"String should only contain hex characters\");\n                bytes[written++] = parseInt1(hexits, 16);\n            }\n            return {\n                bytes: bytes,\n                read: read\n            };\n        };\n    /***/ },\n    /***/ 2360: /***/ (module, __unused_webpack_exports, __nested_webpack_require_33742__)=>{\n        /* global ActiveXObject -- old IE, WSH */ var anObject = __nested_webpack_require_33742__(8551);\n        var definePropertiesModule = __nested_webpack_require_33742__(6801);\n        var enumBugKeys = __nested_webpack_require_33742__(8727);\n        var hiddenKeys = __nested_webpack_require_33742__(421);\n        var html = __nested_webpack_require_33742__(397);\n        var documentCreateElement = __nested_webpack_require_33742__(4055);\n        var sharedKey = __nested_webpack_require_33742__(6119);\n        var GT = \">\";\n        var LT = \"<\";\n        var PROTOTYPE = \"prototype\";\n        var SCRIPT = \"script\";\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var EmptyConstructor = function() {};\n        var scriptTag = function(content) {\n            return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n        };\n        // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n        var NullProtoObjectViaActiveX = function(activeXDocument) {\n            activeXDocument.write(scriptTag(\"\"));\n            activeXDocument.close();\n            var temp = activeXDocument.parentWindow.Object;\n            // eslint-disable-next-line no-useless-assignment -- avoid memory leak\n            activeXDocument = null;\n            return temp;\n        };\n        // Create object with fake `null` prototype: use iframe Object with cleared prototype\n        var NullProtoObjectViaIFrame = function() {\n            // Thrash, waste and sodomy: IE GC bug\n            var iframe = documentCreateElement(\"iframe\");\n            var JS = \"java\" + SCRIPT + \":\";\n            var iframeDocument;\n            iframe.style.display = \"none\";\n            html.appendChild(iframe);\n            // https://github.com/zloirock/core-js/issues/475\n            iframe.src = String(JS);\n            iframeDocument = iframe.contentWindow.document;\n            iframeDocument.open();\n            iframeDocument.write(scriptTag(\"document.F=Object\"));\n            iframeDocument.close();\n            return iframeDocument.F;\n        };\n        // Check for document.domain and active x support\n        // No need to use active x approach when document.domain is not set\n        // see https://github.com/es-shims/es5-shim/issues/150\n        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n        // avoid IE GC bug\n        var activeXDocument;\n        var NullProtoObject = function() {\n            try {\n                activeXDocument = new ActiveXObject(\"htmlfile\");\n            } catch (error) {}\n            NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n             : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n            var length = enumBugKeys.length;\n            while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n            return NullProtoObject();\n        };\n        hiddenKeys[IE_PROTO] = true;\n        // `Object.create` method\n        // https://tc39.es/ecma262/#sec-object.create\n        // eslint-disable-next-line es/no-object-create -- safe\n        module.exports = Object.create || function create(O, Properties) {\n            var result;\n            if (O !== null) {\n                EmptyConstructor[PROTOTYPE] = anObject(O);\n                result = new EmptyConstructor();\n                EmptyConstructor[PROTOTYPE] = null;\n                // add \"__proto__\" for Object.getPrototypeOf polyfill\n                result[IE_PROTO] = O;\n            } else result = NullProtoObject();\n            return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n        };\n    /***/ },\n    /***/ 2475: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_37490__)=>{\n        var $ = __nested_webpack_require_37490__(6518);\n        var isSupersetOf = __nested_webpack_require_37490__(8527);\n        var setMethodAcceptSetLike = __nested_webpack_require_37490__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSupersetOf\", function(result) {\n            return !result;\n        });\n        // `Set.prototype.isSupersetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issupersetof\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSupersetOf: isSupersetOf\n        });\n    /***/ },\n    /***/ 2489: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_38181__)=>{\n        var $ = __nested_webpack_require_38181__(6518);\n        var call = __nested_webpack_require_38181__(9565);\n        var aCallable = __nested_webpack_require_38181__(9306);\n        var anObject = __nested_webpack_require_38181__(8551);\n        var getIteratorDirect = __nested_webpack_require_38181__(1767);\n        var createIteratorProxy = __nested_webpack_require_38181__(9462);\n        var callWithSafeIterationClosing = __nested_webpack_require_38181__(6319);\n        var IS_PURE = __nested_webpack_require_38181__(6395);\n        var iteratorClose = __nested_webpack_require_38181__(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_38181__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_38181__(4549);\n        var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"filter\", function() {});\n        var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"filter\", TypeError);\n        var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var predicate = this.predicate;\n            var next = this.next;\n            var result, done, value;\n            while(true){\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n                value = result.value;\n                if (callWithSafeIterationClosing(iterator, predicate, [\n                    value,\n                    this.counter++\n                ], true)) return value;\n            }\n        });\n        // `Iterator.prototype.filter` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.filter\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            filter: function filter(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    predicate: predicate\n                });\n            }\n        });\n    /***/ },\n    /***/ 2529: /***/ (module)=>{\n        // `CreateIterResultObject` abstract operation\n        // https://tc39.es/ecma262/#sec-createiterresultobject\n        module.exports = function(value, done) {\n            return {\n                value: value,\n                done: done\n            };\n        };\n    /***/ },\n    /***/ 2603: /***/ (module, __unused_webpack_exports, __nested_webpack_require_41049__)=>{\n        var toString = __nested_webpack_require_41049__(655);\n        module.exports = function(argument, $default) {\n            return argument === undefined ? arguments.length < 2 ? \"\" : $default : toString(argument);\n        };\n    /***/ },\n    /***/ 2652: /***/ (module, __unused_webpack_exports, __nested_webpack_require_41362__)=>{\n        var bind = __nested_webpack_require_41362__(6080);\n        var call = __nested_webpack_require_41362__(9565);\n        var anObject = __nested_webpack_require_41362__(8551);\n        var tryToString = __nested_webpack_require_41362__(6823);\n        var isArrayIteratorMethod = __nested_webpack_require_41362__(4209);\n        var lengthOfArrayLike = __nested_webpack_require_41362__(6198);\n        var isPrototypeOf = __nested_webpack_require_41362__(1625);\n        var getIterator = __nested_webpack_require_41362__(81);\n        var getIteratorMethod = __nested_webpack_require_41362__(851);\n        var iteratorClose = __nested_webpack_require_41362__(9539);\n        var $TypeError = TypeError;\n        var Result = function(stopped, result) {\n            this.stopped = stopped;\n            this.result = result;\n        };\n        var ResultPrototype = Result.prototype;\n        module.exports = function(iterable, unboundFunction, options) {\n            var that = options && options.that;\n            var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n            var IS_RECORD = !!(options && options.IS_RECORD);\n            var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n            var INTERRUPTED = !!(options && options.INTERRUPTED);\n            var fn = bind(unboundFunction, that);\n            var iterator, iterFn, index, length, result, next, step;\n            var stop = function(condition) {\n                if (iterator) iteratorClose(iterator, \"normal\");\n                return new Result(true, condition);\n            };\n            var callFn = function(value) {\n                if (AS_ENTRIES) {\n                    anObject(value);\n                    return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n                }\n                return INTERRUPTED ? fn(value, stop) : fn(value);\n            };\n            if (IS_RECORD) {\n                iterator = iterable.iterator;\n            } else if (IS_ITERATOR) {\n                iterator = iterable;\n            } else {\n                iterFn = getIteratorMethod(iterable);\n                if (!iterFn) throw new $TypeError(tryToString(iterable) + \" is not iterable\");\n                // optimisation for array iterators\n                if (isArrayIteratorMethod(iterFn)) {\n                    for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){\n                        result = callFn(iterable[index]);\n                        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n                    }\n                    return new Result(false);\n                }\n                iterator = getIterator(iterable, iterFn);\n            }\n            next = IS_RECORD ? iterable.next : iterator.next;\n            while(!(step = call(next, iterator)).done){\n                try {\n                    result = callFn(step.value);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                if (typeof result == \"object\" && result && isPrototypeOf(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        };\n    /***/ },\n    /***/ 2777: /***/ (module, __unused_webpack_exports, __nested_webpack_require_44501__)=>{\n        var call = __nested_webpack_require_44501__(9565);\n        var isObject = __nested_webpack_require_44501__(34);\n        var isSymbol = __nested_webpack_require_44501__(757);\n        var getMethod = __nested_webpack_require_44501__(5966);\n        var ordinaryToPrimitive = __nested_webpack_require_44501__(4270);\n        var wellKnownSymbol = __nested_webpack_require_44501__(8227);\n        var $TypeError = TypeError;\n        var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n        // `ToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-toprimitive\n        module.exports = function(input, pref) {\n            if (!isObject(input) || isSymbol(input)) return input;\n            var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n            var result;\n            if (exoticToPrim) {\n                if (pref === undefined) pref = \"default\";\n                result = call(exoticToPrim, input, pref);\n                if (!isObject(result) || isSymbol(result)) return result;\n                throw new $TypeError(\"Can't convert object to primitive value\");\n            }\n            if (pref === undefined) pref = \"number\";\n            return ordinaryToPrimitive(input, pref);\n        };\n    /***/ },\n    /***/ 2787: /***/ (module, __unused_webpack_exports, __nested_webpack_require_45735__)=>{\n        var hasOwn = __nested_webpack_require_45735__(9297);\n        var isCallable = __nested_webpack_require_45735__(4901);\n        var toObject = __nested_webpack_require_45735__(8981);\n        var sharedKey = __nested_webpack_require_45735__(6119);\n        var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_45735__(2211);\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var $Object = Object;\n        var ObjectPrototype = $Object.prototype;\n        // `Object.getPrototypeOf` method\n        // https://tc39.es/ecma262/#sec-object.getprototypeof\n        // eslint-disable-next-line es/no-object-getprototypeof -- safe\n        module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {\n            var object = toObject(O);\n            if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n            var constructor = object.constructor;\n            if (isCallable(constructor) && object instanceof constructor) {\n                return constructor.prototype;\n            }\n            return object instanceof $Object ? ObjectPrototype : null;\n        };\n    /***/ },\n    /***/ 2796: /***/ (module, __unused_webpack_exports, __nested_webpack_require_46861__)=>{\n        var fails = __nested_webpack_require_46861__(9039);\n        var isCallable = __nested_webpack_require_46861__(4901);\n        var replacement = /#|\\.prototype\\./;\n        var isForced = function(feature, detection) {\n            var value = data[normalize(feature)];\n            return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n        };\n        var normalize = isForced.normalize = function(string) {\n            return String(string).replace(replacement, \".\").toLowerCase();\n        };\n        var data = isForced.data = {};\n        var NATIVE = isForced.NATIVE = \"N\";\n        var POLYFILL = isForced.POLYFILL = \"P\";\n        module.exports = isForced;\n    /***/ },\n    /***/ 2804: /***/ (module)=>{\n        var commonAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        var base64Alphabet = commonAlphabet + \"+/\";\n        var base64UrlAlphabet = commonAlphabet + \"-_\";\n        var inverse = function(characters) {\n            // TODO: use `Object.create(null)` in `core-js@4`\n            var result = {};\n            var index = 0;\n            for(; index < 64; index++)result[characters.charAt(index)] = index;\n            return result;\n        };\n        module.exports = {\n            i2c: base64Alphabet,\n            c2i: inverse(base64Alphabet),\n            i2cUrl: base64UrlAlphabet,\n            c2iUrl: inverse(base64UrlAlphabet)\n        };\n    /***/ },\n    /***/ 2812: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(passed, required) {\n            if (passed < required) throw new $TypeError(\"Not enough arguments\");\n            return passed;\n        };\n    /***/ },\n    /***/ 2839: /***/ (module, __unused_webpack_exports, __nested_webpack_require_48645__)=>{\n        var globalThis1 = __nested_webpack_require_48645__(4576);\n        var navigator1 = globalThis1.navigator;\n        var userAgent = navigator1 && navigator1.userAgent;\n        module.exports = userAgent ? String(userAgent) : \"\";\n    /***/ },\n    /***/ 2967: /***/ (module, __unused_webpack_exports, __nested_webpack_require_48961__)=>{\n        /* eslint-disable no-proto -- safe */ var uncurryThisAccessor = __nested_webpack_require_48961__(6706);\n        var isObject = __nested_webpack_require_48961__(34);\n        var requireObjectCoercible = __nested_webpack_require_48961__(7750);\n        var aPossiblePrototype = __nested_webpack_require_48961__(3506);\n        // `Object.setPrototypeOf` method\n        // https://tc39.es/ecma262/#sec-object.setprototypeof\n        // Works with __proto__ only. Old v8 can't work with null proto objects.\n        // eslint-disable-next-line es/no-object-setprototypeof -- safe\n        module.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n            var CORRECT_SETTER = false;\n            var test = {};\n            var setter;\n            try {\n                setter = uncurryThisAccessor(Object.prototype, \"__proto__\", \"set\");\n                setter(test, []);\n                CORRECT_SETTER = test instanceof Array;\n            } catch (error) {}\n            return function setPrototypeOf(O, proto) {\n                requireObjectCoercible(O);\n                aPossiblePrototype(proto);\n                if (!isObject(O)) return O;\n                if (CORRECT_SETTER) setter(O, proto);\n                else O.__proto__ = proto;\n                return O;\n            };\n        }() : undefined);\n    /***/ },\n    /***/ 3068: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_50346__)=>{\n        // based on Shewchuk's algorithm for exactly floating point addition\n        // adapted from https://github.com/tc39/proposal-math-sum/blob/3513d58323a1ae25560e8700aa5294500c6c9287/polyfill/polyfill.mjs\n        var $ = __nested_webpack_require_50346__(6518);\n        var uncurryThis = __nested_webpack_require_50346__(9504);\n        var iterate = __nested_webpack_require_50346__(2652);\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var $Infinity = Infinity;\n        var $NaN = NaN;\n        var abs = Math.abs;\n        var pow = Math.pow;\n        var push = uncurryThis([].push);\n        var POW_2_1023 = pow(2, 1023);\n        var MAX_SAFE_INTEGER = pow(2, 53) - 1; // 2 ** 53 - 1 === 9007199254740992\n        var MAX_DOUBLE = Number.MAX_VALUE; // 2 ** 1024 - 2 ** (1023 - 52) === 1.79769313486231570815e+308\n        var MAX_ULP = pow(2, 971); // 2 ** (1023 - 52) === 1.99584030953471981166e+292\n        var NOT_A_NUMBER = {};\n        var MINUS_INFINITY = {};\n        var PLUS_INFINITY = {};\n        var MINUS_ZERO = {};\n        var FINITE = {};\n        // prerequisite: abs(x) >= abs(y)\n        var twosum = function(x, y) {\n            var hi = x + y;\n            var lo = y - (hi - x);\n            return {\n                hi: hi,\n                lo: lo\n            };\n        };\n        // `Math.sumPrecise` method\n        // https://github.com/tc39/proposal-math-sum\n        $({\n            target: \"Math\",\n            stat: true\n        }, {\n            // eslint-disable-next-line max-statements -- ok\n            sumPrecise: function sumPrecise(items) {\n                var numbers = [];\n                var count = 0;\n                var state = MINUS_ZERO;\n                iterate(items, function(n) {\n                    if (++count >= MAX_SAFE_INTEGER) throw new $RangeError(\"Maximum allowed index exceeded\");\n                    if (typeof n != \"number\") throw new $TypeError(\"Value is not a number\");\n                    if (state !== NOT_A_NUMBER) {\n                        // eslint-disable-next-line no-self-compare -- NaN check\n                        if (n !== n) state = NOT_A_NUMBER;\n                        else if (n === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;\n                        else if (n === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;\n                        else if ((n !== 0 || 1 / n === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {\n                            state = FINITE;\n                            push(numbers, n);\n                        }\n                    }\n                });\n                switch(state){\n                    case NOT_A_NUMBER:\n                        return $NaN;\n                    case MINUS_INFINITY:\n                        return -$Infinity;\n                    case PLUS_INFINITY:\n                        return $Infinity;\n                    case MINUS_ZERO:\n                        return -0;\n                }\n                var partials = [];\n                var overflow = 0; // conceptually 2 ** 1024 times this value; the final partial is biased by this amount\n                var x, y, sum, hi, lo, tmp;\n                for(var i = 0; i < numbers.length; i++){\n                    x = numbers[i];\n                    var actuallyUsedPartials = 0;\n                    for(var j = 0; j < partials.length; j++){\n                        y = partials[j];\n                        if (abs(x) < abs(y)) {\n                            tmp = x;\n                            x = y;\n                            y = tmp;\n                        }\n                        sum = twosum(x, y);\n                        hi = sum.hi;\n                        lo = sum.lo;\n                        if (abs(hi) === $Infinity) {\n                            var sign = hi === $Infinity ? 1 : -1;\n                            overflow += sign;\n                            x = x - sign * POW_2_1023 - sign * POW_2_1023;\n                            if (abs(x) < abs(y)) {\n                                tmp = x;\n                                x = y;\n                                y = tmp;\n                            }\n                            sum = twosum(x, y);\n                            hi = sum.hi;\n                            lo = sum.lo;\n                        }\n                        if (lo !== 0) partials[actuallyUsedPartials++] = lo;\n                        x = hi;\n                    }\n                    partials.length = actuallyUsedPartials;\n                    if (x !== 0) push(partials, x);\n                }\n                // compute the exact sum of partials, stopping once we lose precision\n                var n = partials.length - 1;\n                hi = 0;\n                lo = 0;\n                if (overflow !== 0) {\n                    var next = n >= 0 ? partials[n] : 0;\n                    n--;\n                    if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {\n                        return overflow > 0 ? $Infinity : -$Infinity;\n                    }\n                    // here we actually have to do the arithmetic\n                    // drop a factor of 2 so we can do it without overflow\n                    // assert(abs(overflow) === 1)\n                    sum = twosum(overflow * POW_2_1023, next / 2);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    lo *= 2;\n                    if (abs(2 * hi) === $Infinity) {\n                        // rounding to the maximum value\n                        if (hi > 0) {\n                            return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;\n                        }\n                        return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;\n                    }\n                    if (lo !== 0) {\n                        partials[++n] = lo;\n                        lo = 0;\n                    }\n                    hi *= 2;\n                }\n                while(n >= 0){\n                    sum = twosum(hi, partials[n--]);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    if (lo !== 0) break;\n                }\n                if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {\n                    y = lo * 2;\n                    x = hi + y;\n                    if (y === x - hi) hi = x;\n                }\n                return hi;\n            }\n        });\n    /***/ },\n    /***/ 3167: /***/ (module, __unused_webpack_exports, __nested_webpack_require_56987__)=>{\n        var isCallable = __nested_webpack_require_56987__(4901);\n        var isObject = __nested_webpack_require_56987__(34);\n        var setPrototypeOf = __nested_webpack_require_56987__(2967);\n        // makes subclassing work correct for wrapped built-ins\n        module.exports = function($this, dummy, Wrapper) {\n            var NewTarget, NewTargetPrototype;\n            if (// it can work only with native `setPrototypeOf`\n            setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n            return $this;\n        };\n    /***/ },\n    /***/ 3238: /***/ (module, __unused_webpack_exports, __nested_webpack_require_57843__)=>{\n        var globalThis1 = __nested_webpack_require_57843__(4576);\n        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_57843__(7811);\n        var arrayBufferByteLength = __nested_webpack_require_57843__(7394);\n        var DataView1 = globalThis1.DataView;\n        module.exports = function(O) {\n            if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;\n            try {\n                // eslint-disable-next-line no-new -- thrower\n                new DataView1(O);\n                return false;\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 3392: /***/ (module, __unused_webpack_exports, __nested_webpack_require_58513__)=>{\n        var uncurryThis = __nested_webpack_require_58513__(9504);\n        var id = 0;\n        var postfix = Math.random();\n        var toString = uncurryThis(1.1.toString);\n        module.exports = function(key) {\n            return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString(++id + postfix, 36);\n        };\n    /***/ },\n    /***/ 3440: /***/ (module, __unused_webpack_exports, __nested_webpack_require_58920__)=>{\n        var aSet = __nested_webpack_require_58920__(7080);\n        var SetHelpers = __nested_webpack_require_58920__(4402);\n        var clone = __nested_webpack_require_58920__(9286);\n        var size = __nested_webpack_require_58920__(5170);\n        var getSetRecord = __nested_webpack_require_58920__(3789);\n        var iterateSet = __nested_webpack_require_58920__(8469);\n        var iterateSimple = __nested_webpack_require_58920__(507);\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        // `Set.prototype.difference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.difference\n        module.exports = function difference(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = clone(O);\n            if (size(O) <= otherRec.size) iterateSet(O, function(e) {\n                if (otherRec.includes(e)) remove(result, e);\n            });\n            else iterateSimple(otherRec.getIterator(), function(e) {\n                if (has(result, e)) remove(result, e);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 3463: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (typeof argument == \"string\") return argument;\n            throw new $TypeError(\"Argument is not a string\");\n        };\n    /***/ },\n    /***/ 3506: /***/ (module, __unused_webpack_exports, __nested_webpack_require_60307__)=>{\n        var isPossiblePrototype = __nested_webpack_require_60307__(3925);\n        var $String = String;\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (isPossiblePrototype(argument)) return argument;\n            throw new $TypeError(\"Can't set \" + $String(argument) + \" as a prototype\");\n        };\n    /***/ },\n    /***/ 3579: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_60754__)=>{\n        var $ = __nested_webpack_require_60754__(6518);\n        var call = __nested_webpack_require_60754__(9565);\n        var iterate = __nested_webpack_require_60754__(2652);\n        var aCallable = __nested_webpack_require_60754__(9306);\n        var anObject = __nested_webpack_require_60754__(8551);\n        var getIteratorDirect = __nested_webpack_require_60754__(1767);\n        var iteratorClose = __nested_webpack_require_60754__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_60754__(4549);\n        var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"some\", TypeError);\n        // `Iterator.prototype.some` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.some\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: someWithoutClosingOnEarlyError\n        }, {\n            some: function some(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value, stop) {\n                    if (predicate(value, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    /***/ },\n    /***/ 3650: /***/ (module, __unused_webpack_exports, __nested_webpack_require_62386__)=>{\n        var aSet = __nested_webpack_require_62386__(7080);\n        var SetHelpers = __nested_webpack_require_62386__(4402);\n        var clone = __nested_webpack_require_62386__(9286);\n        var getSetRecord = __nested_webpack_require_62386__(3789);\n        var iterateSimple = __nested_webpack_require_62386__(507);\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        // `Set.prototype.symmetricDifference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.symmetricdifference\n        module.exports = function symmetricDifference(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(e) {\n                if (has(O, e)) remove(result, e);\n                else add(result, e);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 3706: /***/ (module, __unused_webpack_exports, __nested_webpack_require_63352__)=>{\n        var uncurryThis = __nested_webpack_require_63352__(9504);\n        var isCallable = __nested_webpack_require_63352__(4901);\n        var store = __nested_webpack_require_63352__(7629);\n        var functionToString = uncurryThis(Function.toString);\n        // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n        if (!isCallable(store.inspectSource)) {\n            store.inspectSource = function(it) {\n                return functionToString(it);\n            };\n        }\n        module.exports = store.inspectSource;\n    /***/ },\n    /***/ 3717: /***/ (__unused_webpack_module, exports)=>{\n        // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\n        exports.f = Object.getOwnPropertySymbols;\n    /***/ },\n    /***/ 3724: /***/ (module, __unused_webpack_exports, __nested_webpack_require_64164__)=>{\n        var fails = __nested_webpack_require_64164__(9039);\n        // Detect IE8's incomplete defineProperty implementation\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty({}, 1, {\n                get: function() {\n                    return 7;\n                }\n            })[1] !== 7;\n        });\n    /***/ },\n    /***/ 3789: /***/ (module, __unused_webpack_exports, __nested_webpack_require_64676__)=>{\n        var aCallable = __nested_webpack_require_64676__(9306);\n        var anObject = __nested_webpack_require_64676__(8551);\n        var call = __nested_webpack_require_64676__(9565);\n        var toIntegerOrInfinity = __nested_webpack_require_64676__(1291);\n        var getIteratorDirect = __nested_webpack_require_64676__(1767);\n        var INVALID_SIZE = \"Invalid size\";\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var max = Math.max;\n        var SetRecord = function(set, intSize) {\n            this.set = set;\n            this.size = max(intSize, 0);\n            this.has = aCallable(set.has);\n            this.keys = aCallable(set.keys);\n        };\n        SetRecord.prototype = {\n            getIterator: function() {\n                return getIteratorDirect(anObject(call(this.keys, this.set)));\n            },\n            includes: function(it) {\n                return call(this.has, this.set, it);\n            }\n        };\n        // `GetSetRecord` abstract operation\n        // https://tc39.es/proposal-set-methods/#sec-getsetrecord\n        module.exports = function(obj) {\n            anObject(obj);\n            var numSize = +obj.size;\n            // NOTE: If size is undefined, then numSize will be NaN\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);\n            var intSize = toIntegerOrInfinity(numSize);\n            if (intSize < 0) throw new $RangeError(INVALID_SIZE);\n            return new SetRecord(obj, intSize);\n        };\n    /***/ },\n    /***/ 3838: /***/ (module, __unused_webpack_exports, __nested_webpack_require_66285__)=>{\n        var aSet = __nested_webpack_require_66285__(7080);\n        var size = __nested_webpack_require_66285__(5170);\n        var iterate = __nested_webpack_require_66285__(8469);\n        var getSetRecord = __nested_webpack_require_66285__(3789);\n        // `Set.prototype.isSubsetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issubsetof\n        module.exports = function isSubsetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) > otherRec.size) return false;\n            return iterate(O, function(e) {\n                if (!otherRec.includes(e)) return false;\n            }, true) !== false;\n        };\n    /***/ },\n    /***/ 3853: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_67034__)=>{\n        var $ = __nested_webpack_require_67034__(6518);\n        var isDisjointFrom = __nested_webpack_require_67034__(4449);\n        var setMethodAcceptSetLike = __nested_webpack_require_67034__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isDisjointFrom\", function(result) {\n            return !result;\n        });\n        // `Set.prototype.isDisjointFrom` method\n        // https://tc39.es/ecma262/#sec-set.prototype.isdisjointfrom\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isDisjointFrom: isDisjointFrom\n        });\n    /***/ },\n    /***/ 3925: /***/ (module, __unused_webpack_exports, __nested_webpack_require_67720__)=>{\n        var isObject = __nested_webpack_require_67720__(34);\n        module.exports = function(argument) {\n            return isObject(argument) || argument === null;\n        };\n    /***/ },\n    /***/ 3972: /***/ (module, __unused_webpack_exports, __nested_webpack_require_67979__)=>{\n        var isObject = __nested_webpack_require_67979__(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (argument === undefined || isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object or undefined\");\n        };\n    /***/ },\n    /***/ 4055: /***/ (module, __unused_webpack_exports, __nested_webpack_require_68411__)=>{\n        var globalThis1 = __nested_webpack_require_68411__(4576);\n        var isObject = __nested_webpack_require_68411__(34);\n        var document1 = globalThis1.document;\n        // typeof document.createElement is 'object' in old IE\n        var EXISTS = isObject(document1) && isObject(document1.createElement);\n        module.exports = function(it) {\n            return EXISTS ? document1.createElement(it) : {};\n        };\n    /***/ },\n    /***/ 4114: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_68924__)=>{\n        var $ = __nested_webpack_require_68924__(6518);\n        var toObject = __nested_webpack_require_68924__(8981);\n        var lengthOfArrayLike = __nested_webpack_require_68924__(6198);\n        var setArrayLength = __nested_webpack_require_68924__(4527);\n        var doesNotExceedSafeInteger = __nested_webpack_require_68924__(6837);\n        var fails = __nested_webpack_require_68924__(9039);\n        var INCORRECT_TO_LENGTH = fails(function() {\n            return [].push.call({\n                length: 0x100000000\n            }, 1) !== 4294967297;\n        });\n        // V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError\n        // https://bugs.chromium.org/p/v8/issues/detail?id=12681\n        var properErrorOnNonWritableLength = function() {\n            try {\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).push();\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        };\n        var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n        // `Array.prototype.push` method\n        // https://tc39.es/ecma262/#sec-array.prototype.push\n        $({\n            target: \"Array\",\n            proto: true,\n            arity: 1,\n            forced: FORCED\n        }, {\n            // eslint-disable-next-line no-unused-vars -- required for `.length`\n            push: function push(item) {\n                var O = toObject(this);\n                var len = lengthOfArrayLike(O);\n                var argCount = arguments.length;\n                doesNotExceedSafeInteger(len + argCount);\n                for(var i = 0; i < argCount; i++){\n                    O[len] = arguments[i];\n                    len++;\n                }\n                setArrayLength(O, len);\n                return len;\n            }\n        });\n    /***/ },\n    /***/ 4117: /***/ (module)=>{\n        // we can't use just `it == null` since of `document.all` special case\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\n        module.exports = function(it) {\n            return it === null || it === undefined;\n        };\n    /***/ },\n    /***/ 4149: /***/ (module)=>{\n        var $RangeError = RangeError;\n        module.exports = function(it) {\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (it === it) return it;\n            throw new $RangeError(\"NaN is not allowed\");\n        };\n    /***/ },\n    /***/ 4154: /***/ (module, __unused_webpack_exports, __nested_webpack_require_71477__)=>{\n        var classof = __nested_webpack_require_71477__(6955);\n        var $TypeError = TypeError;\n        // Perform ? RequireInternalSlot(argument, [[TypedArrayName]])\n        // If argument.[[TypedArrayName]] is not \"Uint8Array\", throw a TypeError exception\n        module.exports = function(argument) {\n            if (classof(argument) === \"Uint8Array\") return argument;\n            throw new $TypeError(\"Argument is not an Uint8Array\");\n        };\n    /***/ },\n    /***/ 4204: /***/ (module, __unused_webpack_exports, __nested_webpack_require_72011__)=>{\n        var aSet = __nested_webpack_require_72011__(7080);\n        var add = __nested_webpack_require_72011__(4402).add;\n        var clone = __nested_webpack_require_72011__(9286);\n        var getSetRecord = __nested_webpack_require_72011__(3789);\n        var iterateSimple = __nested_webpack_require_72011__(507);\n        // `Set.prototype.union` method\n        // https://tc39.es/ecma262/#sec-set.prototype.union\n        module.exports = function union(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 4209: /***/ (module, __unused_webpack_exports, __nested_webpack_require_72771__)=>{\n        var wellKnownSymbol = __nested_webpack_require_72771__(8227);\n        var Iterators = __nested_webpack_require_72771__(6269);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var ArrayPrototype = Array.prototype;\n        // check on default Array iterator\n        module.exports = function(it) {\n            return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n        };\n    /***/ },\n    /***/ 4215: /***/ (module, __unused_webpack_exports, __nested_webpack_require_73265__)=>{\n        /* global Bun, Deno -- detection */ var globalThis1 = __nested_webpack_require_73265__(4576);\n        var userAgent = __nested_webpack_require_73265__(2839);\n        var classof = __nested_webpack_require_73265__(2195);\n        var userAgentStartsWith = function(string) {\n            return userAgent.slice(0, string.length) === string;\n        };\n        module.exports = function() {\n            if (userAgentStartsWith(\"Bun/\")) return \"BUN\";\n            if (userAgentStartsWith(\"Cloudflare-Workers\")) return \"CLOUDFLARE\";\n            if (userAgentStartsWith(\"Deno/\")) return \"DENO\";\n            if (userAgentStartsWith(\"Node.js/\")) return \"NODE\";\n            if (globalThis1.Bun && typeof Bun.version == \"string\") return \"BUN\";\n            if (globalThis1.Deno && typeof Deno.version == \"object\") return \"DENO\";\n            if (classof(globalThis1.process) === \"process\") return \"NODE\";\n            if (globalThis1.window && globalThis1.document) return \"BROWSER\";\n            return \"REST\";\n        }();\n    /***/ },\n    /***/ 4226: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_74354__)=>{\n        var $ = __nested_webpack_require_74354__(6518);\n        var globalThis1 = __nested_webpack_require_74354__(4576);\n        var aString = __nested_webpack_require_74354__(3463);\n        var anUint8Array = __nested_webpack_require_74354__(4154);\n        var notDetached = __nested_webpack_require_74354__(5169);\n        var $fromHex = __nested_webpack_require_74354__(2303);\n        // `Uint8Array.prototype.setFromHex` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (globalThis1.Uint8Array) $({\n            target: \"Uint8Array\",\n            proto: true\n        }, {\n            setFromHex: function setFromHex(string) {\n                anUint8Array(this);\n                aString(string);\n                notDetached(this.buffer);\n                var read = $fromHex(string, this).read;\n                return {\n                    read: read,\n                    written: read / 2\n                };\n            }\n        });\n    /***/ },\n    /***/ 4235: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_75354__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_75354__(3068);\n    /***/ },\n    /***/ 4270: /***/ (module, __unused_webpack_exports, __nested_webpack_require_75524__)=>{\n        var call = __nested_webpack_require_75524__(9565);\n        var isCallable = __nested_webpack_require_75524__(4901);\n        var isObject = __nested_webpack_require_75524__(34);\n        var $TypeError = TypeError;\n        // `OrdinaryToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n        module.exports = function(input, pref) {\n            var fn, val;\n            if (pref === \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n            if (pref !== \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            throw new $TypeError(\"Can't convert object to primitive value\");\n        };\n    /***/ },\n    /***/ 4376: /***/ (module, __unused_webpack_exports, __nested_webpack_require_76406__)=>{\n        var classof = __nested_webpack_require_76406__(2195);\n        // `IsArray` abstract operation\n        // https://tc39.es/ecma262/#sec-isarray\n        // eslint-disable-next-line es/no-array-isarray -- safe\n        module.exports = Array.isArray || function isArray(argument) {\n            return classof(argument) === \"Array\";\n        };\n    /***/ },\n    /***/ 4402: /***/ (module, __unused_webpack_exports, __nested_webpack_require_76833__)=>{\n        var uncurryThis = __nested_webpack_require_76833__(9504);\n        // eslint-disable-next-line es/no-set -- safe\n        var SetPrototype = Set.prototype;\n        module.exports = {\n            // eslint-disable-next-line es/no-set -- safe\n            Set: Set,\n            add: uncurryThis(SetPrototype.add),\n            has: uncurryThis(SetPrototype.has),\n            remove: uncurryThis(SetPrototype[\"delete\"]),\n            proto: SetPrototype\n        };\n    /***/ },\n    /***/ 4449: /***/ (module, __unused_webpack_exports, __nested_webpack_require_77379__)=>{\n        var aSet = __nested_webpack_require_77379__(7080);\n        var has = __nested_webpack_require_77379__(4402).has;\n        var size = __nested_webpack_require_77379__(5170);\n        var getSetRecord = __nested_webpack_require_77379__(3789);\n        var iterateSet = __nested_webpack_require_77379__(8469);\n        var iterateSimple = __nested_webpack_require_77379__(507);\n        var iteratorClose = __nested_webpack_require_77379__(9539);\n        // `Set.prototype.isDisjointFrom` method\n        // https://tc39.es/ecma262/#sec-set.prototype.isdisjointfrom\n        module.exports = function isDisjointFrom(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) <= otherRec.size) return iterateSet(O, function(e) {\n                if (otherRec.includes(e)) return false;\n            }, true) !== false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    /***/ },\n    /***/ 4483: /***/ (module, __unused_webpack_exports, __nested_webpack_require_78475__)=>{\n        var globalThis1 = __nested_webpack_require_78475__(4576);\n        var getBuiltInNodeModule = __nested_webpack_require_78475__(9429);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __nested_webpack_require_78475__(1548);\n        var structuredClone1 = globalThis1.structuredClone;\n        var $ArrayBuffer = globalThis1.ArrayBuffer;\n        var $MessageChannel = globalThis1.MessageChannel;\n        var detach = false;\n        var WorkerThreads, channel, buffer, $detach;\n        if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n            detach = function(transferable) {\n                structuredClone1(transferable, {\n                    transfer: [\n                        transferable\n                    ]\n                });\n            };\n        } else if ($ArrayBuffer) try {\n            if (!$MessageChannel) {\n                WorkerThreads = getBuiltInNodeModule(\"worker_threads\");\n                if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;\n            }\n            if ($MessageChannel) {\n                channel = new $MessageChannel();\n                buffer = new $ArrayBuffer(2);\n                $detach = function(transferable) {\n                    channel.port1.postMessage(null, [\n                        transferable\n                    ]);\n                };\n                if (buffer.byteLength === 2) {\n                    $detach(buffer);\n                    if (buffer.byteLength === 0) detach = $detach;\n                }\n            }\n        } catch (error) {}\n        module.exports = detach;\n    /***/ },\n    /***/ 4495: /***/ (module, __unused_webpack_exports, __nested_webpack_require_80080__)=>{\n        /* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __nested_webpack_require_80080__(9519);\n        var fails = __nested_webpack_require_80080__(9039);\n        var globalThis1 = __nested_webpack_require_80080__(4576);\n        var $String = globalThis1.String;\n        // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\n        module.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n            var symbol = Symbol(\"symbol detection\");\n            // Chrome 38 Symbol has incorrect toString conversion\n            // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n            // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n            // of course, fail.\n            return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n            !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n        });\n    /***/ },\n    /***/ 4527: /***/ (module, __unused_webpack_exports, __nested_webpack_require_81201__)=>{\n        var DESCRIPTORS = __nested_webpack_require_81201__(3724);\n        var isArray = __nested_webpack_require_81201__(4376);\n        var $TypeError = TypeError;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // Safari < 13 does not throw an error in this case\n        var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {\n            // makes no sense without proper strict mode support\n            if (this !== undefined) return true;\n            try {\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).length = 1;\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        }();\n        module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {\n            if (isArray(O) && !getOwnPropertyDescriptor(O, \"length\").writable) {\n                throw new $TypeError(\"Cannot set read only .length\");\n            }\n            return O.length = length;\n        } : function(O, length) {\n            return O.length = length;\n        };\n    /***/ },\n    /***/ 4549: /***/ (module, __unused_webpack_exports, __nested_webpack_require_82534__)=>{\n        var globalThis1 = __nested_webpack_require_82534__(4576);\n        // https://github.com/tc39/ecma262/pull/3467\n        module.exports = function(METHOD_NAME, ExpectedError) {\n            var Iterator1 = globalThis1.Iterator;\n            var IteratorPrototype = Iterator1 && Iterator1.prototype;\n            var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];\n            var CLOSED = false;\n            if (method) try {\n                method.call({\n                    next: function() {\n                        return {\n                            done: true\n                        };\n                    },\n                    \"return\": function() {\n                        CLOSED = true;\n                    }\n                }, -1);\n            } catch (error) {\n                // https://bugs.webkit.org/show_bug.cgi?id=291195\n                if (!(error instanceof ExpectedError)) CLOSED = false;\n            }\n            if (!CLOSED) return method;\n        };\n    /***/ },\n    /***/ 4576: /***/ function(module) {\n        var check = function(it) {\n            return it && it.Math === Math && it;\n        };\n        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n        module.exports = // eslint-disable-next-line es/no-global-this -- safe\n        check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n        check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || check(typeof this == \"object\" && this) || // eslint-disable-next-line no-new-func -- fallback\n        function() {\n            return this;\n        }() || Function(\"return this\")();\n    /***/ },\n    /***/ 4603: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_84376__)=>{\n        var defineBuiltIn = __nested_webpack_require_84376__(6840);\n        var uncurryThis = __nested_webpack_require_84376__(9504);\n        var toString = __nested_webpack_require_84376__(655);\n        var validateArgumentsLength = __nested_webpack_require_84376__(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var append = uncurryThis(URLSearchParamsPrototype.append);\n        var $delete = uncurryThis(URLSearchParamsPrototype[\"delete\"]);\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        var push = uncurryThis([].push);\n        var params = new $URLSearchParams(\"a=1&a=2&b=3\");\n        params[\"delete\"](\"a\", 1);\n        // `undefined` case is a Chromium 117 bug\n        // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n        params[\"delete\"](\"b\", undefined);\n        if (params + \"\" !== \"a=2\") {\n            defineBuiltIn(URLSearchParamsPrototype, \"delete\", function(name /* , value */ ) {\n                var length = arguments.length;\n                var $value = length < 2 ? undefined : arguments[1];\n                if (length && $value === undefined) return $delete(this, name);\n                var entries = [];\n                forEach(this, function(v, k) {\n                    push(entries, {\n                        key: k,\n                        value: v\n                    });\n                });\n                validateArgumentsLength(length, 1);\n                var key = toString(name);\n                var value = toString($value);\n                var index = 0;\n                var dindex = 0;\n                var found = false;\n                var entriesLength = entries.length;\n                var entry;\n                while(index < entriesLength){\n                    entry = entries[index++];\n                    if (found || entry.key === key) {\n                        found = true;\n                        $delete(this, entry.key);\n                    } else dindex++;\n                }\n                while(dindex < entriesLength){\n                    entry = entries[dindex++];\n                    if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);\n                }\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    /***/ },\n    /***/ 4628: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_86806__)=>{\n        var $ = __nested_webpack_require_86806__(6518);\n        var newPromiseCapabilityModule = __nested_webpack_require_86806__(6043);\n        // `Promise.withResolvers` method\n        // https://tc39.es/ecma262/#sec-promise.withResolvers\n        $({\n            target: \"Promise\",\n            stat: true\n        }, {\n            withResolvers: function withResolvers() {\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                return {\n                    promise: promiseCapability.promise,\n                    resolve: promiseCapability.resolve,\n                    reject: promiseCapability.reject\n                };\n            }\n        });\n    /***/ },\n    /***/ 4644: /***/ (module, __unused_webpack_exports, __nested_webpack_require_87559__)=>{\n        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_87559__(7811);\n        var DESCRIPTORS = __nested_webpack_require_87559__(3724);\n        var globalThis1 = __nested_webpack_require_87559__(4576);\n        var isCallable = __nested_webpack_require_87559__(4901);\n        var isObject = __nested_webpack_require_87559__(34);\n        var hasOwn = __nested_webpack_require_87559__(9297);\n        var classof = __nested_webpack_require_87559__(6955);\n        var tryToString = __nested_webpack_require_87559__(6823);\n        var createNonEnumerableProperty = __nested_webpack_require_87559__(6699);\n        var defineBuiltIn = __nested_webpack_require_87559__(6840);\n        var defineBuiltInAccessor = __nested_webpack_require_87559__(2106);\n        var isPrototypeOf = __nested_webpack_require_87559__(1625);\n        var getPrototypeOf = __nested_webpack_require_87559__(2787);\n        var setPrototypeOf = __nested_webpack_require_87559__(2967);\n        var wellKnownSymbol = __nested_webpack_require_87559__(8227);\n        var uid = __nested_webpack_require_87559__(3392);\n        var InternalStateModule = __nested_webpack_require_87559__(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var Int8Array1 = globalThis1.Int8Array;\n        var Int8ArrayPrototype = Int8Array1 && Int8Array1.prototype;\n        var Uint8ClampedArray1 = globalThis1.Uint8ClampedArray;\n        var Uint8ClampedArrayPrototype = Uint8ClampedArray1 && Uint8ClampedArray1.prototype;\n        var TypedArray = Int8Array1 && getPrototypeOf(Int8Array1);\n        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\n        var ObjectPrototype = Object.prototype;\n        var TypeError1 = globalThis1.TypeError;\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var TYPED_ARRAY_TAG = uid(\"TYPED_ARRAY_TAG\");\n        var TYPED_ARRAY_CONSTRUCTOR = \"TypedArrayConstructor\";\n        // Fixing native typed arrays in Opera Presto crashes the browser, see #595\n        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis1.opera) !== \"Opera\";\n        var TYPED_ARRAY_TAG_REQUIRED = false;\n        var NAME, Constructor, Prototype;\n        var TypedArrayConstructorsList = {\n            Int8Array: 1,\n            Uint8Array: 1,\n            Uint8ClampedArray: 1,\n            Int16Array: 2,\n            Uint16Array: 2,\n            Int32Array: 4,\n            Uint32Array: 4,\n            Float32Array: 4,\n            Float64Array: 8\n        };\n        var BigIntArrayConstructorsList = {\n            BigInt64Array: 8,\n            BigUint64Array: 8\n        };\n        var isView = function isView(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return klass === \"DataView\" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var getTypedArrayConstructor = function(it) {\n            var proto = getPrototypeOf(it);\n            if (!isObject(proto)) return;\n            var state = getInternalState(proto);\n            return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n        };\n        var isTypedArray = function(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var aTypedArray = function(it) {\n            if (isTypedArray(it)) return it;\n            throw new TypeError1(\"Target is not a typed array\");\n        };\n        var aTypedArrayConstructor = function(C) {\n            if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;\n            throw new TypeError1(tryToString(C) + \" is not a typed array constructor\");\n        };\n        var exportTypedArrayMethod = function(KEY, property, forced, options) {\n            if (!DESCRIPTORS) return;\n            if (forced) for(var ARRAY in TypedArrayConstructorsList){\n                var TypedArrayConstructor = globalThis1[ARRAY];\n                if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {\n                    delete TypedArrayConstructor.prototype[KEY];\n                } catch (error) {\n                    // old WebKit bug - some methods are non-configurable\n                    try {\n                        TypedArrayConstructor.prototype[KEY] = property;\n                    } catch (error2) {}\n                }\n            }\n            if (!TypedArrayPrototype[KEY] || forced) {\n                defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);\n            }\n        };\n        var exportTypedArrayStaticMethod = function(KEY, property, forced) {\n            var ARRAY, TypedArrayConstructor;\n            if (!DESCRIPTORS) return;\n            if (setPrototypeOf) {\n                if (forced) for(ARRAY in TypedArrayConstructorsList){\n                    TypedArrayConstructor = globalThis1[ARRAY];\n                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {\n                        delete TypedArrayConstructor[KEY];\n                    } catch (error) {}\n                }\n                if (!TypedArray[KEY] || forced) {\n                    // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n                    try {\n                        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);\n                    } catch (error) {}\n                } else return;\n            }\n            for(ARRAY in TypedArrayConstructorsList){\n                TypedArrayConstructor = globalThis1[ARRAY];\n                if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n                    defineBuiltIn(TypedArrayConstructor, KEY, property);\n                }\n            }\n        };\n        for(NAME in TypedArrayConstructorsList){\n            Constructor = globalThis1[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n            else NATIVE_ARRAY_BUFFER_VIEWS = false;\n        }\n        for(NAME in BigIntArrayConstructorsList){\n            Constructor = globalThis1[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n        }\n        // WebKit bug - typed arrays constructors prototype is Object.prototype\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {\n            // eslint-disable-next-line no-shadow -- safe\n            TypedArray = function TypedArray() {\n                throw new TypeError1(\"Incorrect invocation\");\n            };\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis1[NAME]) setPrototypeOf(globalThis1[NAME], TypedArray);\n            }\n        }\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n            TypedArrayPrototype = TypedArray.prototype;\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis1[NAME]) setPrototypeOf(globalThis1[NAME].prototype, TypedArrayPrototype);\n            }\n        }\n        // WebKit bug - one more object in Uint8ClampedArray prototype chain\n        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n            setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n        }\n        if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {\n            TYPED_ARRAY_TAG_REQUIRED = true;\n            defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {\n                configurable: true,\n                get: function() {\n                    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n                }\n            });\n            for(NAME in TypedArrayConstructorsList)if (globalThis1[NAME]) {\n                createNonEnumerableProperty(globalThis1[NAME], TYPED_ARRAY_TAG, NAME);\n            }\n        }\n        module.exports = {\n            NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n            TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,\n            aTypedArray: aTypedArray,\n            aTypedArrayConstructor: aTypedArrayConstructor,\n            exportTypedArrayMethod: exportTypedArrayMethod,\n            exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n            getTypedArrayConstructor: getTypedArrayConstructor,\n            isView: isView,\n            isTypedArray: isTypedArray,\n            TypedArray: TypedArray,\n            TypedArrayPrototype: TypedArrayPrototype\n        };\n    /***/ },\n    /***/ 4659: /***/ (module, __unused_webpack_exports, __nested_webpack_require_96551__)=>{\n        var DESCRIPTORS = __nested_webpack_require_96551__(3724);\n        var definePropertyModule = __nested_webpack_require_96551__(4913);\n        var createPropertyDescriptor = __nested_webpack_require_96551__(6980);\n        module.exports = function(object, key, value) {\n            if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));\n            else object[key] = value;\n        };\n    /***/ },\n    /***/ 4901: /***/ (module)=>{\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n        var documentAll = typeof document == \"object\" && document.all;\n        // `IsCallable` abstract operation\n        // https://tc39.es/ecma262/#sec-iscallable\n        // eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\n        module.exports = typeof documentAll == \"undefined\" && documentAll !== undefined ? function(argument) {\n            return typeof argument == \"function\" || argument === documentAll;\n        } : function(argument) {\n            return typeof argument == \"function\";\n        };\n    /***/ },\n    /***/ 4913: /***/ (__unused_webpack_module, exports, __nested_webpack_require_97680__)=>{\n        var DESCRIPTORS = __nested_webpack_require_97680__(3724);\n        var IE8_DOM_DEFINE = __nested_webpack_require_97680__(5917);\n        var V8_PROTOTYPE_DEFINE_BUG = __nested_webpack_require_97680__(8686);\n        var anObject = __nested_webpack_require_97680__(8551);\n        var toPropertyKey = __nested_webpack_require_97680__(6969);\n        var $TypeError = TypeError;\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var $defineProperty = Object.defineProperty;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var ENUMERABLE = \"enumerable\";\n        var CONFIGURABLE = \"configurable\";\n        var WRITABLE = \"writable\";\n        // `Object.defineProperty` method\n        // https://tc39.es/ecma262/#sec-object.defineproperty\n        exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n                var current = $getOwnPropertyDescriptor(O, P);\n                if (current && current[WRITABLE]) {\n                    O[P] = Attributes.value;\n                    Attributes = {\n                        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n                        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                        writable: false\n                    };\n                }\n            }\n            return $defineProperty(O, P, Attributes);\n        } : $defineProperty : function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (IE8_DOM_DEFINE) try {\n                return $defineProperty(O, P, Attributes);\n            } catch (error) {}\n            if (\"get\" in Attributes || \"set\" in Attributes) throw new $TypeError(\"Accessors not supported\");\n            if (\"value\" in Attributes) O[P] = Attributes.value;\n            return O;\n        };\n    /***/ },\n    /***/ 4916: /***/ (module, __unused_webpack_exports, __nested_webpack_require_99997__)=>{\n        var getBuiltIn = __nested_webpack_require_99997__(7751);\n        var createSetLike = function(size) {\n            return {\n                size: size,\n                has: function() {\n                    return false;\n                },\n                keys: function() {\n                    return {\n                        next: function() {\n                            return {\n                                done: true\n                            };\n                        }\n                    };\n                }\n            };\n        };\n        var createSetLikeWithInfinitySize = function(size) {\n            return {\n                size: size,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    throw new Error(\"e\");\n                }\n            };\n        };\n        module.exports = function(name, callback) {\n            var Set1 = getBuiltIn(\"Set\");\n            try {\n                new Set1()[name](createSetLike(0));\n                try {\n                    // late spec change, early WebKit ~ Safari 17 implementation does not pass it\n                    // https://github.com/tc39/proposal-set-methods/pull/88\n                    // also covered engines with\n                    // https://bugs.webkit.org/show_bug.cgi?id=272679\n                    new Set1()[name](createSetLike(-1));\n                    return false;\n                } catch (error2) {\n                    if (!callback) return true;\n                    // early V8 implementation bug\n                    // https://issues.chromium.org/issues/351332634\n                    try {\n                        new Set1()[name](createSetLikeWithInfinitySize(-Infinity));\n                        return false;\n                    } catch (error) {\n                        var set = new Set1();\n                        set.add(1);\n                        set.add(2);\n                        return callback(set[name](createSetLikeWithInfinitySize(Infinity)));\n                    }\n                }\n            } catch (error) {\n                return false;\n            }\n        };\n    /***/ },\n    /***/ 4972: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_102263__)=>{\n        var $ = __nested_webpack_require_102263__(6518);\n        var call = __nested_webpack_require_102263__(9565);\n        var anObject = __nested_webpack_require_102263__(8551);\n        var getIteratorDirect = __nested_webpack_require_102263__(1767);\n        var notANaN = __nested_webpack_require_102263__(4149);\n        var toPositiveInteger = __nested_webpack_require_102263__(9590);\n        var createIteratorProxy = __nested_webpack_require_102263__(9462);\n        var iteratorClose = __nested_webpack_require_102263__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_102263__(4549);\n        var IS_PURE = __nested_webpack_require_102263__(6395);\n        var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError(\"take\", RangeError);\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            if (!this.remaining--) {\n                this.done = true;\n                return iteratorClose(iterator, \"normal\", undefined);\n            }\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        // `Iterator.prototype.take` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.take\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: IS_PURE || takeWithoutClosingOnEarlyError\n        }, {\n            take: function take(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining: remaining\n                });\n            }\n        });\n    /***/ },\n    /***/ 4979: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_104319__)=>{\n        var $ = __nested_webpack_require_104319__(6518);\n        var globalThis1 = __nested_webpack_require_104319__(4576);\n        var getBuiltIn = __nested_webpack_require_104319__(7751);\n        var createPropertyDescriptor = __nested_webpack_require_104319__(6980);\n        var defineProperty = __nested_webpack_require_104319__(4913).f;\n        var hasOwn = __nested_webpack_require_104319__(9297);\n        var anInstance = __nested_webpack_require_104319__(679);\n        var inheritIfRequired = __nested_webpack_require_104319__(3167);\n        var normalizeStringArgument = __nested_webpack_require_104319__(2603);\n        var DOMExceptionConstants = __nested_webpack_require_104319__(5002);\n        var clearErrorStack = __nested_webpack_require_104319__(8574);\n        var DESCRIPTORS = __nested_webpack_require_104319__(3724);\n        var IS_PURE = __nested_webpack_require_104319__(6395);\n        var DOM_EXCEPTION = \"DOMException\";\n        var Error1 = getBuiltIn(\"Error\");\n        var NativeDOMException = getBuiltIn(DOM_EXCEPTION);\n        var $DOMException = function DOMException() {\n            anInstance(this, DOMExceptionPrototype);\n            var argumentsLength = arguments.length;\n            var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);\n            var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], \"Error\");\n            var that = new NativeDOMException(message, name);\n            var error = new Error1(message);\n            error.name = DOM_EXCEPTION;\n            defineProperty(that, \"stack\", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));\n            inheritIfRequired(that, this, $DOMException);\n            return that;\n        };\n        var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;\n        var ERROR_HAS_STACK = \"stack\" in new Error1(DOM_EXCEPTION);\n        var DOM_EXCEPTION_HAS_STACK = \"stack\" in new NativeDOMException(1, 2);\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis1, DOM_EXCEPTION);\n        // Bun ~ 0.1.1 DOMException have incorrect descriptor and we can't redefine it\n        // https://github.com/Jarred-Sumner/bun/issues/399\n        var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);\n        var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;\n        // `DOMException` constructor patch for `.stack` where it's required\n        // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n        $({\n            global: true,\n            constructor: true,\n            forced: IS_PURE || FORCED_CONSTRUCTOR\n        }, {\n            DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException\n        });\n        var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);\n        var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;\n        if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {\n            if (!IS_PURE) {\n                defineProperty(PolyfilledDOMExceptionPrototype, \"constructor\", createPropertyDescriptor(1, PolyfilledDOMException));\n            }\n            for(var key in DOMExceptionConstants)if (hasOwn(DOMExceptionConstants, key)) {\n                var constant = DOMExceptionConstants[key];\n                var constantName = constant.s;\n                if (!hasOwn(PolyfilledDOMException, constantName)) {\n                    defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));\n                }\n            }\n        }\n    /***/ },\n    /***/ 5002: /***/ (module)=>{\n        module.exports = {\n            IndexSizeError: {\n                s: \"INDEX_SIZE_ERR\",\n                c: 1,\n                m: 1\n            },\n            DOMStringSizeError: {\n                s: \"DOMSTRING_SIZE_ERR\",\n                c: 2,\n                m: 0\n            },\n            HierarchyRequestError: {\n                s: \"HIERARCHY_REQUEST_ERR\",\n                c: 3,\n                m: 1\n            },\n            WrongDocumentError: {\n                s: \"WRONG_DOCUMENT_ERR\",\n                c: 4,\n                m: 1\n            },\n            InvalidCharacterError: {\n                s: \"INVALID_CHARACTER_ERR\",\n                c: 5,\n                m: 1\n            },\n            NoDataAllowedError: {\n                s: \"NO_DATA_ALLOWED_ERR\",\n                c: 6,\n                m: 0\n            },\n            NoModificationAllowedError: {\n                s: \"NO_MODIFICATION_ALLOWED_ERR\",\n                c: 7,\n                m: 1\n            },\n            NotFoundError: {\n                s: \"NOT_FOUND_ERR\",\n                c: 8,\n                m: 1\n            },\n            NotSupportedError: {\n                s: \"NOT_SUPPORTED_ERR\",\n                c: 9,\n                m: 1\n            },\n            InUseAttributeError: {\n                s: \"INUSE_ATTRIBUTE_ERR\",\n                c: 10,\n                m: 1\n            },\n            InvalidStateError: {\n                s: \"INVALID_STATE_ERR\",\n                c: 11,\n                m: 1\n            },\n            SyntaxError: {\n                s: \"SYNTAX_ERR\",\n                c: 12,\n                m: 1\n            },\n            InvalidModificationError: {\n                s: \"INVALID_MODIFICATION_ERR\",\n                c: 13,\n                m: 1\n            },\n            NamespaceError: {\n                s: \"NAMESPACE_ERR\",\n                c: 14,\n                m: 1\n            },\n            InvalidAccessError: {\n                s: \"INVALID_ACCESS_ERR\",\n                c: 15,\n                m: 1\n            },\n            ValidationError: {\n                s: \"VALIDATION_ERR\",\n                c: 16,\n                m: 0\n            },\n            TypeMismatchError: {\n                s: \"TYPE_MISMATCH_ERR\",\n                c: 17,\n                m: 1\n            },\n            SecurityError: {\n                s: \"SECURITY_ERR\",\n                c: 18,\n                m: 1\n            },\n            NetworkError: {\n                s: \"NETWORK_ERR\",\n                c: 19,\n                m: 1\n            },\n            AbortError: {\n                s: \"ABORT_ERR\",\n                c: 20,\n                m: 1\n            },\n            URLMismatchError: {\n                s: \"URL_MISMATCH_ERR\",\n                c: 21,\n                m: 1\n            },\n            QuotaExceededError: {\n                s: \"QUOTA_EXCEEDED_ERR\",\n                c: 22,\n                m: 1\n            },\n            TimeoutError: {\n                s: \"TIMEOUT_ERR\",\n                c: 23,\n                m: 1\n            },\n            InvalidNodeTypeError: {\n                s: \"INVALID_NODE_TYPE_ERR\",\n                c: 24,\n                m: 1\n            },\n            DataCloneError: {\n                s: \"DATA_CLONE_ERR\",\n                c: 25,\n                m: 1\n            }\n        };\n    /***/ },\n    /***/ 5024: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_111344__)=>{\n        var $ = __nested_webpack_require_111344__(6518);\n        var symmetricDifference = __nested_webpack_require_111344__(3650);\n        var setMethodGetKeysBeforeCloning = __nested_webpack_require_111344__(9835);\n        var setMethodAcceptSetLike = __nested_webpack_require_111344__(4916);\n        var FORCED = !setMethodAcceptSetLike(\"symmetricDifference\") || !setMethodGetKeysBeforeCloning(\"symmetricDifference\");\n        // `Set.prototype.symmetricDifference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.symmetricdifference\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            symmetricDifference: symmetricDifference\n        });\n    /***/ },\n    /***/ 5031: /***/ (module, __unused_webpack_exports, __nested_webpack_require_112124__)=>{\n        var getBuiltIn = __nested_webpack_require_112124__(7751);\n        var uncurryThis = __nested_webpack_require_112124__(9504);\n        var getOwnPropertyNamesModule = __nested_webpack_require_112124__(8480);\n        var getOwnPropertySymbolsModule = __nested_webpack_require_112124__(3717);\n        var anObject = __nested_webpack_require_112124__(8551);\n        var concat = uncurryThis([].concat);\n        // all object keys, includes non-enumerable and symbols\n        module.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n            var keys = getOwnPropertyNamesModule.f(anObject(it));\n            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n            return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n        };\n    /***/ },\n    /***/ 5169: /***/ (module, __unused_webpack_exports, __nested_webpack_require_112941__)=>{\n        var isDetached = __nested_webpack_require_112941__(3238);\n        var $TypeError = TypeError;\n        module.exports = function(it) {\n            if (isDetached(it)) throw new $TypeError(\"ArrayBuffer is detached\");\n            return it;\n        };\n    /***/ },\n    /***/ 5170: /***/ (module, __unused_webpack_exports, __nested_webpack_require_113278__)=>{\n        var uncurryThisAccessor = __nested_webpack_require_113278__(6706);\n        var SetHelpers = __nested_webpack_require_113278__(4402);\n        module.exports = uncurryThisAccessor(SetHelpers.proto, \"size\", \"get\") || function(set) {\n            return set.size;\n        };\n    /***/ },\n    /***/ 5213: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_113639__)=>{\n        var $ = __nested_webpack_require_113639__(6518);\n        var globalThis1 = __nested_webpack_require_113639__(4576);\n        var arrayFromConstructorAndList = __nested_webpack_require_113639__(5370);\n        var $fromBase64 = __nested_webpack_require_113639__(9143);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.fromBase64 || !function() {\n            // Webkit not throw an error on odd length string\n            try {\n                Uint8Array1.fromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                Uint8Array1.fromBase64(\"\", null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `Uint8Array.fromBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            stat: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            fromBase64: function fromBase64(string /* , options */ ) {\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, null, 0x1FFFFFFFFFFFFF);\n                return arrayFromConstructorAndList(Uint8Array1, result.bytes);\n            }\n        });\n    /***/ },\n    /***/ 5370: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115002__)=>{\n        var lengthOfArrayLike = __nested_webpack_require_115002__(6198);\n        module.exports = function(Constructor, list, $length) {\n            var index = 0;\n            var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);\n            var result = new Constructor(length);\n            while(length > index)result[index] = list[index++];\n            return result;\n        };\n    /***/ },\n    /***/ 5397: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115481__)=>{\n        // toObject with fallback for non-array-like ES3 strings\n        var IndexedObject = __nested_webpack_require_115481__(7055);\n        var requireObjectCoercible = __nested_webpack_require_115481__(7750);\n        module.exports = function(it) {\n            return IndexedObject(requireObjectCoercible(it));\n        };\n    /***/ },\n    /***/ 5610: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115872__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_115872__(1291);\n        var max = Math.max;\n        var min = Math.min;\n        // Helper for a popular repeating case of the spec:\n        // Let integer be ? ToInteger(index).\n        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n        module.exports = function(index, length) {\n            var integer = toIntegerOrInfinity(index);\n            return integer < 0 ? max(integer + length, 0) : min(integer, length);\n        };\n    /***/ },\n    /***/ 5623: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_116514__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_116514__(456);\n    /***/ },\n    /***/ 5636: /***/ (module, __unused_webpack_exports, __nested_webpack_require_116683__)=>{\n        var globalThis1 = __nested_webpack_require_116683__(4576);\n        var uncurryThis = __nested_webpack_require_116683__(9504);\n        var uncurryThisAccessor = __nested_webpack_require_116683__(6706);\n        var toIndex = __nested_webpack_require_116683__(7696);\n        var notDetached = __nested_webpack_require_116683__(5169);\n        var arrayBufferByteLength = __nested_webpack_require_116683__(7394);\n        var detachTransferable = __nested_webpack_require_116683__(4483);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __nested_webpack_require_116683__(1548);\n        var structuredClone1 = globalThis1.structuredClone;\n        var ArrayBuffer1 = globalThis1.ArrayBuffer;\n        var DataView1 = globalThis1.DataView;\n        var min = Math.min;\n        var ArrayBufferPrototype = ArrayBuffer1.prototype;\n        var DataViewPrototype = DataView1.prototype;\n        var slice = uncurryThis(ArrayBufferPrototype.slice);\n        var isResizable = uncurryThisAccessor(ArrayBufferPrototype, \"resizable\", \"get\");\n        var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, \"maxByteLength\", \"get\");\n        var getInt8 = uncurryThis(DataViewPrototype.getInt8);\n        var setInt8 = uncurryThis(DataViewPrototype.setInt8);\n        module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {\n            var byteLength = arrayBufferByteLength(arrayBuffer);\n            var newByteLength = newLength === undefined ? byteLength : toIndex(newLength);\n            var fixedLength = !isResizable || !isResizable(arrayBuffer);\n            var newBuffer;\n            notDetached(arrayBuffer);\n            if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n                arrayBuffer = structuredClone1(arrayBuffer, {\n                    transfer: [\n                        arrayBuffer\n                    ]\n                });\n                if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;\n            }\n            if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {\n                newBuffer = slice(arrayBuffer, 0, newByteLength);\n            } else {\n                var options = preserveResizability && !fixedLength && maxByteLength ? {\n                    maxByteLength: maxByteLength(arrayBuffer)\n                } : undefined;\n                newBuffer = new ArrayBuffer1(newByteLength, options);\n                var a = new DataView1(arrayBuffer);\n                var b = new DataView1(newBuffer);\n                var copyLength = min(newByteLength, byteLength);\n                for(var i = 0; i < copyLength; i++)setInt8(b, i, getInt8(a, i));\n            }\n            if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);\n            return newBuffer;\n        };\n    /***/ },\n    /***/ 5745: /***/ (module, __unused_webpack_exports, __nested_webpack_require_119509__)=>{\n        var store = __nested_webpack_require_119509__(7629);\n        module.exports = function(key, value) {\n            return store[key] || (store[key] = value || {});\n        };\n    /***/ },\n    /***/ 5781: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_119787__)=>{\n        var $ = __nested_webpack_require_119787__(6518);\n        var getBuiltIn = __nested_webpack_require_119787__(7751);\n        var validateArgumentsLength = __nested_webpack_require_119787__(2812);\n        var toString = __nested_webpack_require_119787__(655);\n        var USE_NATIVE_URL = __nested_webpack_require_119787__(7416);\n        var URL1 = getBuiltIn(\"URL\");\n        // `URL.parse` method\n        // https://url.spec.whatwg.org/#dom-url-canparse\n        $({\n            target: \"URL\",\n            stat: true,\n            forced: !USE_NATIVE_URL\n        }, {\n            parse: function parse(url) {\n                var length = validateArgumentsLength(arguments.length, 1);\n                var urlString = toString(url);\n                var base = length < 2 || arguments[1] === undefined ? undefined : toString(arguments[1]);\n                try {\n                    return new URL1(urlString, base);\n                } catch (error) {\n                    return null;\n                }\n            }\n        });\n    /***/ },\n    /***/ 5854: /***/ (module, __unused_webpack_exports, __nested_webpack_require_120839__)=>{\n        var toPrimitive = __nested_webpack_require_120839__(2777);\n        var $TypeError = TypeError;\n        // `ToBigInt` abstract operation\n        // https://tc39.es/ecma262/#sec-tobigint\n        module.exports = function(argument) {\n            var prim = toPrimitive(argument, \"number\");\n            if (typeof prim == \"number\") throw new $TypeError(\"Can't convert number to bigint\");\n            // eslint-disable-next-line es/no-bigint -- safe\n            return BigInt(prim);\n        };\n    /***/ },\n    /***/ 5876: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_121433__)=>{\n        var $ = __nested_webpack_require_121433__(6518);\n        var isSubsetOf = __nested_webpack_require_121433__(3838);\n        var setMethodAcceptSetLike = __nested_webpack_require_121433__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSubsetOf\", function(result) {\n            return result;\n        });\n        // `Set.prototype.isSubsetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issubsetof\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSubsetOf: isSubsetOf\n        });\n    /***/ },\n    /***/ 5917: /***/ (module, __unused_webpack_exports, __nested_webpack_require_122094__)=>{\n        var DESCRIPTORS = __nested_webpack_require_122094__(3724);\n        var fails = __nested_webpack_require_122094__(9039);\n        var createElement = __nested_webpack_require_122094__(4055);\n        // Thanks to IE8 for its funny defineProperty\n        module.exports = !DESCRIPTORS && !fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty(createElement(\"div\"), \"a\", {\n                get: function() {\n                    return 7;\n                }\n            }).a !== 7;\n        });\n    /***/ },\n    /***/ 5966: /***/ (module, __unused_webpack_exports, __nested_webpack_require_122738__)=>{\n        var aCallable = __nested_webpack_require_122738__(9306);\n        var isNullOrUndefined = __nested_webpack_require_122738__(4117);\n        // `GetMethod` abstract operation\n        // https://tc39.es/ecma262/#sec-getmethod\n        module.exports = function(V, P) {\n            var func = V[P];\n            return isNullOrUndefined(func) ? undefined : aCallable(func);\n        };\n    /***/ },\n    /***/ 6043: /***/ (module, __unused_webpack_exports, __nested_webpack_require_123190__)=>{\n        var aCallable = __nested_webpack_require_123190__(9306);\n        var $TypeError = TypeError;\n        var PromiseCapability = function(C) {\n            var resolve, reject;\n            this.promise = new C(function($$resolve, $$reject) {\n                if (resolve !== undefined || reject !== undefined) throw new $TypeError(\"Bad Promise constructor\");\n                resolve = $$resolve;\n                reject = $$reject;\n            });\n            this.resolve = aCallable(resolve);\n            this.reject = aCallable(reject);\n        };\n        // `NewPromiseCapability` abstract operation\n        // https://tc39.es/ecma262/#sec-newpromisecapability\n        module.exports.f = function(C) {\n            return new PromiseCapability(C);\n        };\n    /***/ },\n    /***/ 6080: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124033__)=>{\n        var uncurryThis = __nested_webpack_require_124033__(7476);\n        var aCallable = __nested_webpack_require_124033__(9306);\n        var NATIVE_BIND = __nested_webpack_require_124033__(616);\n        var bind = uncurryThis(uncurryThis.bind);\n        // optional / simple context binding\n        module.exports = function(fn, that) {\n            aCallable(fn);\n            return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {\n                return fn.apply(that, arguments);\n            };\n        };\n    /***/ },\n    /***/ 6119: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124616__)=>{\n        var shared = __nested_webpack_require_124616__(5745);\n        var uid = __nested_webpack_require_124616__(3392);\n        var keys = shared(\"keys\");\n        module.exports = function(key) {\n            return keys[key] || (keys[key] = uid(key));\n        };\n    /***/ },\n    /***/ 6193: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124946__)=>{\n        var ENVIRONMENT = __nested_webpack_require_124946__(4215);\n        module.exports = ENVIRONMENT === \"NODE\";\n    /***/ },\n    /***/ 6198: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125142__)=>{\n        var toLength = __nested_webpack_require_125142__(8014);\n        // `LengthOfArrayLike` abstract operation\n        // https://tc39.es/ecma262/#sec-lengthofarraylike\n        module.exports = function(obj) {\n            return toLength(obj.length);\n        };\n    /***/ },\n    /***/ 6269: /***/ (module)=>{\n        module.exports = {};\n    /***/ },\n    /***/ 6279: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125563__)=>{\n        var defineBuiltIn = __nested_webpack_require_125563__(6840);\n        module.exports = function(target, src, options) {\n            for(var key in src)defineBuiltIn(target, key, src[key], options);\n            return target;\n        };\n    /***/ },\n    /***/ 6319: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125886__)=>{\n        var anObject = __nested_webpack_require_125886__(8551);\n        var iteratorClose = __nested_webpack_require_125886__(9539);\n        // call something on iterator step with safe closing on error\n        module.exports = function(iterator, fn, value, ENTRIES) {\n            try {\n                return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n            } catch (error) {\n                iteratorClose(iterator, \"throw\", error);\n            }\n        };\n    /***/ },\n    /***/ 6395: /***/ (module)=>{\n        module.exports = false;\n    /***/ },\n    /***/ 6518: /***/ (module, __unused_webpack_exports, __nested_webpack_require_126509__)=>{\n        var globalThis1 = __nested_webpack_require_126509__(4576);\n        var getOwnPropertyDescriptor = __nested_webpack_require_126509__(7347).f;\n        var createNonEnumerableProperty = __nested_webpack_require_126509__(6699);\n        var defineBuiltIn = __nested_webpack_require_126509__(6840);\n        var defineGlobalProperty = __nested_webpack_require_126509__(9433);\n        var copyConstructorProperties = __nested_webpack_require_126509__(7740);\n        var isForced = __nested_webpack_require_126509__(2796);\n        /*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ module.exports = function(options, source) {\n            var TARGET = options.target;\n            var GLOBAL = options.global;\n            var STATIC = options.stat;\n            var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n            if (GLOBAL) {\n                target = globalThis1;\n            } else if (STATIC) {\n                target = globalThis1[TARGET] || defineGlobalProperty(TARGET, {});\n            } else {\n                target = globalThis1[TARGET] && globalThis1[TARGET].prototype;\n            }\n            if (target) for(key in source){\n                sourceProperty = source[key];\n                if (options.dontCallGetSet) {\n                    descriptor = getOwnPropertyDescriptor(target, key);\n                    targetProperty = descriptor && descriptor.value;\n                } else targetProperty = target[key];\n                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                // contained in target\n                if (!FORCED && targetProperty !== undefined) {\n                    if (typeof sourceProperty == typeof targetProperty) continue;\n                    copyConstructorProperties(sourceProperty, targetProperty);\n                }\n                // add a flag to not completely full polyfills\n                if (options.sham || targetProperty && targetProperty.sham) {\n                    createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                }\n                defineBuiltIn(target, key, sourceProperty, options);\n            }\n        };\n    /***/ },\n    /***/ 6573: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_129592__)=>{\n        var DESCRIPTORS = __nested_webpack_require_129592__(3724);\n        var defineBuiltInAccessor = __nested_webpack_require_129592__(2106);\n        var isDetached = __nested_webpack_require_129592__(3238);\n        var ArrayBufferPrototype = ArrayBuffer.prototype;\n        // `ArrayBuffer.prototype.detached` getter\n        // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.detached\n        if (DESCRIPTORS && !(\"detached\" in ArrayBufferPrototype)) {\n            defineBuiltInAccessor(ArrayBufferPrototype, \"detached\", {\n                configurable: true,\n                get: function detached() {\n                    return isDetached(this);\n                }\n            });\n        }\n    /***/ },\n    /***/ 6632: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_130361__)=>{\n        var $ = __nested_webpack_require_130361__(6518);\n        var globalThis1 = __nested_webpack_require_130361__(4576);\n        var $fromBase64 = __nested_webpack_require_130361__(9143);\n        var anUint8Array = __nested_webpack_require_130361__(4154);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.setFromBase64 || !function() {\n            var target = new Uint8Array1([\n                255,\n                255,\n                255,\n                255,\n                255\n            ]);\n            try {\n                target.setFromBase64(\"\", null);\n                return;\n            } catch (error) {}\n            // Webkit not throw an error on odd length string\n            try {\n                target.setFromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                target.setFromBase64(\"MjYyZg===\");\n            } catch (error) {\n                return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;\n            }\n        }();\n        // `Uint8Array.prototype.setFromBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            setFromBase64: function setFromBase64(string /* , options */ ) {\n                anUint8Array(this);\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, this, this.length);\n                return {\n                    read: result.read,\n                    written: result.written\n                };\n            }\n        });\n    /***/ },\n    /***/ 6699: /***/ (module, __unused_webpack_exports, __nested_webpack_require_132198__)=>{\n        var DESCRIPTORS = __nested_webpack_require_132198__(3724);\n        var definePropertyModule = __nested_webpack_require_132198__(4913);\n        var createPropertyDescriptor = __nested_webpack_require_132198__(6980);\n        module.exports = DESCRIPTORS ? function(object, key, value) {\n            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n        } : function(object, key, value) {\n            object[key] = value;\n            return object;\n        };\n    /***/ },\n    /***/ 6706: /***/ (module, __unused_webpack_exports, __nested_webpack_require_132749__)=>{\n        var uncurryThis = __nested_webpack_require_132749__(9504);\n        var aCallable = __nested_webpack_require_132749__(9306);\n        module.exports = function(object, key, method) {\n            try {\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));\n            } catch (error) {}\n        };\n    /***/ },\n    /***/ 6801: /***/ (__unused_webpack_module, exports, __nested_webpack_require_133255__)=>{\n        var DESCRIPTORS = __nested_webpack_require_133255__(3724);\n        var V8_PROTOTYPE_DEFINE_BUG = __nested_webpack_require_133255__(8686);\n        var definePropertyModule = __nested_webpack_require_133255__(4913);\n        var anObject = __nested_webpack_require_133255__(8551);\n        var toIndexedObject = __nested_webpack_require_133255__(5397);\n        var objectKeys = __nested_webpack_require_133255__(1072);\n        // `Object.defineProperties` method\n        // https://tc39.es/ecma262/#sec-object.defineproperties\n        // eslint-disable-next-line es/no-object-defineproperties -- safe\n        exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n            anObject(O);\n            var props = toIndexedObject(Properties);\n            var keys = objectKeys(Properties);\n            var length = keys.length;\n            var index = 0;\n            var key;\n            while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);\n            return O;\n        };\n    /***/ },\n    /***/ 6823: /***/ (module)=>{\n        var $String = String;\n        module.exports = function(argument) {\n            try {\n                return $String(argument);\n            } catch (error) {\n                return \"Object\";\n            }\n        };\n    /***/ },\n    /***/ 6837: /***/ (module)=>{\n        var $TypeError = TypeError;\n        var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n        module.exports = function(it) {\n            if (it > MAX_SAFE_INTEGER) throw $TypeError(\"Maximum allowed index exceeded\");\n            return it;\n        };\n    /***/ },\n    /***/ 6840: /***/ (module, __unused_webpack_exports, __nested_webpack_require_134941__)=>{\n        var isCallable = __nested_webpack_require_134941__(4901);\n        var definePropertyModule = __nested_webpack_require_134941__(4913);\n        var makeBuiltIn = __nested_webpack_require_134941__(283);\n        var defineGlobalProperty = __nested_webpack_require_134941__(9433);\n        module.exports = function(O, key, value, options) {\n            if (!options) options = {};\n            var simple = options.enumerable;\n            var name = options.name !== undefined ? options.name : key;\n            if (isCallable(value)) makeBuiltIn(value, name, options);\n            if (options.global) {\n                if (simple) O[key] = value;\n                else defineGlobalProperty(key, value);\n            } else {\n                try {\n                    if (!options.unsafe) delete O[key];\n                    else if (O[key]) simple = true;\n                } catch (error) {}\n                if (simple) O[key] = value;\n                else definePropertyModule.f(O, key, {\n                    value: value,\n                    enumerable: false,\n                    configurable: !options.nonConfigurable,\n                    writable: !options.nonWritable\n                });\n            }\n            return O;\n        };\n    /***/ },\n    /***/ 6955: /***/ (module, __unused_webpack_exports, __nested_webpack_require_136218__)=>{\n        var TO_STRING_TAG_SUPPORT = __nested_webpack_require_136218__(2140);\n        var isCallable = __nested_webpack_require_136218__(4901);\n        var classofRaw = __nested_webpack_require_136218__(2195);\n        var wellKnownSymbol = __nested_webpack_require_136218__(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $Object = Object;\n        // ES3 wrong here\n        var CORRECT_ARGUMENTS = classofRaw(function() {\n            return arguments;\n        }()) === \"Arguments\";\n        // fallback for IE11 Script Access Denied error\n        var tryGet = function(it, key) {\n            try {\n                return it[key];\n            } catch (error) {}\n        };\n        // getting tag from ES6+ `Object.prototype.toString`\n        module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n            var O, tag, result;\n            return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === \"Object\" && isCallable(O.callee) ? \"Arguments\" : result;\n        };\n    /***/ },\n    /***/ 6969: /***/ (module, __unused_webpack_exports, __nested_webpack_require_137409__)=>{\n        var toPrimitive = __nested_webpack_require_137409__(2777);\n        var isSymbol = __nested_webpack_require_137409__(757);\n        // `ToPropertyKey` abstract operation\n        // https://tc39.es/ecma262/#sec-topropertykey\n        module.exports = function(argument) {\n            var key = toPrimitive(argument, \"string\");\n            return isSymbol(key) ? key : key + \"\";\n        };\n    /***/ },\n    /***/ 6980: /***/ (module)=>{\n        module.exports = function(bitmap, value) {\n            return {\n                enumerable: !(bitmap & 1),\n                configurable: !(bitmap & 2),\n                writable: !(bitmap & 4),\n                value: value\n            };\n        };\n    /***/ },\n    /***/ 7040: /***/ (module, __unused_webpack_exports, __nested_webpack_require_138171__)=>{\n        /* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __nested_webpack_require_138171__(4495);\n        module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    /***/ },\n    /***/ 7055: /***/ (module, __unused_webpack_exports, __nested_webpack_require_138472__)=>{\n        var uncurryThis = __nested_webpack_require_138472__(9504);\n        var fails = __nested_webpack_require_138472__(9039);\n        var classof = __nested_webpack_require_138472__(2195);\n        var $Object = Object;\n        var split = uncurryThis(\"\".split);\n        // fallback for non-array-like ES3 and non-enumerable old V8 strings\n        module.exports = fails(function() {\n            // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return !$Object(\"z\").propertyIsEnumerable(0);\n        }) ? function(it) {\n            return classof(it) === \"String\" ? split(it, \"\") : $Object(it);\n        } : $Object;\n    /***/ },\n    /***/ 7080: /***/ (module, __unused_webpack_exports, __nested_webpack_require_139250__)=>{\n        var has = __nested_webpack_require_139250__(4402).has;\n        // Perform ? RequireInternalSlot(M, [[SetData]])\n        module.exports = function(it) {\n            has(it);\n            return it;\n        };\n    /***/ },\n    /***/ 7347: /***/ (__unused_webpack_module, exports, __nested_webpack_require_139545__)=>{\n        var DESCRIPTORS = __nested_webpack_require_139545__(3724);\n        var call = __nested_webpack_require_139545__(9565);\n        var propertyIsEnumerableModule = __nested_webpack_require_139545__(8773);\n        var createPropertyDescriptor = __nested_webpack_require_139545__(6980);\n        var toIndexedObject = __nested_webpack_require_139545__(5397);\n        var toPropertyKey = __nested_webpack_require_139545__(6969);\n        var hasOwn = __nested_webpack_require_139545__(9297);\n        var IE8_DOM_DEFINE = __nested_webpack_require_139545__(5917);\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // `Object.getOwnPropertyDescriptor` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n        exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n            O = toIndexedObject(O);\n            P = toPropertyKey(P);\n            if (IE8_DOM_DEFINE) try {\n                return $getOwnPropertyDescriptor(O, P);\n            } catch (error) {}\n            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n        };\n    /***/ },\n    /***/ 7394: /***/ (module, __unused_webpack_exports, __nested_webpack_require_140789__)=>{\n        var globalThis1 = __nested_webpack_require_140789__(4576);\n        var uncurryThisAccessor = __nested_webpack_require_140789__(6706);\n        var classof = __nested_webpack_require_140789__(2195);\n        var ArrayBuffer1 = globalThis1.ArrayBuffer;\n        var TypeError1 = globalThis1.TypeError;\n        // Includes\n        // - Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).\n        // - If IsSharedArrayBuffer(O) is true, throw a TypeError exception.\n        module.exports = ArrayBuffer1 && uncurryThisAccessor(ArrayBuffer1.prototype, \"byteLength\", \"get\") || function(O) {\n            if (classof(O) !== \"ArrayBuffer\") throw new TypeError1(\"ArrayBuffer expected\");\n            return O.byteLength;\n        };\n    /***/ },\n    /***/ 7416: /***/ (module, __unused_webpack_exports, __nested_webpack_require_141570__)=>{\n        var fails = __nested_webpack_require_141570__(9039);\n        var wellKnownSymbol = __nested_webpack_require_141570__(8227);\n        var DESCRIPTORS = __nested_webpack_require_141570__(3724);\n        var IS_PURE = __nested_webpack_require_141570__(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module.exports = !fails(function() {\n            // eslint-disable-next-line unicorn/relative-url-style -- required for testing\n            var url = new URL(\"b?a=1&b=2&c=3\", \"https://a\");\n            var params = url.searchParams;\n            var params2 = new URLSearchParams(\"a=1&a=2&b=3\");\n            var result = \"\";\n            url.pathname = \"c%20d\";\n            params.forEach(function(value, key) {\n                params[\"delete\"](\"b\");\n                result += key + value;\n            });\n            params2[\"delete\"](\"a\", 2);\n            // `undefined` case is a Chromium 117 bug\n            // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n            params2[\"delete\"](\"b\", undefined);\n            return IS_PURE && (!url.toJSON || !params2.has(\"a\", 1) || params2.has(\"a\", 2) || !params2.has(\"a\", undefined) || params2.has(\"b\")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== \"https://a/c%20d?a=1&c=3\" || params.get(\"c\") !== \"3\" || String(new URLSearchParams(\"?a=1\")) !== \"a=1\" || !params[ITERATOR] || new URL(\"https://a@b\").username !== \"a\" || new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") !== \"b\" || new URL(\"https://\").host !== \"xn--e1aybc\" || new URL(\"https://a#\").hash !== \"#%D0%B1\" || result !== \"a1c3\" || new URL(\"https://x\", undefined).host !== \"x\";\n        });\n    /***/ },\n    /***/ 7476: /***/ (module, __unused_webpack_exports, __nested_webpack_require_143272__)=>{\n        var classofRaw = __nested_webpack_require_143272__(2195);\n        var uncurryThis = __nested_webpack_require_143272__(9504);\n        module.exports = function(fn) {\n            // Nashorn bug:\n            //   https://github.com/zloirock/core-js/issues/1128\n            //   https://github.com/zloirock/core-js/issues/1130\n            if (classofRaw(fn) === \"Function\") return uncurryThis(fn);\n        };\n    /***/ },\n    /***/ 7566: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_143768__)=>{\n        var defineBuiltIn = __nested_webpack_require_143768__(6840);\n        var uncurryThis = __nested_webpack_require_143768__(9504);\n        var toString = __nested_webpack_require_143768__(655);\n        var validateArgumentsLength = __nested_webpack_require_143768__(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var getAll = uncurryThis(URLSearchParamsPrototype.getAll);\n        var $has = uncurryThis(URLSearchParamsPrototype.has);\n        var params = new $URLSearchParams(\"a=1\");\n        // `undefined` case is a Chromium 117 bug\n        // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n        if (params.has(\"a\", 2) || !params.has(\"a\", undefined)) {\n            defineBuiltIn(URLSearchParamsPrototype, \"has\", function has(name /* , value */ ) {\n                var length = arguments.length;\n                var $value = length < 2 ? undefined : arguments[1];\n                if (length && $value === undefined) return $has(this, name);\n                var values = getAll(this, name); // also validates `this`\n                validateArgumentsLength(length, 1);\n                var value = toString($value);\n                var index = 0;\n                while(index < values.length){\n                    if (values[index++] === value) return true;\n                }\n                return false;\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    /***/ },\n    /***/ 7588: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_145329__)=>{\n        var $ = __nested_webpack_require_145329__(6518);\n        var call = __nested_webpack_require_145329__(9565);\n        var iterate = __nested_webpack_require_145329__(2652);\n        var aCallable = __nested_webpack_require_145329__(9306);\n        var anObject = __nested_webpack_require_145329__(8551);\n        var getIteratorDirect = __nested_webpack_require_145329__(1767);\n        var iteratorClose = __nested_webpack_require_145329__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_145329__(4549);\n        var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"forEach\", TypeError);\n        // `Iterator.prototype.forEach` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.foreach\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: forEachWithoutClosingOnEarlyError\n        }, {\n            forEach: function forEach(fn) {\n                anObject(this);\n                try {\n                    aCallable(fn);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value) {\n                    fn(value, counter++);\n                }, {\n                    IS_RECORD: true\n                });\n            }\n        });\n    /***/ },\n    /***/ 7629: /***/ (module, __unused_webpack_exports, __nested_webpack_require_146881__)=>{\n        var IS_PURE = __nested_webpack_require_146881__(6395);\n        var globalThis1 = __nested_webpack_require_146881__(4576);\n        var defineGlobalProperty = __nested_webpack_require_146881__(9433);\n        var SHARED = \"__core-js_shared__\";\n        var store = module.exports = globalThis1[SHARED] || defineGlobalProperty(SHARED, {});\n        (store.versions || (store.versions = [])).push({\n            version: \"3.45.1\",\n            mode: IS_PURE ? \"pure\" : \"global\",\n            copyright: \"\\xa9 2014-2025 Denis Pushkarev (zloirock.ru)\",\n            license: \"https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE\",\n            source: \"https://github.com/zloirock/core-js\"\n        });\n    /***/ },\n    /***/ 7642: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_147650__)=>{\n        var $ = __nested_webpack_require_147650__(6518);\n        var difference = __nested_webpack_require_147650__(3440);\n        var fails = __nested_webpack_require_147650__(9039);\n        var setMethodAcceptSetLike = __nested_webpack_require_147650__(4916);\n        var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike(\"difference\", function(result) {\n            return result.size === 0;\n        });\n        var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {\n            // https://bugs.webkit.org/show_bug.cgi?id=288595\n            var setLike = {\n                size: 1,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    var index = 0;\n                    return {\n                        next: function() {\n                            var done = index++ > 1;\n                            if (baseSet.has(1)) baseSet.clear();\n                            return {\n                                done: done,\n                                value: 2\n                            };\n                        }\n                    };\n                }\n            };\n            // eslint-disable-next-line es/no-set -- testing\n            var baseSet = new Set([\n                1,\n                2,\n                3,\n                4\n            ]);\n            // eslint-disable-next-line es/no-set-prototype-difference -- testing\n            return baseSet.difference(setLike).size !== 3;\n        });\n        // `Set.prototype.difference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.difference\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            difference: difference\n        });\n    /***/ },\n    /***/ 7657: /***/ (module, __unused_webpack_exports, __nested_webpack_require_149491__)=>{\n        var fails = __nested_webpack_require_149491__(9039);\n        var isCallable = __nested_webpack_require_149491__(4901);\n        var isObject = __nested_webpack_require_149491__(34);\n        var create = __nested_webpack_require_149491__(2360);\n        var getPrototypeOf = __nested_webpack_require_149491__(2787);\n        var defineBuiltIn = __nested_webpack_require_149491__(6840);\n        var wellKnownSymbol = __nested_webpack_require_149491__(8227);\n        var IS_PURE = __nested_webpack_require_149491__(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var BUGGY_SAFARI_ITERATORS = false;\n        // `%IteratorPrototype%` object\n        // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n        /* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {\n            arrayIterator = [].keys();\n            // Safari 8 has buggy iterators w/o `next`\n            if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n            else {\n                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n            }\n        }\n        var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {\n            var test = {};\n            // FF44- legacy iterators case\n            return IteratorPrototype[ITERATOR].call(test) !== test;\n        });\n        if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n        else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n        // `%IteratorPrototype%[@@iterator]()` method\n        // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n        if (!isCallable(IteratorPrototype[ITERATOR])) {\n            defineBuiltIn(IteratorPrototype, ITERATOR, function() {\n                return this;\n            });\n        }\n        module.exports = {\n            IteratorPrototype: IteratorPrototype,\n            BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n        };\n    /***/ },\n    /***/ 7680: /***/ (module, __unused_webpack_exports, __nested_webpack_require_151624__)=>{\n        var uncurryThis = __nested_webpack_require_151624__(9504);\n        module.exports = uncurryThis([].slice);\n    /***/ },\n    /***/ 7696: /***/ (module, __unused_webpack_exports, __nested_webpack_require_151819__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_151819__(1291);\n        var toLength = __nested_webpack_require_151819__(8014);\n        var $RangeError = RangeError;\n        // `ToIndex` abstract operation\n        // https://tc39.es/ecma262/#sec-toindex\n        module.exports = function(it) {\n            if (it === undefined) return 0;\n            var number = toIntegerOrInfinity(it);\n            var length = toLength(number);\n            if (number !== length) throw new $RangeError(\"Wrong length or index\");\n            return length;\n        };\n    /***/ },\n    /***/ 7740: /***/ (module, __unused_webpack_exports, __nested_webpack_require_152448__)=>{\n        var hasOwn = __nested_webpack_require_152448__(9297);\n        var ownKeys = __nested_webpack_require_152448__(5031);\n        var getOwnPropertyDescriptorModule = __nested_webpack_require_152448__(7347);\n        var definePropertyModule = __nested_webpack_require_152448__(4913);\n        module.exports = function(target, source, exceptions) {\n            var keys = ownKeys(source);\n            var defineProperty = definePropertyModule.f;\n            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                }\n            }\n        };\n    /***/ },\n    /***/ 7750: /***/ (module, __unused_webpack_exports, __nested_webpack_require_153315__)=>{\n        var isNullOrUndefined = __nested_webpack_require_153315__(4117);\n        var $TypeError = TypeError;\n        // `RequireObjectCoercible` abstract operation\n        // https://tc39.es/ecma262/#sec-requireobjectcoercible\n        module.exports = function(it) {\n            if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n            return it;\n        };\n    /***/ },\n    /***/ 7751: /***/ (module, __unused_webpack_exports, __nested_webpack_require_153787__)=>{\n        var globalThis1 = __nested_webpack_require_153787__(4576);\n        var isCallable = __nested_webpack_require_153787__(4901);\n        var aFunction = function(argument) {\n            return isCallable(argument) ? argument : undefined;\n        };\n        module.exports = function(namespace, method) {\n            return arguments.length < 2 ? aFunction(globalThis1[namespace]) : globalThis1[namespace] && globalThis1[namespace][method];\n        };\n    /***/ },\n    /***/ 7811: /***/ (module)=>{\n        // eslint-disable-next-line es/no-typed-arrays -- safe\n        module.exports = typeof ArrayBuffer != \"undefined\" && typeof DataView != \"undefined\";\n    /***/ },\n    /***/ 7936: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_154529__)=>{\n        var $ = __nested_webpack_require_154529__(6518);\n        var $transfer = __nested_webpack_require_154529__(5636);\n        // `ArrayBuffer.prototype.transferToFixedLength` method\n        // https://tc39.es/ecma262/#sec-arraybuffer.prototype.transfertofixedlength\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transferToFixedLength: function transferToFixedLength() {\n                return $transfer(this, arguments.length ? arguments[0] : undefined, false);\n            }\n        });\n    /***/ },\n    /***/ 8004: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_155169__)=>{\n        var $ = __nested_webpack_require_155169__(6518);\n        var fails = __nested_webpack_require_155169__(9039);\n        var intersection = __nested_webpack_require_155169__(8750);\n        var setMethodAcceptSetLike = __nested_webpack_require_155169__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"intersection\", function(result) {\n            return result.size === 2 && result.has(1) && result.has(2);\n        }) || fails(function() {\n            // eslint-disable-next-line es/no-array-from, es/no-set, es/no-set-prototype-intersection -- testing\n            return String(Array.from(new Set([\n                1,\n                2,\n                3\n            ]).intersection(new Set([\n                3,\n                2\n            ])))) !== \"3,2\";\n        });\n        // `Set.prototype.intersection` method\n        // https://tc39.es/ecma262/#sec-set.prototype.intersection\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            intersection: intersection\n        });\n    /***/ },\n    /***/ 8014: /***/ (module, __unused_webpack_exports, __nested_webpack_require_156287__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_156287__(1291);\n        var min = Math.min;\n        // `ToLength` abstract operation\n        // https://tc39.es/ecma262/#sec-tolength\n        module.exports = function(argument) {\n            var len = toIntegerOrInfinity(argument);\n            return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n        };\n    /***/ },\n    /***/ 8100: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_156783__)=>{\n        var $ = __nested_webpack_require_156783__(6518);\n        var $transfer = __nested_webpack_require_156783__(5636);\n        // `ArrayBuffer.prototype.transfer` method\n        // https://tc39.es/ecma262/#sec-arraybuffer.prototype.transfer\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transfer: function transfer() {\n                return $transfer(this, arguments.length ? arguments[0] : undefined, true);\n            }\n        });\n    /***/ },\n    /***/ 8111: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_157370__)=>{\n        var $ = __nested_webpack_require_157370__(6518);\n        var globalThis1 = __nested_webpack_require_157370__(4576);\n        var anInstance = __nested_webpack_require_157370__(679);\n        var anObject = __nested_webpack_require_157370__(8551);\n        var isCallable = __nested_webpack_require_157370__(4901);\n        var getPrototypeOf = __nested_webpack_require_157370__(2787);\n        var defineBuiltInAccessor = __nested_webpack_require_157370__(2106);\n        var createProperty = __nested_webpack_require_157370__(4659);\n        var fails = __nested_webpack_require_157370__(9039);\n        var hasOwn = __nested_webpack_require_157370__(9297);\n        var wellKnownSymbol = __nested_webpack_require_157370__(8227);\n        var IteratorPrototype = __nested_webpack_require_157370__(7657).IteratorPrototype;\n        var DESCRIPTORS = __nested_webpack_require_157370__(3724);\n        var IS_PURE = __nested_webpack_require_157370__(6395);\n        var CONSTRUCTOR = \"constructor\";\n        var ITERATOR = \"Iterator\";\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $TypeError = TypeError;\n        var NativeIterator = globalThis1[ITERATOR];\n        // FF56- have non-standard global helper `Iterator`\n        var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {\n            NativeIterator({});\n        });\n        var IteratorConstructor = function Iterator1() {\n            anInstance(this, IteratorPrototype);\n            if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError(\"Abstract class Iterator not directly constructable\");\n        };\n        var defineIteratorPrototypeAccessor = function(key, value) {\n            if (DESCRIPTORS) {\n                defineBuiltInAccessor(IteratorPrototype, key, {\n                    configurable: true,\n                    get: function() {\n                        return value;\n                    },\n                    set: function(replacement) {\n                        anObject(this);\n                        if (this === IteratorPrototype) throw new $TypeError(\"You can't redefine this property\");\n                        if (hasOwn(this, key)) this[key] = replacement;\n                        else createProperty(this, key, replacement);\n                    }\n                });\n            } else IteratorPrototype[key] = value;\n        };\n        if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);\n        if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {\n            defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);\n        }\n        IteratorConstructor.prototype = IteratorPrototype;\n        // `Iterator` constructor\n        // https://tc39.es/ecma262/#sec-iterator\n        $({\n            global: true,\n            constructor: true,\n            forced: FORCED\n        }, {\n            Iterator: IteratorConstructor\n        });\n    /***/ },\n    /***/ 8227: /***/ (module, __unused_webpack_exports, __nested_webpack_require_160301__)=>{\n        var globalThis1 = __nested_webpack_require_160301__(4576);\n        var shared = __nested_webpack_require_160301__(5745);\n        var hasOwn = __nested_webpack_require_160301__(9297);\n        var uid = __nested_webpack_require_160301__(3392);\n        var NATIVE_SYMBOL = __nested_webpack_require_160301__(4495);\n        var USE_SYMBOL_AS_UID = __nested_webpack_require_160301__(7040);\n        var Symbol1 = globalThis1.Symbol;\n        var WellKnownSymbolsStore = shared(\"wks\");\n        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1[\"for\"] || Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n        module.exports = function(name) {\n            if (!hasOwn(WellKnownSymbolsStore, name)) {\n                WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol1, name) ? Symbol1[name] : createWellKnownSymbol(\"Symbol.\" + name);\n            }\n            return WellKnownSymbolsStore[name];\n        };\n    /***/ },\n    /***/ 8235: /***/ (module, __unused_webpack_exports, __nested_webpack_require_161236__)=>{\n        var uncurryThis = __nested_webpack_require_161236__(9504);\n        var hasOwn = __nested_webpack_require_161236__(9297);\n        var $SyntaxError = SyntaxError;\n        var $parseInt = parseInt;\n        var fromCharCode = String.fromCharCode;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var codePoints = {\n            '\\\\\"': '\"',\n            \"\\\\\\\\\": \"\\\\\",\n            \"\\\\/\": \"/\",\n            \"\\\\b\": \"\\b\",\n            \"\\\\f\": \"\\f\",\n            \"\\\\n\": \"\\n\",\n            \"\\\\r\": \"\\r\",\n            \"\\\\t\": \"\t\"\n        };\n        var IS_4_HEX_DIGITS = /^[\\da-f]{4}$/i;\n        // eslint-disable-next-line regexp/no-control-character -- safe\n        var IS_C0_CONTROL_CODE = /^[\\u0000-\\u001F]$/;\n        module.exports = function(source, i) {\n            var unterminated = true;\n            var value = \"\";\n            while(i < source.length){\n                var chr = at(source, i);\n                if (chr === \"\\\\\") {\n                    var twoChars = slice(source, i, i + 2);\n                    if (hasOwn(codePoints, twoChars)) {\n                        value += codePoints[twoChars];\n                        i += 2;\n                    } else if (twoChars === \"\\\\u\") {\n                        i += 2;\n                        var fourHexDigits = slice(source, i, i + 4);\n                        if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError(\"Bad Unicode escape at: \" + i);\n                        value += fromCharCode($parseInt(fourHexDigits, 16));\n                        i += 4;\n                    } else throw new $SyntaxError('Unknown escape sequence: \"' + twoChars + '\"');\n                } else if (chr === '\"') {\n                    unterminated = false;\n                    i++;\n                    break;\n                } else {\n                    if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError(\"Bad control character in string literal at: \" + i);\n                    value += chr;\n                    i++;\n                }\n            }\n            if (unterminated) throw new $SyntaxError(\"Unterminated string at: \" + i);\n            return {\n                value: value,\n                end: i\n            };\n        };\n    /***/ },\n    /***/ 8237: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_163586__)=>{\n        var $ = __nested_webpack_require_163586__(6518);\n        var iterate = __nested_webpack_require_163586__(2652);\n        var aCallable = __nested_webpack_require_163586__(9306);\n        var anObject = __nested_webpack_require_163586__(8551);\n        var getIteratorDirect = __nested_webpack_require_163586__(1767);\n        var iteratorClose = __nested_webpack_require_163586__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_163586__(4549);\n        var apply = __nested_webpack_require_163586__(8745);\n        var fails = __nested_webpack_require_163586__(9039);\n        var $TypeError = TypeError;\n        // https://bugs.webkit.org/show_bug.cgi?id=291651\n        var FAILS_ON_INITIAL_UNDEFINED = fails(function() {\n            // eslint-disable-next-line es/no-iterator-prototype-reduce, es/no-array-prototype-keys, array-callback-return -- required for testing\n            [].keys().reduce(function() {}, undefined);\n        });\n        var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError(\"reduce\", $TypeError);\n        // `Iterator.prototype.reduce` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.reduce\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError\n        }, {\n            reduce: function reduce(reducer /* , initialValue */ ) {\n                anObject(this);\n                try {\n                    aCallable(reducer);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                var noInitial = arguments.length < 2;\n                var accumulator = noInitial ? undefined : arguments[1];\n                if (reduceWithoutClosingOnEarlyError) {\n                    return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [\n                        reducer\n                    ] : [\n                        reducer,\n                        accumulator\n                    ]);\n                }\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value) {\n                    if (noInitial) {\n                        noInitial = false;\n                        accumulator = value;\n                    } else {\n                        accumulator = reducer(accumulator, value, counter);\n                    }\n                    counter++;\n                }, {\n                    IS_RECORD: true\n                });\n                if (noInitial) throw new $TypeError(\"Reduce of empty iterator with no initial value\");\n                return accumulator;\n            }\n        });\n    /***/ },\n    /***/ 8335: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_166364__)=>{\n        var $ = __nested_webpack_require_166364__(6518);\n        var DESCRIPTORS = __nested_webpack_require_166364__(3724);\n        var globalThis1 = __nested_webpack_require_166364__(4576);\n        var getBuiltIn = __nested_webpack_require_166364__(7751);\n        var uncurryThis = __nested_webpack_require_166364__(9504);\n        var call = __nested_webpack_require_166364__(9565);\n        var isCallable = __nested_webpack_require_166364__(4901);\n        var isObject = __nested_webpack_require_166364__(34);\n        var isArray = __nested_webpack_require_166364__(4376);\n        var hasOwn = __nested_webpack_require_166364__(9297);\n        var toString = __nested_webpack_require_166364__(655);\n        var lengthOfArrayLike = __nested_webpack_require_166364__(6198);\n        var createProperty = __nested_webpack_require_166364__(4659);\n        var fails = __nested_webpack_require_166364__(9039);\n        var parseJSONString = __nested_webpack_require_166364__(8235);\n        var NATIVE_SYMBOL = __nested_webpack_require_166364__(4495);\n        var JSON1 = globalThis1.JSON;\n        var Number1 = globalThis1.Number;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var nativeParse = JSON1 && JSON1.parse;\n        var enumerableOwnProperties = getBuiltIn(\"Object\", \"keys\");\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var push = uncurryThis([].push);\n        var IS_DIGIT = /^\\d$/;\n        var IS_NON_ZERO_DIGIT = /^[1-9]$/;\n        var IS_NUMBER_START = /^[\\d-]$/;\n        var IS_WHITESPACE = /^[\\t\\n\\r ]$/;\n        var PRIMITIVE = 0;\n        var OBJECT = 1;\n        var $parse = function(source, reviver) {\n            source = toString(source);\n            var context = new Context(source, 0, \"\");\n            var root = context.parse();\n            var value = root.value;\n            var endIndex = context.skip(IS_WHITESPACE, root.end);\n            if (endIndex < source.length) {\n                throw new SyntaxError1('Unexpected extra character: \"' + at(source, endIndex) + '\" after the parsed data at: ' + endIndex);\n            }\n            return isCallable(reviver) ? internalize({\n                \"\": value\n            }, \"\", reviver, root) : value;\n        };\n        var internalize = function(holder, name, reviver, node) {\n            var val = holder[name];\n            var unmodified = node && val === node.value;\n            var context = unmodified && typeof node.source == \"string\" ? {\n                source: node.source\n            } : {};\n            var elementRecordsLen, keys, len, i, P;\n            if (isObject(val)) {\n                var nodeIsArray = isArray(val);\n                var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};\n                if (nodeIsArray) {\n                    elementRecordsLen = nodes.length;\n                    len = lengthOfArrayLike(val);\n                    for(i = 0; i < len; i++){\n                        internalizeProperty(val, i, internalize(val, \"\" + i, reviver, i < elementRecordsLen ? nodes[i] : undefined));\n                    }\n                } else {\n                    keys = enumerableOwnProperties(val);\n                    len = lengthOfArrayLike(keys);\n                    for(i = 0; i < len; i++){\n                        P = keys[i];\n                        internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : undefined));\n                    }\n                }\n            }\n            return call(reviver, holder, name, val, context);\n        };\n        var internalizeProperty = function(object, key, value) {\n            if (DESCRIPTORS) {\n                var descriptor = getOwnPropertyDescriptor(object, key);\n                if (descriptor && !descriptor.configurable) return;\n            }\n            if (value === undefined) delete object[key];\n            else createProperty(object, key, value);\n        };\n        var Node1 = function(value, end, source, nodes) {\n            this.value = value;\n            this.end = end;\n            this.source = source;\n            this.nodes = nodes;\n        };\n        var Context = function(source, index) {\n            this.source = source;\n            this.index = index;\n        };\n        // https://www.json.org/json-en.html\n        Context.prototype = {\n            fork: function(nextIndex) {\n                return new Context(this.source, nextIndex);\n            },\n            parse: function() {\n                var source = this.source;\n                var i = this.skip(IS_WHITESPACE, this.index);\n                var fork = this.fork(i);\n                var chr = at(source, i);\n                if (exec(IS_NUMBER_START, chr)) return fork.number();\n                switch(chr){\n                    case \"{\":\n                        return fork.object();\n                    case \"[\":\n                        return fork.array();\n                    case '\"':\n                        return fork.string();\n                    case \"t\":\n                        return fork.keyword(true);\n                    case \"f\":\n                        return fork.keyword(false);\n                    case \"n\":\n                        return fork.keyword(null);\n                }\n                throw new SyntaxError1('Unexpected character: \"' + chr + '\" at: ' + i);\n            },\n            node: function(type, value, start, end, nodes) {\n                return new Node1(value, end, type ? null : slice(this.source, start, end), nodes);\n            },\n            object: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectKeypair = false;\n                var object = {};\n                var nodes = {};\n                while(i < source.length){\n                    i = this.until([\n                        '\"',\n                        \"}\"\n                    ], i);\n                    if (at(source, i) === \"}\" && !expectKeypair) {\n                        i++;\n                        break;\n                    }\n                    // Parsing the key\n                    var result = this.fork(i).string();\n                    var key = result.value;\n                    i = result.end;\n                    i = this.until([\n                        \":\"\n                    ], i) + 1;\n                    // Parsing value\n                    i = this.skip(IS_WHITESPACE, i);\n                    result = this.fork(i).parse();\n                    createProperty(nodes, key, result);\n                    createProperty(object, key, result.value);\n                    i = this.until([\n                        \",\",\n                        \"}\"\n                    ], result.end);\n                    var chr = at(source, i);\n                    if (chr === \",\") {\n                        expectKeypair = true;\n                        i++;\n                    } else if (chr === \"}\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, object, this.index, i, nodes);\n            },\n            array: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectElement = false;\n                var array = [];\n                var nodes = [];\n                while(i < source.length){\n                    i = this.skip(IS_WHITESPACE, i);\n                    if (at(source, i) === \"]\" && !expectElement) {\n                        i++;\n                        break;\n                    }\n                    var result = this.fork(i).parse();\n                    push(nodes, result);\n                    push(array, result.value);\n                    i = this.until([\n                        \",\",\n                        \"]\"\n                    ], result.end);\n                    if (at(source, i) === \",\") {\n                        expectElement = true;\n                        i++;\n                    } else if (at(source, i) === \"]\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, array, this.index, i, nodes);\n            },\n            string: function() {\n                var index = this.index;\n                var parsed = parseJSONString(this.source, this.index + 1);\n                return this.node(PRIMITIVE, parsed.value, index, parsed.end);\n            },\n            number: function() {\n                var source = this.source;\n                var startIndex = this.index;\n                var i = startIndex;\n                if (at(source, i) === \"-\") i++;\n                if (at(source, i) === \"0\") i++;\n                else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);\n                else throw new SyntaxError1(\"Failed to parse number at: \" + i);\n                if (at(source, i) === \".\") i = this.skip(IS_DIGIT, i + 1);\n                if (at(source, i) === \"e\" || at(source, i) === \"E\") {\n                    i++;\n                    if (at(source, i) === \"+\" || at(source, i) === \"-\") i++;\n                    var exponentStartIndex = i;\n                    i = this.skip(IS_DIGIT, i);\n                    if (exponentStartIndex === i) throw new SyntaxError1(\"Failed to parse number's exponent value at: \" + i);\n                }\n                return this.node(PRIMITIVE, Number1(slice(source, startIndex, i)), startIndex, i);\n            },\n            keyword: function(value) {\n                var keyword = \"\" + value;\n                var index = this.index;\n                var endIndex = index + keyword.length;\n                if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError1(\"Failed to parse value at: \" + index);\n                return this.node(PRIMITIVE, value, index, endIndex);\n            },\n            skip: function(regex, i) {\n                var source = this.source;\n                for(; i < source.length; i++)if (!exec(regex, at(source, i))) break;\n                return i;\n            },\n            until: function(array, i) {\n                i = this.skip(IS_WHITESPACE, i);\n                var chr = at(this.source, i);\n                for(var j = 0; j < array.length; j++)if (array[j] === chr) return i;\n                throw new SyntaxError1('Unexpected character: \"' + chr + '\" at: ' + i);\n            }\n        };\n        var NO_SOURCE_SUPPORT = fails(function() {\n            var unsafeInt = \"9007199254740993\";\n            var source;\n            nativeParse(unsafeInt, function(key, value, context) {\n                source = context.source;\n            });\n            return source !== unsafeInt;\n        });\n        var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {\n            // Safari 9 bug\n            return 1 / nativeParse(\"-0 \t\") !== -Infinity;\n        });\n        // `JSON.parse` method\n        // https://tc39.es/ecma262/#sec-json.parse\n        // https://github.com/tc39/proposal-json-parse-with-source\n        $({\n            target: \"JSON\",\n            stat: true,\n            forced: NO_SOURCE_SUPPORT\n        }, {\n            parse: function parse(text, reviver) {\n                return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);\n            }\n        });\n    /***/ },\n    /***/ 8469: /***/ (module, __unused_webpack_exports, __nested_webpack_require_177758__)=>{\n        var uncurryThis = __nested_webpack_require_177758__(9504);\n        var iterateSimple = __nested_webpack_require_177758__(507);\n        var SetHelpers = __nested_webpack_require_177758__(4402);\n        var Set1 = SetHelpers.Set;\n        var SetPrototype = SetHelpers.proto;\n        var forEach = uncurryThis(SetPrototype.forEach);\n        var keys = uncurryThis(SetPrototype.keys);\n        var next = keys(new Set1()).next;\n        module.exports = function(set, fn, interruptible) {\n            return interruptible ? iterateSimple({\n                iterator: keys(set),\n                next: next\n            }, fn) : forEach(set, fn);\n        };\n    /***/ },\n    /***/ 8480: /***/ (__unused_webpack_module, exports, __nested_webpack_require_178466__)=>{\n        var internalObjectKeys = __nested_webpack_require_178466__(1828);\n        var enumBugKeys = __nested_webpack_require_178466__(8727);\n        var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n        // `Object.getOwnPropertyNames` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertynames\n        // eslint-disable-next-line es/no-object-getownpropertynames -- safe\n        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n            return internalObjectKeys(O, hiddenKeys);\n        };\n    /***/ },\n    /***/ 8527: /***/ (module, __unused_webpack_exports, __nested_webpack_require_179081__)=>{\n        var aSet = __nested_webpack_require_179081__(7080);\n        var has = __nested_webpack_require_179081__(4402).has;\n        var size = __nested_webpack_require_179081__(5170);\n        var getSetRecord = __nested_webpack_require_179081__(3789);\n        var iterateSimple = __nested_webpack_require_179081__(507);\n        var iteratorClose = __nested_webpack_require_179081__(9539);\n        // `Set.prototype.isSupersetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issupersetof\n        module.exports = function isSupersetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) < otherRec.size) return false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (!has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    /***/ },\n    /***/ 8551: /***/ (module, __unused_webpack_exports, __nested_webpack_require_180010__)=>{\n        var isObject = __nested_webpack_require_180010__(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        // `Assert: Type(argument) is Object`\n        module.exports = function(argument) {\n            if (isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object\");\n        };\n    /***/ },\n    /***/ 8574: /***/ (module, __unused_webpack_exports, __nested_webpack_require_180449__)=>{\n        var uncurryThis = __nested_webpack_require_180449__(9504);\n        var $Error = Error;\n        var replace = uncurryThis(\"\".replace);\n        var TEST = function(arg) {\n            return String(new $Error(arg).stack);\n        }(\"zxcasd\");\n        // eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe\n        var V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at [^:]*:[^\\n]*/;\n        var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\n        module.exports = function(stack, dropEntries) {\n            if (IS_V8_OR_CHAKRA_STACK && typeof stack == \"string\" && !$Error.prepareStackTrace) {\n                while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, \"\");\n            }\n            return stack;\n        };\n    /***/ },\n    /***/ 8622: /***/ (module, __unused_webpack_exports, __nested_webpack_require_181292__)=>{\n        var globalThis1 = __nested_webpack_require_181292__(4576);\n        var isCallable = __nested_webpack_require_181292__(4901);\n        var WeakMap1 = globalThis1.WeakMap;\n        module.exports = isCallable(WeakMap1) && /native code/.test(String(WeakMap1));\n    /***/ },\n    /***/ 8646: /***/ (module, __unused_webpack_exports, __nested_webpack_require_181622__)=>{\n        var call = __nested_webpack_require_181622__(9565);\n        var anObject = __nested_webpack_require_181622__(8551);\n        var getIteratorDirect = __nested_webpack_require_181622__(1767);\n        var getIteratorMethod = __nested_webpack_require_181622__(851);\n        module.exports = function(obj, stringHandling) {\n            if (!stringHandling || typeof obj !== \"string\") anObject(obj);\n            var method = getIteratorMethod(obj);\n            return getIteratorDirect(anObject(method !== undefined ? call(method, obj) : obj));\n        };\n    /***/ },\n    /***/ 8686: /***/ (module, __unused_webpack_exports, __nested_webpack_require_182217__)=>{\n        var DESCRIPTORS = __nested_webpack_require_182217__(3724);\n        var fails = __nested_webpack_require_182217__(9039);\n        // V8 ~ Chrome 36-\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3334\n        module.exports = DESCRIPTORS && fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty(function() {}, \"prototype\", {\n                value: 42,\n                writable: false\n            }).prototype !== 42;\n        });\n    /***/ },\n    /***/ 8721: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_182845__)=>{\n        var DESCRIPTORS = __nested_webpack_require_182845__(3724);\n        var uncurryThis = __nested_webpack_require_182845__(9504);\n        var defineBuiltInAccessor = __nested_webpack_require_182845__(2106);\n        var URLSearchParamsPrototype = URLSearchParams.prototype;\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        // `URLSearchParams.prototype.size` getter\n        // https://github.com/whatwg/url/pull/734\n        if (DESCRIPTORS && !(\"size\" in URLSearchParamsPrototype)) {\n            defineBuiltInAccessor(URLSearchParamsPrototype, \"size\", {\n                get: function size() {\n                    var count = 0;\n                    forEach(this, function() {\n                        count++;\n                    });\n                    return count;\n                },\n                configurable: true,\n                enumerable: true\n            });\n        }\n    /***/ },\n    /***/ 8727: /***/ (module)=>{\n        // IE8- don't enum bug keys\n        module.exports = [\n            \"constructor\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"toLocaleString\",\n            \"toString\",\n            \"valueOf\"\n        ];\n    /***/ },\n    /***/ 8745: /***/ (module, __unused_webpack_exports, __nested_webpack_require_184127__)=>{\n        var NATIVE_BIND = __nested_webpack_require_184127__(616);\n        var FunctionPrototype = Function.prototype;\n        var apply = FunctionPrototype.apply;\n        var call = FunctionPrototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe\n        module.exports = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {\n            return call.apply(apply, arguments);\n        });\n    /***/ },\n    /***/ 8750: /***/ (module, __unused_webpack_exports, __nested_webpack_require_184682__)=>{\n        var aSet = __nested_webpack_require_184682__(7080);\n        var SetHelpers = __nested_webpack_require_184682__(4402);\n        var size = __nested_webpack_require_184682__(5170);\n        var getSetRecord = __nested_webpack_require_184682__(3789);\n        var iterateSet = __nested_webpack_require_184682__(8469);\n        var iterateSimple = __nested_webpack_require_184682__(507);\n        var Set1 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        // `Set.prototype.intersection` method\n        // https://tc39.es/ecma262/#sec-set.prototype.intersection\n        module.exports = function intersection(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = new Set1();\n            if (size(O) > otherRec.size) {\n                iterateSimple(otherRec.getIterator(), function(e) {\n                    if (has(O, e)) add(result, e);\n                });\n            } else {\n                iterateSet(O, function(e) {\n                    if (otherRec.includes(e)) add(result, e);\n                });\n            }\n            return result;\n        };\n    /***/ },\n    /***/ 8773: /***/ (__unused_webpack_module, exports)=>{\n        var $propertyIsEnumerable = {}.propertyIsEnumerable;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // Nashorn ~ JDK8 bug\n        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n            1: 2\n        }, 1);\n        // `Object.prototype.propertyIsEnumerable` method implementation\n        // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n        exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n            var descriptor = getOwnPropertyDescriptor(this, V);\n            return !!descriptor && descriptor.enumerable;\n        } : $propertyIsEnumerable;\n    /***/ },\n    /***/ 8981: /***/ (module, __unused_webpack_exports, __nested_webpack_require_186662__)=>{\n        var requireObjectCoercible = __nested_webpack_require_186662__(7750);\n        var $Object = Object;\n        // `ToObject` abstract operation\n        // https://tc39.es/ecma262/#sec-toobject\n        module.exports = function(argument) {\n            return $Object(requireObjectCoercible(argument));\n        };\n    /***/ },\n    /***/ 9039: /***/ (module)=>{\n        module.exports = function(exec) {\n            try {\n                return !!exec();\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 9143: /***/ (module, __unused_webpack_exports, __nested_webpack_require_187283__)=>{\n        var globalThis1 = __nested_webpack_require_187283__(4576);\n        var uncurryThis = __nested_webpack_require_187283__(9504);\n        var anObjectOrUndefined = __nested_webpack_require_187283__(3972);\n        var aString = __nested_webpack_require_187283__(3463);\n        var hasOwn = __nested_webpack_require_187283__(9297);\n        var base64Map = __nested_webpack_require_187283__(2804);\n        var getAlphabetOption = __nested_webpack_require_187283__(944);\n        var notDetached = __nested_webpack_require_187283__(5169);\n        var base64Alphabet = base64Map.c2i;\n        var base64UrlAlphabet = base64Map.c2iUrl;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var TypeError1 = globalThis1.TypeError;\n        var at = uncurryThis(\"\".charAt);\n        var skipAsciiWhitespace = function(string, index) {\n            var length = string.length;\n            for(; index < length; index++){\n                var chr = at(string, index);\n                if (chr !== \" \" && chr !== \"\t\" && chr !== \"\\n\" && chr !== \"\\f\" && chr !== \"\\r\") break;\n            }\n            return index;\n        };\n        var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {\n            var chunkLength = chunk.length;\n            if (chunkLength < 4) {\n                chunk += chunkLength === 2 ? \"AA\" : \"A\";\n            }\n            var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];\n            var chunkBytes = [\n                triplet >> 16 & 255,\n                triplet >> 8 & 255,\n                triplet & 255\n            ];\n            if (chunkLength === 2) {\n                if (throwOnExtraBits && chunkBytes[1] !== 0) {\n                    throw new SyntaxError1(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0]\n                ];\n            }\n            if (chunkLength === 3) {\n                if (throwOnExtraBits && chunkBytes[2] !== 0) {\n                    throw new SyntaxError1(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0],\n                    chunkBytes[1]\n                ];\n            }\n            return chunkBytes;\n        };\n        var writeBytes = function(bytes, elements, written) {\n            var elementsLength = elements.length;\n            for(var index = 0; index < elementsLength; index++){\n                bytes[written + index] = elements[index];\n            }\n            return written + elementsLength;\n        };\n        /* eslint-disable max-statements, max-depth -- TODO */ module.exports = function(string, options, into, maxLength) {\n            aString(string);\n            anObjectOrUndefined(options);\n            var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n            var lastChunkHandling = options ? options.lastChunkHandling : undefined;\n            if (lastChunkHandling === undefined) lastChunkHandling = \"loose\";\n            if (lastChunkHandling !== \"loose\" && lastChunkHandling !== \"strict\" && lastChunkHandling !== \"stop-before-partial\") {\n                throw new TypeError1(\"Incorrect `lastChunkHandling` option\");\n            }\n            if (into) notDetached(into.buffer);\n            var stringLength = string.length;\n            var bytes = into || [];\n            var written = 0;\n            var read = 0;\n            var chunk = \"\";\n            var index = 0;\n            if (maxLength) while(true){\n                index = skipAsciiWhitespace(string, index);\n                if (index === stringLength) {\n                    if (chunk.length > 0) {\n                        if (lastChunkHandling === \"stop-before-partial\") {\n                            break;\n                        }\n                        if (lastChunkHandling === \"loose\") {\n                            if (chunk.length === 1) {\n                                throw new SyntaxError1(\"Malformed padding: exactly one additional character\");\n                            }\n                            written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                        } else {\n                            throw new SyntaxError1(\"Missing padding\");\n                        }\n                    }\n                    read = stringLength;\n                    break;\n                }\n                var chr = at(string, index);\n                ++index;\n                if (chr === \"=\") {\n                    if (chunk.length < 2) {\n                        throw new SyntaxError1(\"Padding is too early\");\n                    }\n                    index = skipAsciiWhitespace(string, index);\n                    if (chunk.length === 2) {\n                        if (index === stringLength) {\n                            if (lastChunkHandling === \"stop-before-partial\") {\n                                break;\n                            }\n                            throw new SyntaxError1(\"Malformed padding: only one =\");\n                        }\n                        if (at(string, index) === \"=\") {\n                            ++index;\n                            index = skipAsciiWhitespace(string, index);\n                        }\n                    }\n                    if (index < stringLength) {\n                        throw new SyntaxError1(\"Unexpected character after padding\");\n                    }\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === \"strict\"), written);\n                    read = stringLength;\n                    break;\n                }\n                if (!hasOwn(alphabet, chr)) {\n                    throw new SyntaxError1(\"Unexpected character\");\n                }\n                var remainingBytes = maxLength - written;\n                if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {\n                    break;\n                }\n                chunk += chr;\n                if (chunk.length === 4) {\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                    chunk = \"\";\n                    read = index;\n                    if (written === maxLength) {\n                        break;\n                    }\n                }\n            }\n            return {\n                bytes: bytes,\n                read: read,\n                written: written\n            };\n        };\n    /***/ },\n    /***/ 9286: /***/ (module, __unused_webpack_exports, __nested_webpack_require_193785__)=>{\n        var SetHelpers = __nested_webpack_require_193785__(4402);\n        var iterate = __nested_webpack_require_193785__(8469);\n        var Set1 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        module.exports = function(set) {\n            var result = new Set1();\n            iterate(set, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 9297: /***/ (module, __unused_webpack_exports, __nested_webpack_require_194254__)=>{\n        var uncurryThis = __nested_webpack_require_194254__(9504);\n        var toObject = __nested_webpack_require_194254__(8981);\n        var hasOwnProperty = uncurryThis({}.hasOwnProperty);\n        // `HasOwnProperty` abstract operation\n        // https://tc39.es/ecma262/#sec-hasownproperty\n        // eslint-disable-next-line es/no-object-hasown -- safe\n        module.exports = Object.hasOwn || function hasOwn(it, key) {\n            return hasOwnProperty(toObject(it), key);\n        };\n    /***/ },\n    /***/ 9306: /***/ (module, __unused_webpack_exports, __nested_webpack_require_194812__)=>{\n        var isCallable = __nested_webpack_require_194812__(4901);\n        var tryToString = __nested_webpack_require_194812__(6823);\n        var $TypeError = TypeError;\n        // `Assert: IsCallable(argument) is true`\n        module.exports = function(argument) {\n            if (isCallable(argument)) return argument;\n            throw new $TypeError(tryToString(argument) + \" is not a function\");\n        };\n    /***/ },\n    /***/ 9314: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_195306__)=>{\n        var $ = __nested_webpack_require_195306__(6518);\n        var call = __nested_webpack_require_195306__(9565);\n        var anObject = __nested_webpack_require_195306__(8551);\n        var getIteratorDirect = __nested_webpack_require_195306__(1767);\n        var notANaN = __nested_webpack_require_195306__(4149);\n        var toPositiveInteger = __nested_webpack_require_195306__(9590);\n        var iteratorClose = __nested_webpack_require_195306__(9539);\n        var createIteratorProxy = __nested_webpack_require_195306__(9462);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_195306__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_195306__(4549);\n        var IS_PURE = __nested_webpack_require_195306__(6395);\n        var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"drop\", 0);\n        var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"drop\", RangeError);\n        var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var next = this.next;\n            var result, done;\n            while(this.remaining){\n                this.remaining--;\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n            }\n            result = anObject(call(next, iterator));\n            done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        // `Iterator.prototype.drop` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.drop\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            drop: function drop(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining: remaining\n                });\n            }\n        });\n    /***/ },\n    /***/ 9429: /***/ (module, __unused_webpack_exports, __nested_webpack_require_197783__)=>{\n        var globalThis1 = __nested_webpack_require_197783__(4576);\n        var IS_NODE = __nested_webpack_require_197783__(6193);\n        module.exports = function(name) {\n            if (IS_NODE) {\n                try {\n                    return globalThis1.process.getBuiltinModule(name);\n                } catch (error) {}\n                try {\n                    // eslint-disable-next-line no-new-func -- safe\n                    return Function('return require(\"' + name + '\")')();\n                } catch (error) {}\n            }\n        };\n    /***/ },\n    /***/ 9432: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_198416__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_198416__(5213);\n    /***/ },\n    /***/ 9433: /***/ (module, __unused_webpack_exports, __nested_webpack_require_198586__)=>{\n        var globalThis1 = __nested_webpack_require_198586__(4576);\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        module.exports = function(key, value) {\n            try {\n                defineProperty(globalThis1, key, {\n                    value: value,\n                    configurable: true,\n                    writable: true\n                });\n            } catch (error) {\n                globalThis1[key] = value;\n            }\n            return value;\n        };\n    /***/ },\n    /***/ 9462: /***/ (module, __unused_webpack_exports, __nested_webpack_require_199226__)=>{\n        var call = __nested_webpack_require_199226__(9565);\n        var create = __nested_webpack_require_199226__(2360);\n        var createNonEnumerableProperty = __nested_webpack_require_199226__(6699);\n        var defineBuiltIns = __nested_webpack_require_199226__(6279);\n        var wellKnownSymbol = __nested_webpack_require_199226__(8227);\n        var InternalStateModule = __nested_webpack_require_199226__(1181);\n        var getMethod = __nested_webpack_require_199226__(5966);\n        var IteratorPrototype = __nested_webpack_require_199226__(7657).IteratorPrototype;\n        var createIterResultObject = __nested_webpack_require_199226__(2529);\n        var iteratorClose = __nested_webpack_require_199226__(9539);\n        var iteratorCloseAll = __nested_webpack_require_199226__(1385);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var ITERATOR_HELPER = \"IteratorHelper\";\n        var WRAP_FOR_VALID_ITERATOR = \"WrapForValidIterator\";\n        var NORMAL = \"normal\";\n        var THROW = \"throw\";\n        var setInternalState = InternalStateModule.set;\n        var createIteratorProxyPrototype = function(IS_ITERATOR) {\n            var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);\n            return defineBuiltIns(create(IteratorPrototype), {\n                next: function next() {\n                    var state = getInternalState(this);\n                    // for simplification:\n                    //   for `%WrapForValidIteratorPrototype%.next` or with `state.returnHandlerResult` our `nextHandler` returns `IterResultObject`\n                    //   for `%IteratorHelperPrototype%.next` - just a value\n                    if (IS_ITERATOR) return state.nextHandler();\n                    if (state.done) return createIterResultObject(undefined, true);\n                    try {\n                        var result = state.nextHandler();\n                        return state.returnHandlerResult ? result : createIterResultObject(result, state.done);\n                    } catch (error) {\n                        state.done = true;\n                        throw error;\n                    }\n                },\n                \"return\": function() {\n                    var state = getInternalState(this);\n                    var iterator = state.iterator;\n                    state.done = true;\n                    if (IS_ITERATOR) {\n                        var returnMethod = getMethod(iterator, \"return\");\n                        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);\n                    }\n                    if (state.inner) try {\n                        iteratorClose(state.inner.iterator, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (state.openIters) try {\n                        iteratorCloseAll(state.openIters, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (iterator) iteratorClose(iterator, NORMAL);\n                    return createIterResultObject(undefined, true);\n                }\n            });\n        };\n        var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);\n        var IteratorHelperPrototype = createIteratorProxyPrototype(false);\n        createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, \"Iterator Helper\");\n        module.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {\n            var IteratorProxy = function Iterator1(record, state) {\n                if (state) {\n                    state.iterator = record.iterator;\n                    state.next = record.next;\n                } else state = record;\n                state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;\n                state.returnHandlerResult = !!RETURN_HANDLER_RESULT;\n                state.nextHandler = nextHandler;\n                state.counter = 0;\n                state.done = false;\n                setInternalState(this, state);\n            };\n            IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;\n            return IteratorProxy;\n        };\n    /***/ },\n    /***/ 9486: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_203554__)=>{\n        var $ = __nested_webpack_require_203554__(6518);\n        var globalThis1 = __nested_webpack_require_203554__(4576);\n        var uncurryThis = __nested_webpack_require_203554__(9504);\n        var anObjectOrUndefined = __nested_webpack_require_203554__(3972);\n        var anUint8Array = __nested_webpack_require_203554__(4154);\n        var notDetached = __nested_webpack_require_203554__(5169);\n        var base64Map = __nested_webpack_require_203554__(2804);\n        var getAlphabetOption = __nested_webpack_require_203554__(944);\n        var base64Alphabet = base64Map.i2c;\n        var base64UrlAlphabet = base64Map.i2cUrl;\n        var charAt = uncurryThis(\"\".charAt);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.toBase64 || !function() {\n            try {\n                var target = new Uint8Array1();\n                target.toBase64(null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `Uint8Array.prototype.toBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toBase64: function toBase64() {\n                var array = anUint8Array(this);\n                var options = arguments.length ? anObjectOrUndefined(arguments[0]) : undefined;\n                var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n                var omitPadding = !!options && !!options.omitPadding;\n                notDetached(this.buffer);\n                var result = \"\";\n                var i = 0;\n                var length = array.length;\n                var triplet;\n                var at = function(shift) {\n                    return charAt(alphabet, triplet >> 6 * shift & 63);\n                };\n                for(; i + 2 < length; i += 3){\n                    triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];\n                    result += at(3) + at(2) + at(1) + at(0);\n                }\n                if (i + 2 === length) {\n                    triplet = (array[i] << 16) + (array[i + 1] << 8);\n                    result += at(3) + at(2) + at(1) + (omitPadding ? \"\" : \"=\");\n                } else if (i + 1 === length) {\n                    triplet = array[i] << 16;\n                    result += at(3) + at(2) + (omitPadding ? \"\" : \"==\");\n                }\n                return result;\n            }\n        });\n    /***/ },\n    /***/ 9504: /***/ (module, __unused_webpack_exports, __nested_webpack_require_206156__)=>{\n        var NATIVE_BIND = __nested_webpack_require_206156__(616);\n        var FunctionPrototype = Function.prototype;\n        var call = FunctionPrototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind -- safe\n        var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n        module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {\n            return function() {\n                return call.apply(fn, arguments);\n            };\n        };\n    /***/ },\n    /***/ 9519: /***/ (module, __unused_webpack_exports, __nested_webpack_require_206745__)=>{\n        var globalThis1 = __nested_webpack_require_206745__(4576);\n        var userAgent = __nested_webpack_require_206745__(2839);\n        var process1 = globalThis1.process;\n        var Deno1 = globalThis1.Deno;\n        var versions = process1 && process1.versions || Deno1 && Deno1.version;\n        var v8 = versions && versions.v8;\n        var match, version;\n        if (v8) {\n            match = v8.split(\".\");\n            // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n            // but their correct versions are not interesting for us\n            version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n        }\n        // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n        // so check `userAgent` even if `.v8` exists, but 0\n        if (!version && userAgent) {\n            match = userAgent.match(/Edge\\/(\\d+)/);\n            if (!match || match[1] >= 74) {\n                match = userAgent.match(/Chrome\\/(\\d+)/);\n                if (match) version = +match[1];\n            }\n        }\n        module.exports = version;\n    /***/ },\n    /***/ 9539: /***/ (module, __unused_webpack_exports, __nested_webpack_require_207891__)=>{\n        var call = __nested_webpack_require_207891__(9565);\n        var anObject = __nested_webpack_require_207891__(8551);\n        var getMethod = __nested_webpack_require_207891__(5966);\n        module.exports = function(iterator, kind, value) {\n            var innerResult, innerError;\n            anObject(iterator);\n            try {\n                innerResult = getMethod(iterator, \"return\");\n                if (!innerResult) {\n                    if (kind === \"throw\") throw value;\n                    return value;\n                }\n                innerResult = call(innerResult, iterator);\n            } catch (error) {\n                innerError = true;\n                innerResult = error;\n            }\n            if (kind === \"throw\") throw value;\n            if (innerError) throw innerResult;\n            anObject(innerResult);\n            return value;\n        };\n    /***/ },\n    /***/ 9565: /***/ (module, __unused_webpack_exports, __nested_webpack_require_208827__)=>{\n        var NATIVE_BIND = __nested_webpack_require_208827__(616);\n        var call = Function.prototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind -- safe\n        module.exports = NATIVE_BIND ? call.bind(call) : function() {\n            return call.apply(call, arguments);\n        };\n    /***/ },\n    /***/ 9577: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_209237__)=>{\n        var arrayWith = __nested_webpack_require_209237__(9928);\n        var ArrayBufferViewCore = __nested_webpack_require_209237__(4644);\n        var isBigIntArray = __nested_webpack_require_209237__(1108);\n        var toIntegerOrInfinity = __nested_webpack_require_209237__(1291);\n        var toBigInt = __nested_webpack_require_209237__(5854);\n        var aTypedArray = ArrayBufferViewCore.aTypedArray;\n        var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\n        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n        var PROPER_ORDER = function() {\n            try {\n                // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing\n                new Int8Array(1)[\"with\"](2, {\n                    valueOf: function() {\n                        throw 8;\n                    }\n                });\n            } catch (error) {\n                // some early implementations, like WebKit, does not follow the final semantic\n                // https://github.com/tc39/proposal-change-array-by-copy/pull/86\n                return error === 8;\n            }\n        }();\n        // Bug in WebKit. It should truncate a negative fractional index to zero, but instead throws an error\n        var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && function() {\n            try {\n                // eslint-disable-next-line es/no-typed-arrays, es/no-array-prototype-with -- required for testing\n                new Int8Array(1)[\"with\"](-0.5, 1);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `%TypedArray%.prototype.with` method\n        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.with\n        exportTypedArrayMethod(\"with\", {\n            \"with\": function(index, value) {\n                var O = aTypedArray(this);\n                var relativeIndex = toIntegerOrInfinity(index);\n                var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;\n                return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);\n            }\n        }[\"with\"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);\n    /***/ },\n    /***/ 9590: /***/ (module, __unused_webpack_exports, __nested_webpack_require_211484__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_211484__(1291);\n        var $RangeError = RangeError;\n        module.exports = function(it) {\n            var result = toIntegerOrInfinity(it);\n            if (result < 0) throw new $RangeError(\"The argument can't be less than 0\");\n            return result;\n        };\n    /***/ },\n    /***/ 9617: /***/ (module, __unused_webpack_exports, __nested_webpack_require_211893__)=>{\n        var toIndexedObject = __nested_webpack_require_211893__(5397);\n        var toAbsoluteIndex = __nested_webpack_require_211893__(5610);\n        var lengthOfArrayLike = __nested_webpack_require_211893__(6198);\n        // `Array.prototype.{ indexOf, includes }` methods implementation\n        var createMethod = function(IS_INCLUDES) {\n            return function($this, el, fromIndex) {\n                var O = toIndexedObject($this);\n                var length = lengthOfArrayLike(O);\n                if (length === 0) return !IS_INCLUDES && -1;\n                var index = toAbsoluteIndex(fromIndex, length);\n                var value;\n                // Array#includes uses SameValueZero equality algorithm\n                // eslint-disable-next-line no-self-compare -- NaN check\n                if (IS_INCLUDES && el !== el) while(length > index){\n                    value = O[index++];\n                    // eslint-disable-next-line no-self-compare -- NaN check\n                    if (value !== value) return true;\n                // Array#indexOf ignores holes, Array#includes - not\n                }\n                else for(; length > index; index++){\n                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                }\n                return !IS_INCLUDES && -1;\n            };\n        };\n        module.exports = {\n            // `Array.prototype.includes` method\n            // https://tc39.es/ecma262/#sec-array.prototype.includes\n            includes: createMethod(true),\n            // `Array.prototype.indexOf` method\n            // https://tc39.es/ecma262/#sec-array.prototype.indexof\n            indexOf: createMethod(false)\n        };\n    /***/ },\n    /***/ 9631: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213678__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_213678__(9486);\n    /***/ },\n    /***/ 9797: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213865__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_213865__(4226);\n    /***/ },\n    /***/ 9835: /***/ (module)=>{\n        // Should get iterator record of a set-like object before cloning this\n        // https://bugs.webkit.org/show_bug.cgi?id=289430\n        module.exports = function(METHOD_NAME) {\n            try {\n                // eslint-disable-next-line es/no-set -- needed for test\n                var baseSet = new Set();\n                var setLike = {\n                    size: 0,\n                    has: function() {\n                        return true;\n                    },\n                    keys: function() {\n                        // eslint-disable-next-line es/no-object-defineproperty -- needed for test\n                        return Object.defineProperty({}, \"next\", {\n                            get: function() {\n                                baseSet.clear();\n                                baseSet.add(4);\n                                return function() {\n                                    return {\n                                        done: true\n                                    };\n                                };\n                            }\n                        });\n                    }\n                };\n                var result = baseSet[METHOD_NAME](setLike);\n                return result.size === 1 && result.values().next().value === 4;\n            } catch (error) {\n                return false;\n            }\n        };\n    /***/ },\n    /***/ 9928: /***/ (module, __unused_webpack_exports, __nested_webpack_require_215453__)=>{\n        var lengthOfArrayLike = __nested_webpack_require_215453__(6198);\n        var toIntegerOrInfinity = __nested_webpack_require_215453__(1291);\n        var $RangeError = RangeError;\n        // https://tc39.es/ecma262/#sec-array.prototype.with\n        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.with\n        module.exports = function(O, C, index, value) {\n            var len = lengthOfArrayLike(O);\n            var relativeIndex = toIntegerOrInfinity(index);\n            var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;\n            if (actualIndex >= len || actualIndex < 0) throw new $RangeError(\"Incorrect index\");\n            var A = new C(len);\n            var k = 0;\n            for(; k < len; k++)A[k] = k === actualIndex ? value : O[k];\n            return A;\n        };\n    /***/ }\n};\n/************************************************************************/ /******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ /******/ // The require function\n/******/ function __nested_webpack_require_216482__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/ var cachedModule = __webpack_module_cache__[moduleId];\n    /******/ if (cachedModule !== undefined) {\n        /******/ return cachedModule.exports;\n    /******/ }\n    /******/ // Create a new module (and put it into the cache)\n    /******/ var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/ exports: {}\n    };\n    /******/ /******/ // Execute the module function\n    /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_216482__);\n    /******/ /******/ // Return the exports of the module\n    /******/ return module.exports;\n/******/ }\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_216482__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_216482__.o(definition, key) && !__nested_webpack_require_216482__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_216482__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __webpack_exports__ = {};\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js\nvar es_array_push = __nested_webpack_require_216482__(4114);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.detached.js\nvar es_array_buffer_detached = __nested_webpack_require_216482__(6573);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.transfer.js\nvar es_array_buffer_transfer = __nested_webpack_require_216482__(8100);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js\nvar es_array_buffer_transfer_to_fixed_length = __nested_webpack_require_216482__(7936);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.constructor.js\nvar es_iterator_constructor = __nested_webpack_require_216482__(8111);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.reduce.js\nvar es_iterator_reduce = __nested_webpack_require_216482__(8237);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.try.js\nvar es_promise_try = __nested_webpack_require_216482__(1689);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.with.js\nvar es_typed_array_with = __nested_webpack_require_216482__(9577);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.math.sum-precise.js\nvar esnext_math_sum_precise = __nested_webpack_require_216482__(4235);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.from-base64.js\nvar esnext_uint8_array_from_base64 = __nested_webpack_require_216482__(9432);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.set-from-base64.js\nvar esnext_uint8_array_set_from_base64 = __nested_webpack_require_216482__(1549);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.set-from-hex.js\nvar esnext_uint8_array_set_from_hex = __nested_webpack_require_216482__(9797);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.to-base64.js\nvar esnext_uint8_array_to_base64 = __nested_webpack_require_216482__(9631);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.to-hex.js\nvar esnext_uint8_array_to_hex = __nested_webpack_require_216482__(5623);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-exception.stack.js\nvar web_dom_exception_stack = __nested_webpack_require_216482__(4979);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.parse.js\nvar web_url_parse = __nested_webpack_require_216482__(5781);\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15,\n    POPUP: 16,\n    SIGNATURE: 101,\n    COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_THICKNESS: 32,\n    HIGHLIGHT_FREE: 33,\n    HIGHLIGHT_SHOW_ALL: 34,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93,\n    rawFillPath: 94\n};\nconst DrawOPS = {\n    moveTo: 0,\n    lineTo: 1,\n    curveTo: 2,\n    closePath: 3\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.info(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.warn(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    if (options && typeof url === \"string\") {\n        if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n            const dots = url.match(/\\./g);\n            if (dots?.length >= 2) {\n                url = `http://${url}`;\n            }\n        }\n        if (options.tryConvertEncoding) {\n            try {\n                url = stringToUTF8String(url);\n            } catch  {}\n        }\n    }\n    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n    const res = URL.parse(url);\n    if (res) {\n        res.hash = hash;\n        return res.href;\n    }\n    if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n    }\n    return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass ResponseException extends BaseException {\n    constructor(msg, status, missing){\n        super(msg, \"ResponseException\");\n        this.status = status;\n        this.missing = missing;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        const { platform, userAgent } = navigator;\n        return shadow(this, \"platform\", {\n            isAndroid: userAgent.includes(\"Android\"),\n            isLinux: platform.includes(\"Linux\"),\n            isMac: platform.includes(\"Mac\"),\n            isWindows: platform.includes(\"Win\"),\n            isFirefox: userAgent.includes(\"Firefox\")\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static domMatrixToTransform(dm) {\n        return [\n            dm.a,\n            dm.b,\n            dm.c,\n            dm.d,\n            dm.e,\n            dm.f\n        ];\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static multiplyByDOMMatrix(m, md) {\n        return [\n            m[0] * md.a + m[2] * md.b,\n            m[1] * md.a + m[3] * md.b,\n            m[0] * md.c + m[2] * md.d,\n            m[1] * md.c + m[3] * md.d,\n            m[0] * md.e + m[2] * md.f + m[4],\n            m[1] * md.e + m[3] * md.f + m[5]\n        ];\n    }\n    static applyTransform(p, m, pos = 0) {\n        const p0 = p[pos];\n        const p1 = p[pos + 1];\n        p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n    }\n    static applyTransformToBezier(p, transform, pos = 0) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        for(let i = 0; i < 6; i += 2){\n            const pI = p[pos + i];\n            const pI1 = p[pos + i + 1];\n            p[pos + i] = pI * m0 + pI1 * m2 + m4;\n            p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n        }\n    }\n    static applyInverseTransform(p, m) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const d = m[0] * m[3] - m[1] * m[2];\n        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    }\n    static axialAlignedBoundingBox(rect, transform, output) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        const r0 = rect[0];\n        const r1 = rect[1];\n        const r2 = rect[2];\n        const r3 = rect[3];\n        let a0 = m0 * r0 + m4;\n        let a2 = a0;\n        let a1 = m0 * r2 + m4;\n        let a3 = a1;\n        let b0 = m3 * r1 + m5;\n        let b2 = b0;\n        let b1 = m3 * r3 + m5;\n        let b3 = b1;\n        if (m1 !== 0 || m2 !== 0) {\n            const m1r0 = m1 * r0;\n            const m1r2 = m1 * r2;\n            const m2r1 = m2 * r1;\n            const m2r3 = m2 * r3;\n            a0 += m2r1;\n            a3 += m2r1;\n            a1 += m2r3;\n            a2 += m2r3;\n            b0 += m1r0;\n            b3 += m1r0;\n            b1 += m1r2;\n            b2 += m1r2;\n        }\n        output[0] = Math.min(output[0], a0, a1, a2, a3);\n        output[1] = Math.min(output[1], b0, b1, b2, b3);\n        output[2] = Math.max(output[2], a0, a1, a2, a3);\n        output[3] = Math.max(output[3], b0, b1, b2, b3);\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(matrix, output) {\n        const m0 = matrix[0];\n        const m1 = matrix[1];\n        const m2 = matrix[2];\n        const m3 = matrix[3];\n        const a = m0 ** 2 + m1 ** 2;\n        const b = m0 * m2 + m1 * m3;\n        const c = m2 ** 2 + m3 ** 2;\n        const first = (a + c) / 2;\n        const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n        output[0] = Math.sqrt(first + second || 1);\n        output[1] = Math.sqrt(first - second || 1);\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static pointBoundingBox(x, y, minMax) {\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static rectBoundingBox(x0, y0, x1, y1, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x1);\n        minMax[1] = Math.min(minMax[1], y0, y1);\n        minMax[2] = Math.max(minMax[2], x0, x1);\n        minMax[3] = Math.max(minMax[3], y0, y1);\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x3);\n        minMax[1] = Math.min(minMax[1], y0, y3);\n        minMax[2] = Math.max(minMax[2], x0, x3);\n        minMax[3] = Math.max(minMax[3], y0, y3);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str, keepEscapeSequence = false) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (keepEscapeSequence || !decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (!keepEscapeSequence && charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    if (!(date instanceof Date)) {\n        date = new Date(date);\n    }\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"\",\n                \"t\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n    if (!Array.isArray(dest) || dest.length < 2) {\n        return false;\n    }\n    const [page, zoom, ...args] = dest;\n    if (!validRef(page) && !Number.isInteger(page)) {\n        return false;\n    }\n    if (!validName(zoom)) {\n        return false;\n    }\n    const argsLen = args.length;\n    let allowNull = true;\n    switch(zoom.name){\n        case \"XYZ\":\n            if (argsLen < 2 || argsLen > 3) {\n                return false;\n            }\n            break;\n        case \"Fit\":\n        case \"FitB\":\n            return argsLen === 0;\n        case \"FitH\":\n        case \"FitBH\":\n        case \"FitV\":\n        case \"FitBV\":\n            if (argsLen > 1) {\n                return false;\n            }\n            break;\n        case \"FitR\":\n            if (argsLen !== 4) {\n                return false;\n            }\n            allowNull = false;\n            break;\n        default:\n            return false;\n    }\n    for (const arg of args){\n        if (typeof arg === \"number\" || allowNull && arg === null) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction MathClamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Math.sumPrecise !== \"function\") {\n    Math.sumPrecise = function(numbers) {\n        return numbers.reduce((a, b)=>a + b, 0);\n    };\n}\nif (typeof AbortSignal.any !== \"function\") {\n    AbortSignal.any = function(iterable) {\n        const ac = new AbortController();\n        const { signal } = ac;\n        for (const s of iterable){\n            if (s.aborted) {\n                ac.abort(s.reason);\n                return signal;\n            }\n        }\n        for (const s of iterable){\n            s.addEventListener(\"abort\", ()=>{\n                ac.abort(s.reason);\n            }, {\n                signal\n            });\n        }\n        return signal;\n    };\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.map.js\nvar es_iterator_map = __nested_webpack_require_216482__(1701);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js\nvar web_url_search_params_delete = __nested_webpack_require_216482__(4603);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js\nvar web_url_search_params_has = __nested_webpack_require_216482__(7566);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js\nvar web_url_search_params_size = __nested_webpack_require_216482__(8721);\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const dims = this.viewBox;\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyTransform(p, this.transform);\n        return p;\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = [\n            rect[0],\n            rect[1]\n        ];\n        Util.applyTransform(topLeft, this.transform);\n        const bottomRight = [\n            rect[2],\n            rect[3]\n        ];\n        Util.applyTransform(bottomRight, this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyInverseTransform(p, this.transform);\n        return p;\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const getURL = (urlString)=>{\n        try {\n            return new URL(urlString);\n        } catch  {\n            try {\n                return new URL(decodeURIComponent(urlString));\n            } catch  {\n                try {\n                    return new URL(urlString, \"https://foo.bar\");\n                } catch  {\n                    try {\n                        return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n                    } catch  {\n                        return null;\n                    }\n                }\n            }\n        }\n    };\n    const newURL = getURL(url);\n    if (!newURL) {\n        return defaultFilename;\n    }\n    const decode = (name)=>{\n        try {\n            let decoded = decodeURIComponent(name);\n            if (decoded.includes(\"/\")) {\n                decoded = decoded.split(\"/\").at(-1);\n                if (decoded.test(/^\\.pdf$/i)) {\n                    return decoded;\n                }\n                return name;\n            }\n            return decoded;\n        } catch  {\n            return name;\n        }\n    };\n    const pdfRegex = /\\.pdf$/i;\n    const filename = newURL.pathname.split(\"/\").at(-1);\n    if (pdfRegex.test(filename)) {\n        return decode(filename);\n    }\n    if (newURL.searchParams.size > 0) {\n        const values = Array.from(newURL.searchParams.values()).reverse();\n        for (const value of values){\n            if (pdfRegex.test(value)) {\n                return decode(value);\n            }\n        }\n        const keys = Array.from(newURL.searchParams.keys()).reverse();\n        for (const key of keys){\n            if (pdfRegex.test(key)) {\n                return decode(key);\n            }\n        }\n    }\n    if (newURL.hash) {\n        const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n        const hashFilename = reFilename.exec(newURL.hash);\n        if (hashFilename) {\n            return decode(hashFilename[0]);\n        }\n    }\n    return defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (input instanceof Date) {\n            return input;\n        }\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    span.style.colorScheme = \"only light\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const { pixelRatio } = OutputScale;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n    limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;\n        maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n        if (maxPixels > 0) {\n            maxAreaScale = Math.sqrt(maxPixels / (width * height));\n        }\n        if (maxDim !== -1) {\n            maxWidthScale = maxDim / width;\n            maxHeightScale = maxDim / height;\n        }\n        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n        if (this.sx > maxScale || this.sy > maxScale) {\n            this.sx = maxScale;\n            this.sy = maxScale;\n            return true;\n        }\n        return false;\n    }\n    static get pixelRatio() {\n        return globalThis.devicePixelRatio || 1;\n    }\n    static capPixels(maxPixels, capAreaFactor) {\n        if (capAreaFactor >= 0) {\n            const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n            return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n        }\n        return maxPixels;\n    }\n}\nconst SupportedImageMimeTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n];\nclass ColorScheme {\n    static get isDarkMode() {\n        return shadow(this, \"isDarkMode\", !!window?.matchMedia?.(\"(prefers-color-scheme: dark)\").matches);\n    }\n}\nclass CSSConstants {\n    static get commentForegroundColor() {\n        const element = document.createElement(\"span\");\n        element.classList.add(\"comment\", \"sidebar\");\n        const { style } = element;\n        style.width = style.height = \"0\";\n        style.display = \"none\";\n        style.color = \"var(--comment-fg-color)\";\n        document.body.append(element);\n        const { color } = window.getComputedStyle(element);\n        element.remove();\n        return shadow(this, \"commentForegroundColor\", getRGB(color));\n    }\n}\nfunction applyOpacity(r, g, b, opacity) {\n    opacity = Math.min(Math.max(opacity ?? 1, 0), 1);\n    const white = 255 * (1 - opacity);\n    r = Math.round(r * opacity + white);\n    g = Math.round(g * opacity + white);\n    b = Math.round(b * opacity + white);\n    return [\n        r,\n        g,\n        b\n    ];\n}\nfunction RGBToHSL(rgb, output) {\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    if (max === min) {\n        output[0] = output[1] = 0;\n    } else {\n        const d = max - min;\n        output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);\n        switch(max){\n            case r:\n                output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;\n                break;\n            case g:\n                output[0] = ((b - r) / d + 2) * 60;\n                break;\n            case b:\n                output[0] = ((r - g) / d + 4) * 60;\n                break;\n        }\n    }\n    output[2] = l;\n}\nfunction HSLToRGB(hsl, output) {\n    const h = hsl[0];\n    const s = hsl[1];\n    const l = hsl[2];\n    const c = (1 - Math.abs(2 * l - 1)) * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = l - c / 2;\n    switch(Math.floor(h / 60)){\n        case 0:\n            output[0] = c + m;\n            output[1] = x + m;\n            output[2] = m;\n            break;\n        case 1:\n            output[0] = x + m;\n            output[1] = c + m;\n            output[2] = m;\n            break;\n        case 2:\n            output[0] = m;\n            output[1] = c + m;\n            output[2] = x + m;\n            break;\n        case 3:\n            output[0] = m;\n            output[1] = x + m;\n            output[2] = c + m;\n            break;\n        case 4:\n            output[0] = x + m;\n            output[1] = m;\n            output[2] = c + m;\n            break;\n        case 5:\n        case 6:\n            output[0] = c + m;\n            output[1] = m;\n            output[2] = x + m;\n            break;\n    }\n}\nfunction computeLuminance(x) {\n    return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n}\nfunction contrastRatio(hsl1, hsl2, output) {\n    HSLToRGB(hsl1, output);\n    output.map(computeLuminance);\n    const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    HSLToRGB(hsl2, output);\n    output.map(computeLuminance);\n    const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n}\nconst contrastCache = new Map();\nfunction findContrastColor(baseColor, fixedColor) {\n    const key = baseColor[0] + baseColor[1] * 0x100 + baseColor[2] * 0x10000 + fixedColor[0] * 0x1000000 + fixedColor[1] * 0x100000000 + fixedColor[2] * 0x10000000000;\n    let cachedValue = contrastCache.get(key);\n    if (cachedValue) {\n        return cachedValue;\n    }\n    const array = new Float32Array(9);\n    const output = array.subarray(0, 3);\n    const baseHSL = array.subarray(3, 6);\n    RGBToHSL(baseColor, baseHSL);\n    const fixedHSL = array.subarray(6, 9);\n    RGBToHSL(fixedColor, fixedHSL);\n    const isFixedColorDark = fixedHSL[2] < 0.5;\n    const minContrast = isFixedColorDark ? 12 : 4.5;\n    baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);\n    if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n        let start, end;\n        if (isFixedColorDark) {\n            start = baseHSL[2];\n            end = 1;\n        } else {\n            start = 0;\n            end = baseHSL[2];\n        }\n        const PRECISION = 0.005;\n        while(end - start > PRECISION){\n            const mid = baseHSL[2] = (start + end) / 2;\n            if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        baseHSL[2] = isFixedColorDark ? end : start;\n    }\n    HSLToRGB(baseHSL, output);\n    cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));\n    contrastCache.set(key, cachedValue);\n    return cachedValue;\n}\nfunction renderRichText({ html, dir, className }, container) {\n    const fragment = document.createDocumentFragment();\n    if (typeof html === \"string\") {\n        const p = document.createElement(\"p\");\n        p.dir = dir || \"auto\";\n        const lines = html.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        fragment.append(p);\n    } else {\n        XfaLayer.render({\n            xfaHtml: html,\n            div: fragment,\n            intent: \"richText\"\n        });\n    }\n    fragment.firstChild.classList.add(\"richText\", className);\n    container.append(fragment);\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.take.js\nvar es_iterator_take = __nested_webpack_require_216482__(4972);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.with-resolvers.js\nvar es_promise_with_resolvers = __nested_webpack_require_216482__(4628);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.difference.v2.js\nvar es_set_difference_v2 = __nested_webpack_require_216482__(7642);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.intersection.v2.js\nvar es_set_intersection_v2 = __nested_webpack_require_216482__(8004);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-disjoint-from.v2.js\nvar es_set_is_disjoint_from_v2 = __nested_webpack_require_216482__(3853);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-subset-of.v2.js\nvar es_set_is_subset_of_v2 = __nested_webpack_require_216482__(5876);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-superset-of.v2.js\nvar es_set_is_superset_of_v2 = __nested_webpack_require_216482__(2475);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.symmetric-difference.v2.js\nvar es_set_symmetric_difference_v2 = __nested_webpack_require_216482__(5024);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.union.v2.js\nvar es_set_union_v2 = __nested_webpack_require_216482__(1698);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.drop.js\nvar es_iterator_drop = __nested_webpack_require_216482__(9314);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.every.js\nvar es_iterator_every = __nested_webpack_require_216482__(1148);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.some.js\nvar es_iterator_some = __nested_webpack_require_216482__(3579);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.json.parse.js\nvar esnext_json_parse = __nested_webpack_require_216482__(8335);\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    #comment;\n    #commentButtonDivider;\n    #signatureDescriptionButton;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentButtonDivider = null;\n        this.#signatureDescriptionButton = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\",\n            signature: \"pdfjs-editor-remove-signature-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return false;\n        }\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        return true;\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n        this.#comment?.shown();\n    }\n    addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", \"deleteButton\");\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        if (this.#addListenersToElement(button)) {\n            button.addEventListener(\"click\", (e)=>{\n                _uiManager.delete();\n            }, {\n                signal: _uiManager._signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n        this.#altText = altText;\n    }\n    addComment(comment, beforeElement = null) {\n        if (this.#comment) {\n            return;\n        }\n        const button = comment.renderForToolbar();\n        if (!button) {\n            return;\n        }\n        this.#addListenersToElement(button);\n        const divider = this.#commentButtonDivider = this.#divider;\n        if (!beforeElement) {\n            this.#buttons.append(button, divider);\n        } else {\n            this.#buttons.insertBefore(button, beforeElement);\n            this.#buttons.insertBefore(divider, beforeElement);\n        }\n        this.#comment = comment;\n        comment.toolbar = this;\n    }\n    addColorPicker(colorPicker) {\n        if (this.#colorPicker) {\n            return;\n        }\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    async addEditSignatureButton(signatureManager) {\n        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    removeButton(name) {\n        switch(name){\n            case \"comment\":\n                this.#comment?.removeToolbarCommentButton();\n                this.#comment = null;\n                this.#commentButtonDivider?.remove();\n                this.#commentButtonDivider = null;\n                break;\n        }\n    }\n    async addButton(name, tool) {\n        switch(name){\n            case \"colorPicker\":\n                this.addColorPicker(tool);\n                break;\n            case \"altText\":\n                await this.addAltText(tool);\n                break;\n            case \"editSignature\":\n                await this.addEditSignatureButton(tool);\n                break;\n            case \"delete\":\n                this.addDeleteButton();\n                break;\n            case \"comment\":\n                this.addComment(tool);\n                break;\n        }\n    }\n    async addButtonBefore(name, tool, beforeSelector) {\n        const beforeElement = this.#buttons.querySelector(beforeSelector);\n        if (!beforeElement) {\n            return;\n        }\n        if (name === \"comment\") {\n            this.addComment(tool, beforeElement);\n        }\n    }\n    updateEditSignatureButton(description) {\n        if (this.#signatureDescriptionButton) {\n            this.#signatureDescriptionButton.title = description;\n        }\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass FloatingToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        if (this.#uiManager.hasCommentManager()) {\n            this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", ()=>{\n                this.#uiManager.commentSelection(\"floating_button\");\n            });\n        }\n        this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        });\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", buttonClass);\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", l10nId);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", labelL10nId);\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            button.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            button.addEventListener(\"click\", clickHandler, {\n                signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self1, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self1, event)) {\n            return;\n        }\n        callback.bind(self1, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditableAnnotations;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #commentManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #floatingToolbar;\n    #idManager;\n    #isEnabled;\n    #isPointerDown;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #missingCanvases;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #signatureManager;\n    #pageColors;\n    #showAllStates;\n    #pdfDocument;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #viewerAlert;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self1)=>self1.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self1.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self1, { target: el })=>!(el instanceof HTMLButtonElement) && self1.#container.contains(el) && !self1.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self1, { target: el })=>!(el instanceof HTMLButtonElement) && self1.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditableAnnotations = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#commentManager = null;\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#floatingToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isPointerDown = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#missingCanvases = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#signatureManager = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#pdfDocument = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#viewerAlert = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#viewerAlert = viewerAlert;\n        this.#altTextManager = altTextManager;\n        this.#commentManager = commentManager;\n        this.#signatureManager = signatureManager;\n        this.#pdfDocument = pdfDocument;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", ()=>{\n            this.#isPointerDown = true;\n        }, {\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"pointerup\", ()=>{\n            this.#isPointerDown = false;\n        }, {\n            capture: true,\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n        commentManager?.setSidebarUiManager(this);\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#missingCanvases?.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#commentManager?.destroy();\n        this.#signatureManager?.destroy();\n        this.#floatingToolbar?.hide();\n        this.#floatingToolbar = null;\n        this.#mainHighlightColorPicker?.destroy();\n        this.#mainHighlightColorPicker = null;\n        this.#allEditableAnnotations = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n        this.#pdfDocument = null;\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get _highlightColors() {\n        return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>{\n            pair = pair.split(\"=\").map((x)=>x.trim());\n            pair[1] = pair[1].toUpperCase();\n            return pair;\n        })) : null);\n    }\n    get highlightColors() {\n        const { _highlightColors } = this;\n        if (!_highlightColors) {\n            return shadow(this, \"highlightColors\", null);\n        }\n        const map = new Map();\n        const hasHCM = !!this.#pageColors;\n        for (const [name, color] of _highlightColors){\n            const isNameForHCM = name.endsWith(\"_HCM\");\n            if (hasHCM && isNameForHCM) {\n                map.set(name.replace(\"_HCM\", \"\"), color);\n                continue;\n            }\n            if (!hasHCM && !isNameForHCM) {\n                map.set(name, color);\n            }\n        }\n        return shadow(this, \"highlightColors\", map);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    getNonHCMColor(color) {\n        if (!this._highlightColors) {\n            return color;\n        }\n        const colorName = this.highlightColorNames.get(color);\n        return this._highlightColors.get(colorName) || color;\n    }\n    getNonHCMColorName(color) {\n        return this.highlightColorNames.get(color) || color;\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    hasCommentManager() {\n        return !!this.#commentManager;\n    }\n    editComment(editor, posX, posY, options) {\n        this.#commentManager?.showDialog(this, editor, posX, posY, options);\n    }\n    selectComment(pageIndex, uid) {\n        const layer = this.#allLayers.get(pageIndex);\n        const editor = layer?.getEditorByUID(uid);\n        editor?.toggleComment(true, true);\n    }\n    updateComment(editor) {\n        this.#commentManager?.updateComment(editor.getData());\n    }\n    updatePopupColor(editor) {\n        this.#commentManager?.updatePopupColor(editor);\n    }\n    removeComment(editor) {\n        this.#commentManager?.removeComments([\n            editor.uid\n        ]);\n    }\n    toggleComment(editor, isSelected, visibility = undefined) {\n        this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);\n    }\n    makeCommentColor(color, opacity) {\n        return color && this.#commentManager?.makeCommentColor(color, opacity) || null;\n    }\n    getCommentDialogElement() {\n        return this.#commentManager?.dialogElement || null;\n    }\n    async waitForEditorsRendered(pageNumber) {\n        if (this.#allLayers.has(pageNumber - 1)) {\n            return;\n        }\n        const { resolve, promise } = Promise.withResolvers();\n        const onEditorsRendered = (evt)=>{\n            if (evt.pageNumber === pageNumber) {\n                this._eventBus._off(\"editorsrendered\", onEditorsRendered);\n                resolve();\n            }\n        };\n        this._eventBus.on(\"editorsrendered\", onEditorsRendered);\n        await promise;\n    }\n    getSignature(editor) {\n        this.#signatureManager?.getSignature({\n            uiManager: this,\n            editor\n        });\n    }\n    get signatureManager() {\n        return this.#signatureManager;\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\", comment = false) {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            const editor = layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n            if (comment) {\n                editor?.editComment();\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    commentSelection(methodOfCreation = \"\") {\n        this.highlightSelection(methodOfCreation, true);\n    }\n    #displayFloatingToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#floatingToolbar ||= new FloatingToolbar(this);\n        this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    getAndRemoveDataFromAnnotationStorage(annotationId) {\n        if (!this.#annotationStorage) {\n            return null;\n        }\n        const key = `${AnnotationEditorPrefix}${annotationId}`;\n        const storedValue = this.#annotationStorage.getRawValue(key);\n        if (storedValue) {\n            this.#annotationStorage.remove(key);\n        }\n        return storedValue;\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    a11yAlert(messageId, args = null) {\n        const viewerAlert = this.#viewerAlert;\n        if (!viewerAlert) {\n            return;\n        }\n        viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n        if (args) {\n            viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n        } else {\n            viewerAlert.removeAttribute(\"data-l10n-args\");\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            if (this.#isPointerDown) {\n                const ac = new AbortController();\n                const signal = this.combinedSignal(ac);\n                const pointerup = (e)=>{\n                    if (e.type === \"pointerup\" && e.button !== 0) {\n                        return;\n                    }\n                    ac.abort();\n                    activeLayer?.toggleDrawing(true);\n                    if (e.type === \"pointerup\") {\n                        this.#onSelectEnd(\"main_toolbar\");\n                    }\n                };\n                window.addEventListener(\"pointerup\", pointerup, {\n                    signal\n                });\n                window.addEventListener(\"blur\", pointerup, {\n                    signal\n                });\n            } else {\n                activeLayer?.toggleDrawing(true);\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayFloatingToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n            case \"commentSelection\":\n                this.commentSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#currentDrawingSession?.commitOrRemove();\n        if (this.#mode === AnnotationEditorType.POPUP) {\n            this.#commentManager?.hideSidebar();\n        }\n        this.#commentManager?.destroyPopup();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            for (const editor of this.#allEditors.values()){\n                editor.hideStandaloneCommentButton();\n            }\n            this._editorUndoBar?.hide();\n            this.toggleComment(null);\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            editor.addStandaloneCommentButton();\n        }\n        if (mode === AnnotationEditorType.SIGNATURE) {\n            await this.#signatureManager?.loadSignatures();\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (mode === AnnotationEditorType.POPUP) {\n            this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass)=>editorClass._editorType)));\n            const elementIds = new Set();\n            const allComments = [];\n            for (const editor of this.#allEditors.values()){\n                const { annotationElementId, hasComment, deleted } = editor;\n                if (annotationElementId) {\n                    elementIds.add(annotationElementId);\n                }\n                if (hasComment && !deleted) {\n                    allComments.push(editor.getData());\n                }\n            }\n            for (const annotation of this.#allEditableAnnotations){\n                const { id, popupRef, contentsObj } = annotation;\n                if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {\n                    allComments.push(annotation);\n                }\n            }\n            this.#commentManager?.showSidebar(allComments);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.uid === editId) {\n                this.setSelected(editor);\n                if (editComment) {\n                    editor.editComment();\n                } else if (mustEnterInEditMode) {\n                    editor.enterInEditMode();\n                } else {\n                    editor.focus();\n                }\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(options) {\n        if (options.mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            ...options\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor(value);\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        if (this.hasSelection) {\n            for (const editor of this.#selectedEditors){\n                editor.updateParams(type, value);\n            }\n        } else {\n            for (const editorType of this.#editorTypes){\n                editorType.updateDefaultParams(type, value);\n            }\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    *getEditors(pageIndex) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                yield editor;\n            }\n        }\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        if (editor.annotationElementId) {\n            this.#missingCanvases?.delete(editor.annotationElementId);\n        }\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.updateToolbar({\n            mode: editor.mode,\n            editId: editor.id\n        });\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n            editor.translationDone();\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    isEditingMode() {\n        return this.#mode !== AnnotationEditorType.NONE;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n    setMissingCanvas(annotationId, annotationElementId, canvas) {\n        const editor = this.#missingCanvases?.get(annotationId);\n        if (!editor) {\n            return;\n        }\n        editor.setCanvas(annotationElementId, canvas);\n        this.#missingCanvases.delete(annotationId);\n    }\n    addMissingCanvas(annotationId, editor) {\n        (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getElementForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/editor/comment.js\nclass Comment {\n    #commentStandaloneButton;\n    #commentToolbarButton;\n    #commentWasFromKeyBoard;\n    #editor;\n    #initialText;\n    #richText;\n    #text;\n    #date;\n    #deleted;\n    #popupPosition;\n    constructor(editor){\n        this.#commentStandaloneButton = null;\n        this.#commentToolbarButton = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#editor = null;\n        this.#initialText = null;\n        this.#richText = null;\n        this.#text = null;\n        this.#date = null;\n        this.#deleted = false;\n        this.#popupPosition = null;\n        this.#editor = editor;\n    }\n    renderForToolbar() {\n        const button = this.#commentToolbarButton = document.createElement(\"button\");\n        button.className = \"comment\";\n        return this.#render(button, false);\n    }\n    renderForStandalone() {\n        const button = this.#commentStandaloneButton = document.createElement(\"button\");\n        button.className = \"annotationCommentButton\";\n        const position = this.#editor.commentButtonPosition;\n        if (position) {\n            const { style } = button;\n            style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;\n            style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;\n            const color = this.#editor.commentButtonColor;\n            if (color) {\n                style.backgroundColor = color;\n            }\n        }\n        return this.#render(button, true);\n    }\n    focusButton() {\n        setTimeout(()=>{\n            (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();\n        }, 0);\n    }\n    onUpdatedColor() {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        const color = this.#editor.commentButtonColor;\n        if (color) {\n            this.#commentStandaloneButton.style.backgroundColor = color;\n        }\n        this.#editor._uiManager.updatePopupColor(this.#editor);\n    }\n    get commentButtonWidth() {\n        return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;\n    }\n    get commentPopupPositionInLayer() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        if (!this.#commentStandaloneButton) {\n            return null;\n        }\n        const { x, y, height } = this.#commentStandaloneButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#editor.parent.boundingClientRect;\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPositionInLayer(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    removeStandaloneCommentButton() {\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n    }\n    removeToolbarCommentButton() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        this.#commentStandaloneButton.classList.toggle(\"selected\", selected);\n        this.#commentStandaloneButton.ariaExpanded = hasPopup;\n    }\n    #render(comment, isStandalone) {\n        if (!this.#editor._uiManager.hasCommentManager()) {\n            return null;\n        }\n        comment.tabIndex = \"0\";\n        comment.ariaHasPopup = \"dialog\";\n        if (isStandalone) {\n            comment.ariaControls = \"commentPopup\";\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n        } else {\n            comment.ariaControlsElements = [\n                this.#editor._uiManager.getCommentDialogElement()\n            ];\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-edit-comment-button\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return comment;\n        }\n        comment.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        if (isStandalone) {\n            comment.addEventListener(\"focusin\", (e)=>{\n                this.#editor._focusEventsAllowed = false;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n            comment.addEventListener(\"focusout\", (e)=>{\n                this.#editor._focusEventsAllowed = true;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n        }\n        comment.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            if (comment === this.#commentToolbarButton) {\n                this.edit();\n            } else {\n                this.#editor.toggleComment(true);\n            }\n        };\n        comment.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        comment.addEventListener(\"keydown\", (event)=>{\n            if (event.target === comment && event.key === \"Enter\") {\n                this.#commentWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerenter\", ()=>{\n            this.#editor.toggleComment(false, true);\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerleave\", ()=>{\n            this.#editor.toggleComment(false, false);\n        }, {\n            signal\n        });\n        return comment;\n    }\n    edit(options) {\n        const position = this.commentPopupPositionInLayer;\n        let posX, posY;\n        if (position) {\n            [posX, posY] = position;\n        } else {\n            [posX, posY] = this.#editor.commentButtonPosition;\n            const { width, height, x, y } = this.#editor;\n            posX = x + posX * width;\n            posY = y + posY * height;\n        }\n        const parentDimensions = this.#editor.parent.boundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    finish() {\n        if (!this.#commentToolbarButton) {\n            return;\n        }\n        this.#commentToolbarButton.focus({\n            focusVisible: this.#commentWasFromKeyBoard\n        });\n        this.#commentWasFromKeyBoard = false;\n    }\n    isDeleted() {\n        return this.#deleted || this.#text === \"\";\n    }\n    isEmpty() {\n        return this.#text === null;\n    }\n    hasBeenEdited() {\n        return this.isDeleted() || this.#text !== this.#initialText;\n    }\n    serialize() {\n        return this.data;\n    }\n    get data() {\n        return {\n            text: this.#text,\n            richText: this.#richText,\n            date: this.#date,\n            deleted: this.isDeleted()\n        };\n    }\n    set data(text) {\n        if (text !== this.#text) {\n            this.#richText = null;\n        }\n        if (text === null) {\n            this.#text = \"\";\n            this.#deleted = true;\n            return;\n        }\n        this.#text = text;\n        this.#date = new Date();\n        this.#deleted = false;\n    }\n    setInitialText(text, richText = null) {\n        this.#initialText = text;\n        this.data = text;\n        this.#date = null;\n        this.#richText = richText;\n    }\n    shown() {}\n    destroy() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n        this.#text = \"\";\n        this.#richText = null;\n        this.#date = null;\n        this.#editor = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#deleted = false;\n    }\n}\n; // ./src/display/touch_manager.js\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #pointerDownAC;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#pointerDownAC = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return 35 / OutputScale.pixelRatio;\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.()) {\n            return;\n        }\n        if (evt.touches.length === 1) {\n            if (this.#pointerDownAC) {\n                return;\n            }\n            const pointerDownAC = this.#pointerDownAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                pointerDownAC.signal\n            ]);\n            const container = this.#container;\n            const opts = {\n                capture: true,\n                signal,\n                passive: false\n            };\n            const cancelPointerDown = (e)=>{\n                if (e.pointerType === \"touch\") {\n                    this.#pointerDownAC?.abort();\n                    this.#pointerDownAC = null;\n                }\n            };\n            container.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === \"touch\") {\n                    stopEvent(e);\n                    cancelPointerDown(e);\n                }\n            }, opts);\n            container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n            container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                capture: false,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            const onTouchEnd = this.#onTouchEnd.bind(this);\n            container.addEventListener(\"touchend\", onTouchEnd, opt);\n            container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n            opt.capture = true;\n            container.addEventListener(\"pointerdown\", stopEvent, opt);\n            container.addEventListener(\"pointermove\", stopEvent, opt);\n            container.addEventListener(\"pointercancel\", stopEvent, opt);\n            container.addEventListener(\"pointerup\", stopEvent, opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        stopEvent(evt);\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        if (evt.touches.length >= 2) {\n            return;\n        }\n        if (this.#touchMoveAC) {\n            this.#touchMoveAC.abort();\n            this.#touchMoveAC = null;\n            this.#onPinchEnd?.();\n        }\n        if (!this.#touchInfo) {\n            return;\n        }\n        stopEvent(evt);\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n        this.#pointerDownAC?.abort();\n        this.#pointerDownAC = null;\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #comment;\n    #commentStandaloneButton;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #fakeAnnotation;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentStandaloneButton = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#fakeAnnotation = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this.isSelected = false;\n        this._isCopy = false;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        this.annotationElementId = parameters.annotationElementId || null;\n        this.creationDate = parameters.creationDate || new Date();\n        this.modificationDate = parameters.modificationDate || null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    get mode() {\n        return Object.getPrototypeOf(this).constructor._editorType;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get uid() {\n        return this.annotationElementId || this.id;\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n            this.#fakeAnnotation?.remove();\n            this.#fakeAnnotation = null;\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    _moveAfterPaste(baseX, baseY) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        this._onTranslated();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    translationDone() {\n        this._onTranslated(this.x, this.y);\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = MathClamp(x, 0, pageWidth - width);\n                    y = MathClamp(y, 0, pageHeight - height);\n                    break;\n                case 90:\n                    x = MathClamp(x, 0, pageWidth - height);\n                    y = MathClamp(y, width, pageHeight);\n                    break;\n                case 180:\n                    x = MathClamp(x, width, pageWidth);\n                    y = MathClamp(y, height, pageHeight);\n                    break;\n                case 270:\n                    x = MathClamp(x, height, pageWidth);\n                    y = MathClamp(y, 0, pageHeight - width);\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims() {\n        const { div: { style }, width, height } = this;\n        style.width = `${(100 * width).toFixed(2)}%`;\n        style.height = `${(100 * height).toFixed(2)}%`;\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 10000) / 10000;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n        } else {\n            ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    get toolbarButtons() {\n        return null;\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        const { toolbarButtons } = this;\n        if (toolbarButtons) {\n            for (const [name, tool] of toolbarButtons){\n                await this._editToolbar.addButton(name, tool);\n            }\n        }\n        if (!this.hasComment) {\n            this._editToolbar.addButton(\"comment\", this.addCommentButton());\n        }\n        this._editToolbar.addButton(\"delete\");\n        return this._editToolbar;\n    }\n    addCommentButtonInToolbar() {\n        this._editToolbar?.addButtonBefore(\"comment\", this.addCommentButton(), \".deleteButton\");\n    }\n    removeCommentButtonFromToolbar() {\n        this._editToolbar?.removeButton(\"comment\");\n    }\n    removeEditToolbar() {\n        this._editToolbar?.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    createAltText() {\n        if (!this.#altText) {\n            AltText.initialize(AnnotationEditor._l10n);\n            this.#altText = new AltText(this);\n            if (this.#accessibilityData) {\n                this.#altText.data = this.#accessibilityData;\n                this.#accessibilityData = null;\n            }\n        }\n        return this.#altText;\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    focusCommentButton() {\n        this.#comment?.focusButton();\n    }\n    addCommentButton() {\n        return this.#comment ||= new Comment(this);\n    }\n    addStandaloneCommentButton() {\n        if (this.#commentStandaloneButton) {\n            if (this._uiManager.isEditingMode()) {\n                this.#commentStandaloneButton.classList.remove(\"hidden\");\n            }\n            return;\n        }\n        if (!this.hasComment) {\n            return;\n        }\n        this.#commentStandaloneButton = this.#comment.renderForStandalone();\n        this.div.append(this.#commentStandaloneButton);\n    }\n    removeStandaloneCommentButton() {\n        this.#comment.removeStandaloneCommentButton();\n        this.#commentStandaloneButton = null;\n    }\n    hideStandaloneCommentButton() {\n        this.#commentStandaloneButton?.classList.add(\"hidden\");\n    }\n    get comment() {\n        const { data: { richText, text, date, deleted } } = this.#comment;\n        return {\n            text,\n            richText,\n            date,\n            deleted,\n            color: this.getNonHCMColor(),\n            opacity: this.opacity ?? 1\n        };\n    }\n    set comment(text) {\n        this.#comment ||= new Comment(this);\n        this.#comment.data = text;\n        if (this.hasComment) {\n            this.removeCommentButtonFromToolbar();\n            this.addStandaloneCommentButton();\n            this._uiManager.updateComment(this);\n        } else {\n            this.addCommentButtonInToolbar();\n            this.removeStandaloneCommentButton();\n            this._uiManager.removeComment(this);\n        }\n    }\n    setCommentData({ comment, popupRef, richText }) {\n        if (!popupRef) {\n            return;\n        }\n        this.#comment ||= new Comment(this);\n        this.#comment.setInitialText(comment, richText);\n        if (!this.annotationElementId) {\n            return;\n        }\n        const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);\n        if (storedData) {\n            this.updateFromAnnotationLayer(storedData);\n        }\n    }\n    get hasEditedComment() {\n        return this.#comment?.hasBeenEdited();\n    }\n    get hasDeletedComment() {\n        return this.#comment?.isDeleted();\n    }\n    get hasComment() {\n        return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();\n    }\n    async editComment(options) {\n        this.#comment ||= new Comment(this);\n        this.#comment.edit(options);\n    }\n    toggleComment(isSelected, visibility = undefined) {\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, isSelected, visibility);\n        }\n    }\n    setSelectedCommentButton(selected) {\n        this.#comment.setSelectedButton(selected);\n    }\n    addComment(serialized) {\n        if (this.hasEditedComment) {\n            const DEFAULT_POPUP_WIDTH = 180;\n            const DEFAULT_POPUP_HEIGHT = 100;\n            const [, , , trY] = serialized.rect;\n            const [pageWidth] = this.pageDimensions;\n            const [pageX] = this.pageTranslation;\n            const blX = pageX + pageWidth + 1;\n            const blY = trY - DEFAULT_POPUP_HEIGHT;\n            const trX = blX + DEFAULT_POPUP_WIDTH;\n            serialized.popup = {\n                contents: this.comment.text,\n                deleted: this.comment.deleted,\n                rect: [\n                    blX,\n                    blY,\n                    trX,\n                    trY\n                ]\n            };\n        }\n    }\n    updateFromAnnotationLayer({ popup: { contents, deleted } }) {\n        this.#comment.data = deleted ? null : contents;\n    }\n    get parentBoundingClientRect() {\n        return this.parent.boundingClientRect;\n    }\n    render() {\n        const div = this.div = document.createElement(\"div\");\n        div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        div.className = this.name;\n        div.setAttribute(\"id\", this.id);\n        div.tabIndex = this.#disabled ? -1 : 0;\n        div.setAttribute(\"role\", \"application\");\n        if (this.defaultL10nId) {\n            div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n        }\n        if (!this._isVisible) {\n            div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, div, [\n            \"keydown\",\n            \"pointerdown\",\n            \"dblclick\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this.addStandaloneCommentButton();\n        this._uiManager._editorUndoBar?.hide();\n        return div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._uiManager.toggleComment(this, true, false);\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getPDFRect() {\n        return this.getRect(0, 0);\n    }\n    getNonHCMColor() {\n        return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n    }\n    onUpdatedColor() {\n        this.#comment?.onUpdatedColor();\n    }\n    getData() {\n        const { comment: { text: str, color, date, opacity, deleted, richText }, uid: id, pageIndex, creationDate, modificationDate } = this;\n        return {\n            id,\n            pageIndex,\n            rect: this.getPDFRect(),\n            richText,\n            contentsObj: {\n                str\n            },\n            creationDate,\n            modificationDate: date || modificationDate,\n            popupRef: !deleted,\n            color,\n            opacity\n        };\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(false);\n        this.#isInEditMode = true;\n        return true;\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(true);\n        this.#isInEditMode = false;\n        return true;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        return {\n            annotationType: this.mode,\n            pageIndex: this.pageIndex,\n            rect: this.getPDFRect(),\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager,\n            annotationElementId: data.annotationElementId,\n            creationDate: data.creationDate,\n            modificationDate: data.modificationDate\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        editor._isCopy = data.isCopy || false;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    get commentButtonPosition() {\n        return this._uiManager.direction === \"ltr\" ? [\n            1,\n            0\n        ] : [\n            0,\n            0\n        ];\n    }\n    get commentButtonPositionInPage() {\n        const { commentButtonPosition: [posX, posY] } = this;\n        const [blX, blY, trX, trY] = this.getPDFRect();\n        return [\n            AnnotationEditor._round(blX + (trX - blX) * posX),\n            AnnotationEditor._round(blY + (trY - blY) * (1 - posY))\n        ];\n    }\n    get commentButtonColor() {\n        return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);\n    }\n    get commentPopupPosition() {\n        return this.#comment.commentPopupPositionInLayer;\n    }\n    set commentPopupPosition(pos) {\n        this.#comment.commentPopupPositionInLayer = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#comment.hasDefaultPopupPosition();\n    }\n    get commentButtonWidth() {\n        return this.#comment.commentButtonWidth;\n    }\n    get elementBeforePopup() {\n        return this.div;\n    }\n    setCommentButtonStates(options) {\n        this.#comment.setCommentButtonStates(options);\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        if (this.isSelected && this._editToolbar) {\n            this._editToolbar.show();\n            return;\n        }\n        this.isSelected = true;\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    focus() {\n        if (this.div && !this.div.contains(document.activeElement)) {\n            setTimeout(()=>this.div?.focus({\n                    preventScroll: true\n                }), 0);\n        }\n    }\n    unselect() {\n        if (!this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, false, false);\n        }\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    get canChangeContent() {\n        return false;\n    }\n    enterInEditMode() {\n        if (!this.canChangeContent) {\n            return;\n        }\n        this.enableEditMode();\n        this.div.focus();\n    }\n    dblclick(event) {\n        if (event.target.nodeName === \"BUTTON\") {\n            return;\n        }\n        this.enterInEditMode();\n        this.parent.updateToolbar({\n            mode: this.constructor._editorType,\n            editId: this.id\n        });\n    }\n    getElementForAltText() {\n        return this.div;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    updateFakeAnnotationElement(annotationLayer) {\n        if (!this.#fakeAnnotation && !this.deleted) {\n            this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);\n            return;\n        }\n        if (this.deleted) {\n            this.#fakeAnnotation.remove();\n            this.#fakeAnnotation = null;\n            return;\n        }\n        if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {\n            this.#fakeAnnotation.updateEdited({\n                rect: this.getPDFRect(),\n                popup: this.comment\n            });\n        }\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #editorsMap;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#editorsMap = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        const storedValue = this.#storage.get(key);\n        if (storedValue === undefined) {\n            return;\n        }\n        if (storedValue instanceof AnnotationEditor) {\n            this.#editorsMap.delete(storedValue.annotationElementId);\n        }\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor) {\n            (this.#editorsMap ||= new Map()).set(value.annotationElementId, value);\n            if (typeof this.onAnnotationEditor === \"function\") {\n                this.onAnnotationEditor(value.constructor._type);\n            }\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        let numberOfEditedComments = 0;\n        let numberOfDeletedComments = 0;\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                if (value.popup) {\n                    if (value.popup.deleted) {\n                        numberOfDeletedComments += 1;\n                    } else {\n                        numberOfEditedComments += 1;\n                    }\n                }\n                continue;\n            }\n            if (value.isCommentDeleted) {\n                numberOfDeletedComments += 1;\n            } else if (value.hasEditedComment) {\n                numberOfEditedComments += 1;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {\n            stats ||= Object.create(null);\n            stats.comments = {\n                deleted: numberOfDeletedComments,\n                edited: numberOfEditedComments\n            };\n        }\n        if (!stats) {\n            return null;\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    updateEditor(annotationId, data) {\n        const value = this.#editorsMap?.get(annotationId);\n        if (value) {\n            value.updateFromAnnotationLayer(data);\n            return true;\n        }\n        return false;\n    }\n    getEditor(annotationId) {\n        return this.#editorsMap?.get(annotationId) || null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        if (this.#editorsMap) {\n            for (const value of this.#editorsMap.values()){\n                if (!value.serialize()) {\n                    continue;\n                }\n                ids.push(value.annotationElementId);\n            }\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n    [Symbol.iterator]() {\n        return this.#storage.entries();\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, disableFontFace, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    #fontData;\n    constructor(translatedData, inspectFont = null, extra, charProcOperatorList){\n        this.compiledGlyphs = Object.create(null);\n        this.#fontData = translatedData;\n        this._inspectFont = inspectFont;\n        if (extra) {\n            Object.assign(this, extra);\n        }\n        if (charProcOperatorList) {\n            this.charProcOperatorList = charProcOperatorList;\n        }\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n    get black() {\n        return this.#fontData.black;\n    }\n    get bold() {\n        return this.#fontData.bold;\n    }\n    get disableFontFace() {\n        return this.#fontData.disableFontFace ?? false;\n    }\n    get fontExtraProperties() {\n        return this.#fontData.fontExtraProperties ?? false;\n    }\n    get isInvalidPDFjsFont() {\n        return this.#fontData.isInvalidPDFjsFont;\n    }\n    get isType3Font() {\n        return this.#fontData.isType3Font;\n    }\n    get italic() {\n        return this.#fontData.italic;\n    }\n    get missingFile() {\n        return this.#fontData.missingFile;\n    }\n    get remeasure() {\n        return this.#fontData.remeasure;\n    }\n    get vertical() {\n        return this.#fontData.vertical;\n    }\n    get ascent() {\n        return this.#fontData.ascent;\n    }\n    get defaultWidth() {\n        return this.#fontData.defaultWidth;\n    }\n    get descent() {\n        return this.#fontData.descent;\n    }\n    get bbox() {\n        return this.#fontData.bbox;\n    }\n    get fontMatrix() {\n        return this.#fontData.fontMatrix;\n    }\n    get fallbackName() {\n        return this.#fontData.fallbackName;\n    }\n    get loadedName() {\n        return this.#fontData.loadedName;\n    }\n    get mimetype() {\n        return this.#fontData.mimetype;\n    }\n    get name() {\n        return this.#fontData.name;\n    }\n    get data() {\n        return this.#fontData.data;\n    }\n    clearData() {\n        this.#fontData.clearData();\n    }\n    get cssFontInfo() {\n        return this.#fontData.cssFontInfo;\n    }\n    get systemFontInfo() {\n        return this.#fontData.systemFontInfo;\n    }\n    get defaultVMetrics() {\n        return this.#fontData.defaultVMetrics;\n    }\n}\n; // ./src/display/api_utils.js\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    if (typeof val === \"string\") {\n        if (isNodeJS) {\n            return val;\n        }\n        const url = URL.parse(val, window.location);\n        if (url) {\n            return url.href;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    if (val.endsWith(\"/\")) {\n        return val;\n    }\n    throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = (v)=>typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = (v)=>typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"ResponseException\":\n            return new ResponseException(ex.message, ex.status, ex.missing);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self1 = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self1.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.filter.js\nvar es_iterator_filter = __nested_webpack_require_216482__(2489);\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = updateUrlHash(url, \"\");\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/wasm_factory.js\nclass BaseWasmFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Wasm filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load wasm data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    let canvas;\n    try {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///C:/Users/Emmanuel/Desktop/Expense%20Tracker/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n        try {\n            canvas = require(\"@napi-rs/canvas\");\n        } catch (ex) {\n            warn(`Cannot load \"@napi-rs/canvas\" package: \"${ex}\".`);\n        }\n    } catch (ex) {\n        warn(`Cannot access the \\`require\\` function: \"${ex}\".`);\n    }\n    if (!globalThis.DOMMatrix) {\n        if (canvas?.DOMMatrix) {\n            globalThis.DOMMatrix = canvas.DOMMatrix;\n        } else {\n            warn(\"Cannot polyfill `DOMMatrix`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.ImageData) {\n        if (canvas?.ImageData) {\n            globalThis.ImageData = canvas.ImageData;\n        } else {\n            warn(\"Cannot polyfill `ImageData`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.Path2D) {\n        if (canvas?.Path2D) {\n            globalThis.Path2D = canvas.Path2D;\n        } else {\n            warn(\"Cannot polyfill `Path2D`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.navigator?.language) {\n        globalThis.navigator = {\n            language: \"en-US\",\n            platform: \"\",\n            userAgent: \"\"\n        };\n    }\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///C:/Users/Emmanuel/Desktop/Expense%20Tracker/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.for-each.js\nvar es_iterator_for_each = __nested_webpack_require_216482__(7588);\n; // ./src/display/canvas_dependency_tracker.js\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nconst { floor, ceil } = Math;\nfunction expandBBox(array, index, minX, minY, maxX, maxY) {\n    array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);\n    array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);\n    array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);\n    array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);\n}\nconst EMPTY_BBOX = new Uint32Array(new Uint8Array([\n    255,\n    255,\n    0,\n    0\n]).buffer)[0];\nclass BBoxReader {\n    #bboxes;\n    #coords;\n    constructor(bboxes, coords){\n        this.#bboxes = bboxes;\n        this.#coords = coords;\n    }\n    get length() {\n        return this.#bboxes.length;\n    }\n    isEmpty(i) {\n        return this.#bboxes[i] === EMPTY_BBOX;\n    }\n    minX(i) {\n        return this.#coords[i * 4 + 0] / 256;\n    }\n    minY(i) {\n        return this.#coords[i * 4 + 1] / 256;\n    }\n    maxX(i) {\n        return (this.#coords[i * 4 + 2] + 1) / 256;\n    }\n    maxY(i) {\n        return (this.#coords[i * 4 + 3] + 1) / 256;\n    }\n}\nconst ensureDebugMetadata = (map, key)=>{\n    if (!map) {\n        return undefined;\n    }\n    let value = map.get(key);\n    if (!value) {\n        value = {\n            dependencies: new Set(),\n            isRenderingOperation: false\n        };\n        map.set(key, value);\n    }\n    return value;\n};\nclass CanvasDependencyTracker {\n    #simple;\n    #incremental;\n    #namedDependencies;\n    #savesStack;\n    #markedContentStack;\n    #baseTransformStack;\n    #clipBox;\n    #pendingBBox;\n    #pendingBBoxIdx;\n    #pendingDependencies;\n    #operations;\n    #fontBBoxTrustworthy;\n    #canvasWidth;\n    #canvasHeight;\n    #bboxesCoords;\n    #bboxes;\n    #debugMetadata;\n    constructor(canvas, operationsCount, recordDebugMetadata = false){\n        this.#simple = {\n            __proto__: null\n        };\n        this.#incremental = {\n            __proto__: null,\n            transform: [],\n            moveText: [],\n            sameLineText: [],\n            [FORCED_DEPENDENCY_LABEL]: []\n        };\n        this.#namedDependencies = new Map();\n        this.#savesStack = [];\n        this.#markedContentStack = [];\n        this.#baseTransformStack = [\n            [\n                1,\n                0,\n                0,\n                1,\n                0,\n                0\n            ]\n        ];\n        this.#clipBox = [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity\n        ];\n        this.#pendingBBox = new Float64Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        this.#pendingBBoxIdx = -1;\n        this.#pendingDependencies = new Set();\n        this.#operations = new Map();\n        this.#fontBBoxTrustworthy = new Map();\n        this.#canvasWidth = canvas.width;\n        this.#canvasHeight = canvas.height;\n        this.#initializeBBoxes(operationsCount);\n        if (recordDebugMetadata) {\n            this.#debugMetadata = new Map();\n        }\n    }\n    growOperationsCount(operationsCount) {\n        if (operationsCount >= this.#bboxes.length) {\n            this.#initializeBBoxes(operationsCount, this.#bboxes);\n        }\n    }\n    #initializeBBoxes(operationsCount, oldBBoxes) {\n        const buffer = new ArrayBuffer(operationsCount * 4);\n        this.#bboxesCoords = new Uint8ClampedArray(buffer);\n        this.#bboxes = new Uint32Array(buffer);\n        if (oldBBoxes && oldBBoxes.length > 0) {\n            this.#bboxes.set(oldBBoxes);\n            this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);\n        } else {\n            this.#bboxes.fill(EMPTY_BBOX);\n        }\n    }\n    save(opIdx) {\n        this.#simple = {\n            __proto__: this.#simple\n        };\n        this.#incremental = {\n            __proto__: this.#incremental,\n            transform: {\n                __proto__: this.#incremental.transform\n            },\n            moveText: {\n                __proto__: this.#incremental.moveText\n            },\n            sameLineText: {\n                __proto__: this.#incremental.sameLineText\n            },\n            [FORCED_DEPENDENCY_LABEL]: {\n                __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n            }\n        };\n        this.#clipBox = {\n            __proto__: this.#clipBox\n        };\n        this.#savesStack.push(opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        const previous = Object.getPrototypeOf(this.#simple);\n        if (previous === null) {\n            return this;\n        }\n        this.#simple = previous;\n        this.#incremental = Object.getPrototypeOf(this.#incremental);\n        this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#savesStack.push(idx);\n        return this;\n    }\n    getOpenMarker() {\n        if (this.#savesStack.length === 0) {\n            return null;\n        }\n        return this.#savesStack.at(-1);\n    }\n    recordCloseMarker(opIdx) {\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        this.#markedContentStack.push(opIdx);\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        const lastSave = this.#markedContentStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n        return this;\n    }\n    popBaseTransform() {\n        if (this.#baseTransformStack.length > 1) {\n            this.#baseTransformStack.pop();\n        }\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#simple[name] = idx;\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#incremental[name].push(idx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#incremental[name].length = 0;\n        return this;\n    }\n    recordNamedData(name, idx) {\n        this.#namedDependencies.set(name, idx);\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        for (const name of names){\n            if (name in this.#simple) {\n                this.recordFutureForcedDependency(name, this.#simple[name]);\n            }\n        }\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        for (const dep of this.#pendingDependencies){\n            this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n        }\n        return this;\n    }\n    resetBBox(idx) {\n        if (this.#pendingBBoxIdx !== idx) {\n            this.#pendingBBoxIdx = idx;\n            this.#pendingBBox[0] = Infinity;\n            this.#pendingBBox[1] = Infinity;\n            this.#pendingBBox[2] = -Infinity;\n            this.#pendingBBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        const clipBox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, clipBox);\n        const intersection = Util.intersect(this.#clipBox, clipBox);\n        if (intersection) {\n            this.#clipBox[0] = intersection[0];\n            this.#clipBox[1] = intersection[1];\n            this.#clipBox[2] = intersection[2];\n            this.#clipBox[3] = intersection[3];\n        } else {\n            this.#clipBox[0] = this.#clipBox[1] = Infinity;\n            this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        const clipBox = this.#clipBox;\n        if (clipBox[0] === Infinity) {\n            return this;\n        }\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        if (clipBox[0] === -Infinity) {\n            Util.axialAlignedBoundingBox([\n                minX,\n                minY,\n                maxX,\n                maxY\n            ], transform, this.#pendingBBox);\n            return this;\n        }\n        const bbox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, bbox);\n        this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n        this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n        this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n        this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n        const fontBBox = font.bbox;\n        let isBBoxTrustworthy;\n        let computedBBox;\n        if (fontBBox) {\n            isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n            if (isBBoxTrustworthy !== false) {\n                computedBBox = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n                if (scale !== 1 || x !== 0 || y !== 0) {\n                    Util.scaleMinMax([\n                        scale,\n                        0,\n                        0,\n                        -scale,\n                        x,\n                        y\n                    ], computedBBox);\n                }\n                if (isBBoxTrustworthy) {\n                    return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n                }\n            }\n        }\n        if (!getMeasure) {\n            return this.recordFullPageBBox(idx);\n        }\n        const measure = getMeasure();\n        if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {\n            isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n            this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n            if (isBBoxTrustworthy) {\n                return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n            }\n        }\n        return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n    }\n    recordFullPageBBox(idx) {\n        this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n        this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n        this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n        this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#simple[dependencyName];\n    }\n    recordDependencies(idx, dependencyNames) {\n        const pendingDependencies = this.#pendingDependencies;\n        const simple = this.#simple;\n        const incremental = this.#incremental;\n        for (const name of dependencyNames){\n            if (name in this.#simple) {\n                pendingDependencies.add(simple[name]);\n            } else if (name in incremental) {\n                incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n            }\n        }\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        if (this.#namedDependencies.has(name)) {\n            this.#pendingDependencies.add(this.#namedDependencies.get(name));\n        }\n        return this;\n    }\n    recordOperation(idx, preserve = false) {\n        this.recordDependencies(idx, [\n            FORCED_DEPENDENCY_LABEL\n        ]);\n        if (this.#debugMetadata) {\n            const metadata = ensureDebugMetadata(this.#debugMetadata, idx);\n            const { dependencies } = metadata;\n            this.#pendingDependencies.forEach(dependencies.add, dependencies);\n            this.#savesStack.forEach(dependencies.add, dependencies);\n            this.#markedContentStack.forEach(dependencies.add, dependencies);\n            dependencies.delete(idx);\n            metadata.isRenderingOperation = true;\n        }\n        if (this.#pendingBBoxIdx === idx) {\n            const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);\n            const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);\n            const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);\n            const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);\n            expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);\n            for (const depIdx of this.#pendingDependencies){\n                if (depIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#savesStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#markedContentStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n                this.#pendingBBoxIdx = -1;\n            }\n        }\n        return this;\n    }\n    recordShowTextOperation(idx, preserve = false) {\n        const deps = Array.from(this.#pendingDependencies);\n        this.recordOperation(idx, preserve);\n        this.recordIncrementalData(\"sameLineText\", idx);\n        for (const dep of deps){\n            this.recordIncrementalData(\"sameLineText\", dep);\n        }\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx, preserve = false) {\n        if (this.#pendingBBoxIdx === idx) {\n            this.#pendingBBoxIdx = -1;\n            this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n            this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n            this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n            this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n            }\n        }\n        return this;\n    }\n    _takePendingDependencies() {\n        const pendingDependencies = this.#pendingDependencies;\n        this.#pendingDependencies = new Set();\n        return pendingDependencies;\n    }\n    _extractOperation(idx) {\n        const operation = this.#operations.get(idx);\n        this.#operations.delete(idx);\n        return operation;\n    }\n    _pushPendingDependencies(dependencies) {\n        for (const dep of dependencies){\n            this.#pendingDependencies.add(dep);\n        }\n    }\n    take() {\n        this.#fontBBoxTrustworthy.clear();\n        return new BBoxReader(this.#bboxes, this.#bboxesCoords);\n    }\n    takeDebugMetadata() {\n        return this.#debugMetadata;\n    }\n}\nclass CanvasNestedDependencyTracker {\n    #dependencyTracker;\n    #opIdx;\n    #ignoreBBoxes;\n    #nestingLevel;\n    #savesLevel;\n    constructor(dependencyTracker, opIdx, ignoreBBoxes){\n        this.#nestingLevel = 0;\n        this.#savesLevel = 0;\n        if (dependencyTracker instanceof CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {\n            return dependencyTracker;\n        }\n        this.#dependencyTracker = dependencyTracker;\n        this.#opIdx = opIdx;\n        this.#ignoreBBoxes = !!ignoreBBoxes;\n    }\n    growOperationsCount() {\n        throw new Error(\"Unreachable\");\n    }\n    save(opIdx) {\n        this.#savesLevel++;\n        this.#dependencyTracker.save(this.#opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        if (this.#savesLevel > 0) {\n            this.#dependencyTracker.restore(this.#opIdx);\n            this.#savesLevel--;\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#nestingLevel++;\n        return this;\n    }\n    getOpenMarker() {\n        return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n    }\n    recordCloseMarker(idx) {\n        this.#nestingLevel--;\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#dependencyTracker.pushBaseTransform(ctx);\n        return this;\n    }\n    popBaseTransform() {\n        this.#dependencyTracker.popBaseTransform();\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    recordNamedData(name, idx) {\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);\n        return this;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n        return this;\n    }\n    resetBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.resetBBox(this.#opIdx);\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n        }\n        return this;\n    }\n    recordFullPageBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n        }\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#dependencyTracker.getSimpleIndex(dependencyName);\n    }\n    recordDependencies(idx, dependencyNames) {\n        this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n        return this;\n    }\n    recordOperation(idx) {\n        this.#dependencyTracker.recordOperation(this.#opIdx, true);\n        return this;\n    }\n    recordShowTextOperation(idx) {\n        this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);\n        }\n        return this;\n    }\n    take() {\n        throw new Error(\"Unreachable\");\n    }\n    takeDebugMetadata() {\n        throw new Error(\"Unreachable\");\n    }\n}\nconst Dependencies = {\n    stroke: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"strokeColor\",\n        \"strokeAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"dash\"\n    ],\n    fill: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\",\n        \"globalCompositeOperation\",\n        \"SMask\"\n    ],\n    imageXObject: [\n        \"transform\",\n        \"SMask\",\n        \"filter\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\"\n    ],\n    rawFillPath: [\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\"\n    ],\n    showText: [\n        \"transform\",\n        \"leading\",\n        \"charSpacing\",\n        \"wordSpacing\",\n        \"hScale\",\n        \"textRise\",\n        \"moveText\",\n        \"textMatrix\",\n        \"font\",\n        \"fontObj\",\n        \"filter\",\n        \"fillColor\",\n        \"textRenderingMode\",\n        \"SMask\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\",\n        \"sameLineText\"\n    ],\n    transform: [\n        \"transform\"\n    ],\n    transformAndFill: [\n        \"transform\",\n        \"fillColor\"\n    ]\n};\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[6];\n        this._background = IR[7];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    isModifyingCurrentTransform() {\n        return true;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        const scale = new Float32Array(2);\n        if (pathType === PathType.SHADING) {\n            Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n        } else if (this.matrix) {\n            Util.singularValueDecompose2dScale(this.matrix, scale);\n            const [matrixScaleX, matrixScaleY] = scale;\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n            scale[0] *= matrixScaleX;\n            scale[1] *= matrixScaleY;\n        } else {\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, ctx, canvasGraphicsFactory, baseTransform){\n        this.color = IR[1];\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner, opIdx) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const scale = new Float32Array(2);\n        Util.singularValueDecompose2dScale(this.matrix, scale);\n        const [matrixScaleX, matrixScaleY] = scale;\n        Util.singularValueDecompose2dScale(this.baseTransform, scale);\n        const combinedScaleX = matrixScaleX * scale[0];\n        const combinedScaleY = matrixScaleY * scale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        graphics.dependencyTracker?.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        graphics.dependencyTracker?.restore();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        Util.axialAlignedBoundingBox([\n            x0,\n            y0,\n            x1,\n            y1\n        ], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const { fillStyle, strokeStyle } = this.ctx;\n                context.fillStyle = current.fillColor = fillStyle;\n                context.strokeStyle = current.strokeColor = strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                context.fillStyle = context.strokeStyle = color;\n                current.fillColor = current.strokeColor = color;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern(ctx, owner, inverse, pathType, opIdx) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([\n    Infinity,\n    Infinity,\n    -Infinity,\n    -Infinity\n]);\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nclass CanvasExtraState {\n    constructor(width, height, preInit){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = null;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        preInit?.(this);\n        this.clipBox = new Float32Array([\n            0,\n            0,\n            width,\n            height\n        ]);\n        this.minMax = MIN_MAX_INIT.slice();\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        clone.minMax = this.minMax.slice();\n        return clone;\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = this.minMax.slice();\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            Util.singularValueDecompose2dScale(transform, XY);\n            const xStrokePad = XY[0] * this.lineWidth / 2;\n            const yStrokePad = XY[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minMax[0] === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox.set(box, 0);\n        this.minMax.set(MIN_MAX_INIT, 0);\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    const { filter } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    Util.singularValueDecompose2dScale(transform, XY);\n    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors, dependencyTracker){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n        this.dependencyTracker = dependencyTracker ?? null;\n    }\n    getObject(opIdx, data, fallback = null) {\n        if (typeof data === \"string\") {\n            this.dependencyTracker?.recordNamedDependency(opIdx, data);\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId, fnArgs;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            if (!operationsFilter || operationsFilter(i)) {\n                fnId = fnArray[i];\n                fnArgs = argsArray[i] ?? null;\n                if (fnId !== OPS.dependency) {\n                    if (fnArgs === null) {\n                        this[fnId](i);\n                    } else {\n                        this[fnId](i, ...fnArgs);\n                    }\n                } else {\n                    for (const depObjId of fnArgs){\n                        this.dependencyTracker?.recordNamedData(depObjId, i);\n                        const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                        if (!objsPool.has(depObjId)) {\n                            objsPool.get(depObjId, continueCallback);\n                            return i;\n                        }\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(opIdx, img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const minMax = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas, minMax);\n        const [minX, minY, maxX, maxY] = minMax;\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(opIdx, width) {\n        this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(opIdx, limit) {\n        this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n        this.ctx.miterLimit = limit;\n    }\n    setDash(opIdx, dashArray, dashPhase) {\n        this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(opIdx, intent) {}\n    setFlatness(opIdx, flatness) {}\n    setGState(opIdx, states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(opIdx, value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(opIdx, value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(opIdx, value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(opIdx, value);\n                    break;\n                case \"D\":\n                    this.setDash(opIdx, value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(opIdx, value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(opIdx, value);\n                    break;\n                case \"Font\":\n                    this.setFont(opIdx, value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n                    this.ctx.globalAlpha = this.current.fillAlpha = value;\n                    break;\n                case \"BM\":\n                    this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode(opIdx) {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        const ctx = this.ctx = scratchCanvas.context;\n        ctx.setTransform(this.suspendedCtx.getTransform());\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdrop;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdrop;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save(opIdx) {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n        }\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n        this.dependencyTracker?.save(opIdx);\n    }\n    restore(opIdx) {\n        this.dependencyTracker?.restore(opIdx);\n        if (this.stateStack.length === 0) {\n            if (this.inSMaskMode) {\n                this.endSMaskMode();\n            }\n            return;\n        }\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        if (this.inSMaskMode) {\n            copyCtxState(this.suspendedCtx, this.ctx);\n        }\n        this.checkSMaskState();\n        this.pendingClip = null;\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    transform(opIdx, a, b, c, d, e, f) {\n        this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(opIdx, op, data, minMax) {\n        let [path] = data;\n        if (!minMax) {\n            path ||= data[0] = new Path2D();\n            this[op](opIdx, path);\n            return;\n        }\n        if (this.dependencyTracker !== null) {\n            const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n            this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\n                \"transform\"\n            ]);\n        }\n        if (!(path instanceof Path2D)) {\n            const path2d = data[0] = new Path2D();\n            for(let i = 0, ii = path.length; i < ii;){\n                switch(path[i++]){\n                    case DrawOPS.moveTo:\n                        path2d.moveTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.lineTo:\n                        path2d.lineTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.curveTo:\n                        path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n                        break;\n                    case DrawOPS.closePath:\n                        path2d.closePath();\n                        break;\n                    default:\n                        warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n                        break;\n                }\n            }\n            path = path2d;\n        }\n        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n        this[op](opIdx, path);\n        this._pathStartIdx = opIdx;\n    }\n    closePath(opIdx) {\n        this.ctx.closePath();\n    }\n    stroke(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n                if (baseTransform) {\n                    const newPath = new Path2D();\n                    newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                    path = newPath;\n                }\n                this.rescaleAndStroke(path, false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(path, true);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n        if (consumePath) {\n            this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke(opIdx, path) {\n        this.stroke(opIdx, path);\n    }\n    fill(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n            this.dependencyTracker?.save(opIdx);\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            if (baseTransform) {\n                const newPath = new Path2D();\n                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                path = newPath;\n            }\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(path, \"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill(path);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n        if (needRestore) {\n            ctx.restore();\n            this.dependencyTracker?.restore(opIdx);\n        }\n        if (consumePath) {\n            this.consumePath(opIdx, path, intersect);\n        }\n    }\n    eoFill(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fill(opIdx, path);\n    }\n    fillStroke(opIdx, path) {\n        this.fill(opIdx, path, false);\n        this.stroke(opIdx, path, false);\n        this.consumePath(opIdx, path);\n    }\n    eoFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    closeFillStroke(opIdx, path) {\n        this.fillStroke(opIdx, path);\n    }\n    closeEOFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    endPath(opIdx, path) {\n        this.consumePath(opIdx, path);\n    }\n    rawFillPath(opIdx, path) {\n        this.ctx.fill(path);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n    }\n    clip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = EO_CLIP;\n    }\n    beginText(opIdx) {\n        this.current.textMatrix = null;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n        this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n    }\n    endText(opIdx) {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (this.dependencyTracker) {\n            const { dependencyTracker } = this;\n            if (paths !== undefined) {\n                dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n            }\n            dependencyTracker.recordCloseMarker(opIdx);\n        }\n        if (paths !== undefined) {\n            const newPath = new Path2D();\n            const invTransf = ctx.getTransform().invertSelf();\n            for (const { transform, x, y, fontSize, path } of paths){\n                if (!path) {\n                    continue;\n                }\n                newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n            }\n            ctx.clip(newPath);\n        }\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(opIdx, scale) {\n        this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(opIdx, leading) {\n        this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n        this.current.leading = -leading;\n    }\n    setFont(opIdx, fontRefName, size) {\n        this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordSimpleDataFromNamed(\"fontObj\", fontRefName, opIdx);\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(opIdx, mode) {\n        this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(opIdx, rise) {\n        this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n        this.current.textRise = rise;\n    }\n    moveText(opIdx, x, y) {\n        this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(opIdx, x, y) {\n        this.setLeading(opIdx, -y);\n        this.moveText(opIdx, x, y);\n    }\n    setTextMatrix(opIdx, matrix) {\n        this.dependencyTracker?.recordSimpleData(\"textMatrix\", opIdx);\n        const { current } = this;\n        current.textMatrix = matrix;\n        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n    }\n    nextLine(opIdx) {\n        this.moveText(opIdx, 0, this.current.leading);\n        this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (path && (font.disableFontFace || patternFill || patternStroke)) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n            let currentTransform;\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n                    ctx.fill(scaledPath);\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    currentTransform ||= ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    const { a, b, c, d } = currentTransform;\n                    const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n                    const transf = Util.transform([\n                        a,\n                        b,\n                        c,\n                        d,\n                        0,\n                        0\n                    ], invPatternTransform);\n                    Util.singularValueDecompose2dScale(transf, XY);\n                    ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n                this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character));\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (this.dependencyTracker) {\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n                }\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(opIdx, glyphs) {\n        if (this.dependencyTracker) {\n            this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);\n            if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n                this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n            }\n        }\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            this.showType3Text(opIdx, glyphs);\n            this.dependencyTracker?.recordShowTextOperation(opIdx);\n            return undefined;\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            this.dependencyTracker?.recordOperation(opIdx);\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            const joinedChars = chars.join(\"\");\n            ctx.fillText(joinedChars, 0, 0);\n            if (this.dependencyTracker !== null) {\n                const measure = ctx.measureText(joinedChars);\n                this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);\n            }\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            let measure;\n            if (font.remeasure && width > 0) {\n                measure = ctx.measureText(character);\n                const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n                        bbox: null\n                    } : font, fontSize / fontSizeScale, scaledX, scaledY, ()=>measure ?? ctx.measureText(character));\n                } else {\n                    this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordShowTextOperation(opIdx);\n        return undefined;\n    }\n    showType3Text(opIdx, glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        ctx.scale(textHScale, fontDirection);\n        const dependencyTracker = this.dependencyTracker;\n        this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            } else if (this.contentVisible) {\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const p = [\n                glyph.width,\n                0\n            ];\n            Util.applyTransform(p, fontMatrix);\n            width = p[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        if (dependencyTracker) {\n            this.dependencyTracker = dependencyTracker;\n        }\n    }\n    setCharWidth(opIdx, xWidth, yWidth) {}\n    setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n        const clip = new Path2D();\n        clip.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip(clip);\n        this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n        this.endPath(opIdx);\n    }\n    getColorN_Pattern(opIdx, IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx, renderingOpIdx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)\n            };\n            pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(opIdx, IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternStroke = true;\n    }\n    setFillColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = color;\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = color;\n        this.current.patternFill = false;\n    }\n    setFillTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(opIdx, objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(opIdx, objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const pattern = this._getPattern(opIdx, objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const minMax = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv, minMax);\n            const [x0, y0, x1, y1] = minMax;\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore(opIdx);\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(opIdx, matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(opIdx, ...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n            const [x0, y0, x1, y1] = bbox;\n            const clip = new Path2D();\n            clip.rect(x0, y0, x1 - x0, y1 - y0);\n            this.ctx.clip(clip);\n            this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n            this.endPath(opIdx);\n        }\n    }\n    paintFormXObjectEnd(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore(opIdx);\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        let clip = new Path2D();\n        const [x0, y0, x1, y1] = group.bbox;\n        clip.rect(x0, y0, x1 - x0, y1 - y0);\n        if (group.matrix) {\n            const path = new Path2D();\n            path.addPath(clip, new DOMMatrix(group.matrix));\n            clip = path;\n        }\n        groupCtx.clip(clip);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        }\n        if (!group.smask || this.dependencyTracker) {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\n            \"fillAlpha\",\n            \"strokeAlpha\",\n            \"globalCompositeOperation\"\n        ]).pushBaseTransform(currentCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        this.dependencyTracker?.popBaseTransform();\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore(opIdx);\n            if (this.dependencyTracker) {\n                this.ctx.restore();\n            }\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore(opIdx);\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx, dirtyBox);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save(opIdx);\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath(opIdx);\n                const clip = new Path2D();\n                clip.rect(rect[0], rect[1], width, height);\n                this.ctx.clip(clip);\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(opIdx, ...transform);\n        this.transform(opIdx, ...matrix);\n    }\n    endAnnotation(opIdx) {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(opIdx, img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(opIdx, img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const mask = this._createMaskCanvas(opIdx, img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(opIdx, img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(opIdx, img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        this.dependencyTracker?.resetBBox(opIdx);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            ctx.drawImage(mask.canvas, trans[4], trans[5]);\n            this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageMaskXObjectGroup(opIdx, images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(opIdx, data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n            ctx.restore();\n        }\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageXObject(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(opIdx, imgData);\n    }\n    paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(opIdx, imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore(opIdx);\n    }\n    paintInlineImageXObjectGroup(opIdx, imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        this.dependencyTracker?.resetBBox(opIdx);\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n            ctx.restore();\n        }\n        this.dependencyTracker?.recordOperation(opIdx);\n        this.compose();\n    }\n    paintSolidColorImageMask(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(opIdx, tag) {}\n    markPointProps(opIdx, tag, properties) {}\n    beginMarkedContent(opIdx, tag) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(opIdx, tag, properties) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent(opIdx) {\n        this.dependencyTracker?.endMarkedContent(opIdx);\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat(opIdx) {}\n    endCompat(opIdx) {}\n    consumePath(opIdx, path, clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(path, \"evenodd\");\n                } else {\n                    ctx.clip(path);\n                }\n            }\n            this.pendingClip = null;\n            this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n        } else {\n            this.dependencyTracker?.recordOperation(opIdx);\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(path, saveRestore) {\n        const { ctx, current: { lineWidth } } = this;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        if (scaleX === scaleY) {\n            ctx.lineWidth = (lineWidth || 1) * scaleX;\n            ctx.stroke(path);\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        SCALE_MATRIX.a = 1 / scaleX;\n        SCALE_MATRIX.d = 1 / scaleY;\n        const newPath = new Path2D();\n        newPath.addPath(path, SCALE_MATRIX);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.lineWidth = lineWidth || 1;\n        ctx.stroke(newPath);\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/shared/obj-bin-transform.js\nclass CssFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"fontFamily\",\n            \"fontWeight\",\n            \"italicAngle\"\n        ];\n    }\n    static write(info) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encoder.encode(info[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        const buffer = new ArrayBuffer(stringsLength);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        assert(offset === buffer.byteLength, \"CssFontInfo.write: Buffer overflow\");\n        return buffer;\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    #readString(index) {\n        assert(index < CssFontInfo.strings.length, \"Invalid string index\");\n        let offset = 0;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get fontFamily() {\n        return this.#readString(0);\n    }\n    get fontWeight() {\n        return this.#readString(1);\n    }\n    get italicAngle() {\n        return this.#readString(2);\n    }\n}\nclass SystemFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"css\",\n            \"loadedName\",\n            \"baseFontName\",\n            \"src\"\n        ];\n    }\n    static write(info) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encoder.encode(info[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        stringsLength += 4;\n        let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;\n        if (info.style) {\n            encodedStyleStyle = encoder.encode(info.style.style);\n            encodedStyleWeight = encoder.encode(info.style.weight);\n            lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;\n        }\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        view.setUint8(offset++, info.guessFallback ? 1 : 0);\n        view.setUint32(offset, 0);\n        offset += 4;\n        stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            stringsLength += 4 + length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(offset - stringsLength - 4, stringsLength);\n        if (info.style) {\n            view.setUint32(offset, encodedStyleStyle.length);\n            data.set(encodedStyleStyle, offset + 4);\n            offset += 4 + encodedStyleStyle.length;\n            view.setUint32(offset, encodedStyleWeight.length);\n            data.set(encodedStyleWeight, offset + 4);\n            offset += 4 + encodedStyleWeight.length;\n        }\n        assert(offset <= buffer.byteLength, \"SubstitionInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    get guessFallback() {\n        return this.#view.getUint8(0) !== 0;\n    }\n    #readString(index) {\n        assert(index < SystemFontInfo.strings.length, \"Invalid string index\");\n        let offset = 5;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get css() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get baseFontName() {\n        return this.#readString(2);\n    }\n    get src() {\n        return this.#readString(3);\n    }\n    get style() {\n        let offset = 1;\n        offset += 4 + this.#view.getUint32(offset);\n        const styleLength = this.#view.getUint32(offset);\n        const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));\n        offset += 4 + styleLength;\n        const weightLength = this.#view.getUint32(offset);\n        const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));\n        return {\n            style,\n            weight\n        };\n    }\n}\nclass FontInfo {\n    static{\n        this.bools = [\n            \"black\",\n            \"bold\",\n            \"disableFontFace\",\n            \"fontExtraProperties\",\n            \"isInvalidPDFjsFont\",\n            \"isType3Font\",\n            \"italic\",\n            \"missingFile\",\n            \"remeasure\",\n            \"vertical\"\n        ];\n    }\n    static{\n        this.numbers = [\n            \"ascent\",\n            \"defaultWidth\",\n            \"descent\"\n        ];\n    }\n    static{\n        this.strings = [\n            \"fallbackName\",\n            \"loadedName\",\n            \"mimetype\",\n            \"name\"\n        ];\n    }\n    static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);\n    static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;\n    static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;\n    static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;\n    static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;\n    #buffer;\n    #decoder;\n    #view;\n    constructor({ data, extra }){\n        this.#buffer = data;\n        this.#decoder = new TextDecoder();\n        this.#view = new DataView(this.#buffer);\n        if (extra) {\n            Object.assign(this, extra);\n        }\n    }\n    #readBoolean(index) {\n        assert(index < FontInfo.bools.length, \"Invalid boolean index\");\n        const byteOffset = Math.floor(index / 4);\n        const bitOffset = index * 2 % 8;\n        const value = this.#view.getUint8(byteOffset) >> bitOffset & 0x03;\n        return value === 0x00 ? undefined : value === 0x02;\n    }\n    get black() {\n        return this.#readBoolean(0);\n    }\n    get bold() {\n        return this.#readBoolean(1);\n    }\n    get disableFontFace() {\n        return this.#readBoolean(2);\n    }\n    get fontExtraProperties() {\n        return this.#readBoolean(3);\n    }\n    get isInvalidPDFjsFont() {\n        return this.#readBoolean(4);\n    }\n    get isType3Font() {\n        return this.#readBoolean(5);\n    }\n    get italic() {\n        return this.#readBoolean(6);\n    }\n    get missingFile() {\n        return this.#readBoolean(7);\n    }\n    get remeasure() {\n        return this.#readBoolean(8);\n    }\n    get vertical() {\n        return this.#readBoolean(9);\n    }\n    #readNumber(index) {\n        assert(index < FontInfo.numbers.length, \"Invalid number index\");\n        return this.#view.getFloat64(FontInfo.#OFFSET_NUMBERS + index * 8);\n    }\n    get ascent() {\n        return this.#readNumber(0);\n    }\n    get defaultWidth() {\n        return this.#readNumber(1);\n    }\n    get descent() {\n        return this.#readNumber(2);\n    }\n    get bbox() {\n        let offset = FontInfo.#OFFSET_BBOX;\n        const numCoords = this.#view.getUint8(offset);\n        if (numCoords === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const bbox = [];\n        for(let i = 0; i < 4; i++){\n            bbox.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return bbox;\n    }\n    get fontMatrix() {\n        let offset = FontInfo.#OFFSET_FONT_MATRIX;\n        const numPoints = this.#view.getUint8(offset);\n        if (numPoints === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const fontMatrix = [];\n        for(let i = 0; i < 6; i++){\n            fontMatrix.push(this.#view.getFloat64(offset, true));\n            offset += 8;\n        }\n        return fontMatrix;\n    }\n    get defaultVMetrics() {\n        let offset = FontInfo.#OFFSET_DEFAULT_VMETRICS;\n        const numMetrics = this.#view.getUint8(offset);\n        if (numMetrics === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const defaultVMetrics = [];\n        for(let i = 0; i < 3; i++){\n            defaultVMetrics.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return defaultVMetrics;\n    }\n    #readString(index) {\n        assert(index < FontInfo.strings.length, \"Invalid string index\");\n        let offset = FontInfo.#OFFSET_STRINGS + 4;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        const stringData = new Uint8Array(length);\n        stringData.set(new Uint8Array(this.#buffer, offset + 4, length));\n        return this.#decoder.decode(stringData);\n    }\n    get fallbackName() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get mimetype() {\n        return this.#readString(2);\n    }\n    get name() {\n        return this.#readString(3);\n    }\n    get data() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        if (length === 0) {\n            return undefined;\n        }\n        return new Uint8Array(this.#buffer, offset + 4, length);\n    }\n    clearData() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        const data = new Uint8Array(this.#buffer, offset + 4, length);\n        data.fill(0);\n        this.#view.setUint32(offset, 0);\n    }\n    get cssFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        if (cssFontInfoLength === 0) {\n            return null;\n        }\n        const cssFontInfoData = new Uint8Array(cssFontInfoLength);\n        cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));\n        return new CssFontInfo(cssFontInfoData.buffer);\n    }\n    get systemFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        if (systemFontInfoLength === 0) {\n            return null;\n        }\n        const systemFontInfoData = new Uint8Array(systemFontInfoLength);\n        systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));\n        return new SystemFontInfo(systemFontInfoData.buffer);\n    }\n    static write(font) {\n        const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;\n        const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of FontInfo.strings){\n            encodedStrings[prop] = encoder.encode(font[prop]);\n            stringsLength += 4 + encodedStrings[prop].length;\n        }\n        const lengthEstimate = FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        const numBools = FontInfo.bools.length;\n        let boolByte = 0, boolBit = 0;\n        for(let i = 0; i < numBools; i++){\n            const value = font[FontInfo.bools[i]];\n            const bits = value === undefined ? 0x00 : value ? 0x02 : 0x01;\n            boolByte |= bits << boolBit;\n            boolBit += 2;\n            if (boolBit === 8 || i === numBools - 1) {\n                view.setUint8(offset++, boolByte);\n                boolByte = 0;\n                boolBit = 0;\n            }\n        }\n        assert(offset === FontInfo.#OFFSET_NUMBERS, \"FontInfo.write: Boolean properties offset mismatch\");\n        for (const prop of FontInfo.numbers){\n            view.setFloat64(offset, font[prop]);\n            offset += 8;\n        }\n        assert(offset === FontInfo.#OFFSET_BBOX, \"FontInfo.write: Number properties offset mismatch\");\n        if (font.bbox) {\n            view.setUint8(offset++, 4);\n            for (const coord of font.bbox){\n                view.setInt16(offset, coord, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 2 * 4;\n        }\n        assert(offset === FontInfo.#OFFSET_FONT_MATRIX, \"FontInfo.write: BBox properties offset mismatch\");\n        if (font.fontMatrix) {\n            view.setUint8(offset++, 6);\n            for (const point of font.fontMatrix){\n                view.setFloat64(offset, point, true);\n                offset += 8;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 8 * 6;\n        }\n        assert(offset === FontInfo.#OFFSET_DEFAULT_VMETRICS, \"FontInfo.write: FontMatrix properties offset mismatch\");\n        if (font.defaultVMetrics) {\n            view.setUint8(offset++, 1);\n            for (const metric of font.defaultVMetrics){\n                view.setInt16(offset, metric, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 3 * 2;\n        }\n        assert(offset === FontInfo.#OFFSET_STRINGS, \"FontInfo.write: DefaultVMetrics properties offset mismatch\");\n        view.setUint32(FontInfo.#OFFSET_STRINGS, 0);\n        offset += 4;\n        for (const prop of FontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(FontInfo.#OFFSET_STRINGS, offset - FontInfo.#OFFSET_STRINGS - 4);\n        if (!systemFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = systemFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at systemFontInfo\");\n            data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (!cssFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = cssFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at cssFontInfo\");\n            data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (font.data === undefined) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            view.setUint32(offset, font.data.length);\n            data.set(font.data, offset + 4);\n            offset += 4 + font.data.length;\n        }\n        assert(offset <= buffer.byteLength, \"FontInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #map;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#map = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#map.get(name) ?? null;\n    }\n    [Symbol.iterator]() {\n        return this.#map.entries();\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n    [Symbol.iterator]() {\n        return this.#groups.entries();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseError(status, url) {\n    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = createResponseError(0, this._url.href);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/pdf_objects.js\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * OutputScale.pixelRatio;\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * OutputScale.pixelRatio;\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, style, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        const ascent = metrics.fontBoundingBoxAscent;\n        const descent = Math.abs(metrics.fontBoundingBoxDescent);\n        ctx.canvas.width = ctx.canvas.height = 0;\n        let ratio = 0.8;\n        if (ascent) {\n            ratio = ascent / (ascent + descent);\n        } else {\n            if (util_FeatureTest.platform.isFirefox) {\n                warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n            }\n            if (style.ascent) {\n                ratio = style.ascent;\n            } else if (style.descent) {\n                ratio = 1 + style.descent;\n            }\n        }\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/api.js\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n    const iccUrl = getFactoryUrlProp(src.iccUrl);\n    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n    const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n    const enableHWA = src.enableHWA === true;\n    const useWasm = src.useWasm !== false;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        }),\n        wasmFactory: useWorkerFetch ? null : new WasmFactory({\n            baseUrl: wasmUrl\n        })\n    };\n    if (!worker) {\n        worker = PDFWorker.create({\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        });\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"5.4.296\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            useWasm,\n            useWorkerFetch,\n            cMapUrl,\n            iccUrl,\n            standardFontDataUrl,\n            wasmUrl\n        }\n    };\n    const transportParams = {\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n    async getData() {\n        return this._transport.getData();\n    }\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n}\nclass PDFDataRangeTransport {\n    #capability;\n    #progressiveDoneListeners;\n    #progressiveReadListeners;\n    #progressListeners;\n    #rangeListeners;\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.#capability = Promise.withResolvers();\n        this.#progressiveDoneListeners = [];\n        this.#progressiveReadListeners = [];\n        this.#progressListeners = [];\n        this.#rangeListeners = [];\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n    }\n    addRangeListener(listener) {\n        this.#rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this.#progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this.#progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this.#progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this.#rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this.#capability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._intentStates = new Map();\n        this.destroyed = false;\n        this.recordedBBoxes = null;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, canvas = canvasContext.canvas, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false, recordOperations = false, operationsFilter = null }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);\n        const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (shouldRecordOperations) {\n                const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();\n                if (recordedBBoxes) {\n                    if (internalRenderTask.stepper) {\n                        internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());\n                    }\n                    if (recordOperations) {\n                        this.recordedBBoxes = recordedBBoxes;\n                    }\n                }\n            }\n            if (intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup();\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvas,\n                canvasContext,\n                dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors,\n            enableHWA: this._transport.enableHWA,\n            operationsFilter\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup();\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup() {\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup();\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup();\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass PDFWorker {\n    #capability;\n    #messageHandler;\n    #port;\n    #webWorker;\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts = new WeakMap();\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            const base = URL.parse(baseUrl);\n            if (!base?.origin || base.origin === \"null\") {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n        this.fromPort = (params)=>{\n            deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n            if (!params?.port) {\n                throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n            }\n            return this.create(params);\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.#capability = Promise.withResolvers();\n        this.#messageHandler = null;\n        this.#port = null;\n        this.#webWorker = null;\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        if (port) {\n            if (PDFWorker.#workerPorts.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            PDFWorker.#workerPorts.set(port, this);\n            this.#initializeFromPort(port);\n        } else {\n            this.#initialize();\n        }\n    }\n    get promise() {\n        return this.#capability.promise;\n    }\n    #resolve() {\n        this.#capability.resolve();\n        this.#messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this.#port;\n    }\n    get messageHandler() {\n        return this.#messageHandler;\n    }\n    #initializeFromPort(port) {\n        this.#port = port;\n        this.#messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this.#messageHandler.on(\"ready\", ()=>{});\n        this.#resolve();\n    }\n    #initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this.#setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this.#capability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this.#setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this.#webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this.#messageHandler = messageHandler;\n                this.#port = worker;\n                this.#webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this.#setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this.#setupFakeWorker();\n    }\n    #setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this.#capability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this.#port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this.#messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this.#capability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this.#webWorker?.terminate();\n        this.#webWorker = null;\n        PDFWorker.#workerPorts.delete(this.#port);\n        this.#port = null;\n        this.#messageHandler?.destroy();\n        this.#messageHandler = null;\n    }\n    static create(params) {\n        const cachedPort = this.#workerPorts.get(params?.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.create - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ /*@vite-ignore*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.wasmFactory = factory.wasmFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.enableHWA = enableHWA;\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const fontData = new FontInfo(exportedData);\n                    const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!font.fontExtraProperties && font.data) {\n                            font.clearData();\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBinaryData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            const factory = this[data.type];\n            if (!factory) {\n                throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n            }\n            return factory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n            types,\n            pageIndexesToSkip\n        });\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.onContinue = null;\n        this.onError = null;\n        this.#internalRenderTask = internalRenderTask;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null, enableHWA = false, operationsFilter = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvas;\n        this._canvasContext = params.canvas ? null : params.canvasContext;\n        this._enableHWA = enableHWA;\n        this._dependencyTracker = params.dependencyTracker;\n        this._operationsFilter = operationsFilter;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { viewport, transform, background, dependencyTracker } = this.params;\n        const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n            alpha: false,\n            willReadFrequently: !this._enableHWA\n        });\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n        this.callback(error);\n        this.task.onError?.(error);\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"5.4.296\";\nconst build = \"f56dc8601\";\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.ariaHasPopup = \"true\";\n        if (this.#editor) {\n            button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.ariaHidden = \"true\";\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.ariaOrientation = \"horizontal\";\n        dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.ariaMultiSelectable = \"false\";\n        div.ariaOrientation = \"vertical\";\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        if (this.#editor) {\n            div.id = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.ariaSelected = color === this.#defaultColor;\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            value: color\n        });\n        this.updateColor(color);\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        this.#button.ariaExpanded = \"true\";\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#button.ariaExpanded = \"false\";\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.ariaSelected = i.next().value === color.toUpperCase();\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\nclass BasicColorPicker {\n    #input;\n    #editor;\n    #uiManager;\n    static #l10nColor = null;\n    constructor(editor){\n        this.#input = null;\n        this.#editor = null;\n        this.#uiManager = null;\n        this.#editor = editor;\n        this.#uiManager = editor._uiManager;\n        BasicColorPicker.#l10nColor ||= Object.freeze({\n            freetext: \"pdfjs-editor-color-picker-free-text-input\",\n            ink: \"pdfjs-editor-color-picker-ink-input\"\n        });\n    }\n    renderButton() {\n        if (this.#input) {\n            return this.#input;\n        }\n        const { editorType, colorType, colorValue } = this.#editor;\n        const input = this.#input = document.createElement(\"input\");\n        input.type = \"color\";\n        input.value = colorValue || \"#000000\";\n        input.className = \"basicColorPicker\";\n        input.tabIndex = 0;\n        input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n        input.addEventListener(\"input\", ()=>{\n            this.#uiManager.updateParams(colorType, input.value);\n        }, {\n            signal: this.#uiManager._signal\n        });\n        return input;\n    }\n    update(value) {\n        if (!this.#input) {\n            return;\n        }\n        this.#input.value = value;\n    }\n    destroy() {\n        this.#input?.remove();\n        this.#input = null;\n    }\n    hideDropdown() {}\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.find.js\nvar es_iterator_find = __nested_webpack_require_216482__(116);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.flat-map.js\nvar es_iterator_flat_map = __nested_webpack_require_216482__(531);\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\nconst DateFormats = /* unused pure expression or super */ null && 0;\nconst TimeFormats = /* unused pure expression or super */ null && 0;\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/annotation_layer.js\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nconst TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableComment = parameters.enableComment;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ contentsObj, richText }) {\n        return !!(contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;\n    }\n    get commentData() {\n        const { data } = this;\n        const editor = this.annotationStorage?.getEditor(data.id);\n        if (editor) {\n            return editor.getData();\n        }\n        return data;\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.hasPopupElement;\n    }\n    get commentButtonPosition() {\n        const editor = this.annotationStorage?.getEditor(this.data.id);\n        if (editor) {\n            return editor.commentButtonPositionInPage;\n        }\n        const { quadPoints, inkLists, rect } = this.data;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        if (quadPoints?.length >= 8) {\n            for(let i = 0; i < quadPoints.length; i += 8){\n                if (quadPoints[i + 1] > maxY) {\n                    maxY = quadPoints[i + 1];\n                    maxX = quadPoints[i + 2];\n                } else if (quadPoints[i + 1] === maxY) {\n                    maxX = Math.max(maxX, quadPoints[i + 2]);\n                }\n            }\n            return [\n                maxX,\n                maxY\n            ];\n        }\n        if (inkLists?.length >= 1) {\n            for (const inkList of inkLists){\n                for(let i = 0, ii = inkList.length; i < ii; i += 2){\n                    if (inkList[i + 1] > maxY) {\n                        maxY = inkList[i + 1];\n                        maxX = inkList[i];\n                    } else if (inkList[i + 1] === maxY) {\n                        maxX = Math.max(maxX, inkList[i]);\n                    }\n                }\n            }\n            if (maxX !== Infinity) {\n                return [\n                    maxX,\n                    maxY\n                ];\n            }\n        }\n        if (rect) {\n            return [\n                rect[2],\n                rect[3]\n            ];\n        }\n        return null;\n    }\n    _normalizePoint(point) {\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.parent;\n        point[1] = view[3] - point[1] + view[1];\n        point[0] = 100 * (point[0] - pageX) / pageWidth;\n        point[1] = 100 * (point[1] - pageY) / pageHeight;\n        return point;\n    }\n    get commentText() {\n        const { data } = this;\n        return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || \"\";\n    }\n    set commentText(text) {\n        const { data } = this;\n        const popup = {\n            deleted: !text,\n            contents: text || \"\"\n        };\n        if (!this.annotationStorage.updateEditor(data.id, {\n            popup\n        })) {\n            this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {\n                id: data.id,\n                annotationType: data.annotationType,\n                pageIndex: this.parent.page._pageIndex,\n                popup,\n                popupRef: data.popupRef,\n                modificationDate: new Date()\n            });\n        }\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    removePopup() {\n        (this.#popupElement?.popup || this.popup)?.remove();\n        this.#popupElement = this.popup = null;\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        if (params.rect) {\n            this.#updates ||= {\n                rect: this.data.rect.slice(0)\n            };\n        }\n        const { rect, popup: newPopup } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        let popup = this.#popupElement?.popup || this.popup;\n        if (!popup && newPopup?.text) {\n            this._createPopup(newPopup);\n            popup = this.#popupElement.popup;\n        }\n        if (!popup) {\n            return;\n        }\n        popup.updateEdited(params);\n        if (newPopup?.deleted) {\n            popup.remove();\n            this.#popupElement = null;\n            this.popup = null;\n        }\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n            style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n            container.tabIndex = 0;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex;\n        this.parent.zIndex += 2;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = this;\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        let { width, height } = this;\n        if (angle % 180 !== 0) {\n            [width, height] = [\n                height,\n                width\n            ];\n        }\n        container.style.width = `${100 * width / pageWidth}%`;\n        container.style.height = `${100 * height / pageHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        svg.role = \"none\";\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup(popupData = null) {\n        const { data } = this;\n        let contentsObj, modificationDate;\n        if (popupData) {\n            contentsObj = {\n                str: popupData.text\n            };\n            modificationDate = popupData.date;\n        } else {\n            contentsObj = data.contentsObj;\n            modificationDate = data.modificationDate;\n        }\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate,\n                contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation,\n                noRotate: true\n            },\n            linkService: this.linkService,\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        if (!this.parent._commentManager) {\n            this.parent.div.append(popup.render());\n        }\n    }\n    get hasPopupElement() {\n        return !!(this.#popupElement || this.popup || this.data.popupRef);\n    }\n    get extraPopupElement() {\n        return this.#popupElement;\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId,\n                mustEnterInEditMode: true\n            });\n        });\n    }\n    get width() {\n        return this.data.rect[2] - this.data.rect[0];\n    }\n    get height() {\n        return this.data.rect[3] - this.data.rect[1];\n    }\n}\nclass EditorAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.editor = parameters.editor;\n    }\n    render() {\n        this.container.className = \"editorAnnotation\";\n        return this.container;\n    }\n    createOrUpdatePopup() {\n        const { editor } = this;\n        if (!editor.hasComment) {\n            return;\n        }\n        this._createPopup(editor.comment);\n        this.extraPopupElement.popup.renderCommentButton();\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.editor.hasComment;\n    }\n    get commentButtonPosition() {\n        return this.editor.commentButtonPositionInPage;\n    }\n    get commentText() {\n        return this.editor.comment.text;\n    }\n    set commentText(text) {\n        this.editor.comment = text;\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    get commentData() {\n        return this.editor.getData();\n    }\n    remove() {\n        this.container.remove();\n        this.container = null;\n        this.removePopup();\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action, data.overlaidText);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest, data.overlaidText);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination, overlaidText = \"\") {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n    }\n    _bindNamedAction(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        } else if (overlaidText) {\n            link.title = overlaidText;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (data.overlaidText) {\n            link.title = data.overlaidText;\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = this.data.password ? \"password\" : \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = 0;\n            const { datetimeFormat, datetimeType, timeStep } = this.data;\n            const hasDateOrTime = !!datetimeType && this.enableScripting;\n            if (datetimeFormat) {\n                element.title = datetimeFormat;\n            }\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (hasDateOrTime) {\n                        target.type = datetimeType;\n                        if (timeStep) {\n                            target.step = timeStep;\n                        }\n                    }\n                    if (elementData.userValue) {\n                        const value = elementData.userValue;\n                        if (hasDateOrTime) {\n                            if (datetimeType === \"time\") {\n                                const date = new Date(value);\n                                const parts = [\n                                    date.getHours(),\n                                    date.getMinutes(),\n                                    date.getSeconds()\n                                ];\n                                target.value = parts.map((v)=>v.toString().padStart(2, \"0\")).join(\":\");\n                            } else {\n                                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n                            }\n                        } else {\n                            target.value = value;\n                        }\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            if (!hasDateOrTime) {\n                                storage.setValue(id, {\n                                    value: elementData.userValue.toString()\n                                });\n                            }\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            const data = {\n                                formattedValue\n                            };\n                            if (hasDateOrTime) {\n                                data.value = formattedValue;\n                            }\n                            storage.setValue(id, data);\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { target } = event;\n                    let { value } = target;\n                    if (hasDateOrTime) {\n                        if (value && datetimeType === \"time\") {\n                            const parts = value.split(\":\").map((v)=>parseInt(v, 10));\n                            value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n                            target.step = \"\";\n                        } else {\n                            if (!value.includes(\"T\")) {\n                                value = `${value}T00:00`;\n                            }\n                            value = new Date(value).valueOf();\n                        }\n                        target.type = \"text\";\n                    }\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = 0;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements, parent } = parameters;\n        const hasCommentManager = !!parent._commentManager;\n        super(parameters, {\n            isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        if (hasCommentManager && AnnotationElement._hasPopupData(data)) {\n            const popup = this.popup = this.#createPopup();\n            for (const element of elements){\n                element.popup = popup;\n            }\n        } else {\n            this.popup = null;\n        }\n    }\n    #createPopup() {\n        return new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate || this.data.creationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open,\n            commentManager: this.parent._commentManager\n        });\n    }\n    render() {\n        const { container } = this;\n        container.classList.add(\"popupAnnotation\");\n        container.role = \"comment\";\n        const popup = this.popup = this.#createPopup();\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #commentManager;\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #popupAbortController;\n    #position;\n    #commentButton;\n    #commentButtonPosition;\n    #popupPosition;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    #firstElement;\n    #commentText;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open, commentManager = null }){\n        this.#commentManager = null;\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#popupAbortController = null;\n        this.#position = null;\n        this.#commentButton = null;\n        this.#commentButtonPosition = null;\n        this.#popupPosition = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#firstElement = null;\n        this.#commentText = null;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#commentManager = commentManager;\n        this.#firstElement = elements[0];\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        if (commentManager) {\n            this.renderCommentButton();\n        } else {\n            this.#addEventListeners();\n            this.#container.hidden = true;\n            if (open) {\n                this.#toggle();\n            }\n        }\n    }\n    #addEventListeners() {\n        if (this.#popupAbortController) {\n            return;\n        }\n        this.#popupAbortController = new AbortController();\n        const { signal } = this.#popupAbortController;\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle, {\n                signal\n            });\n            element.addEventListener(\"pointerenter\", this.#boundShow, {\n                signal\n            });\n            element.addEventListener(\"pointerleave\", this.#boundHide, {\n                signal\n            });\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of this.#elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n        }\n    }\n    #setCommentButtonPosition() {\n        const element = this.#elements.find((e)=>e.hasCommentButton);\n        if (!element) {\n            return;\n        }\n        this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n    }\n    renderCommentButton() {\n        if (this.#commentButton) {\n            return;\n        }\n        if (!this.#commentButtonPosition) {\n            this.#setCommentButtonPosition();\n        }\n        if (!this.#commentButtonPosition) {\n            return;\n        }\n        const { signal } = this.#popupAbortController = new AbortController();\n        const hasOwnButton = !!this.#firstElement.extraPopupElement;\n        const togglePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, true, undefined, !hasOwnButton);\n        };\n        const showPopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);\n        };\n        const hidePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, false);\n        };\n        if (!hasOwnButton) {\n            const button = this.#commentButton = document.createElement(\"button\");\n            button.className = \"annotationCommentButton\";\n            const parentContainer = this.#firstElement.container;\n            button.style.zIndex = parentContainer.style.zIndex + 1;\n            button.tabIndex = 0;\n            button.ariaHasPopup = \"dialog\";\n            button.ariaControls = \"commentPopup\";\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n            this.#updateColor();\n            this.#updateCommentButtonPosition();\n            button.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n            button.addEventListener(\"click\", togglePopup, {\n                signal\n            });\n            button.addEventListener(\"pointerenter\", showPopup, {\n                signal\n            });\n            button.addEventListener(\"pointerleave\", hidePopup, {\n                signal\n            });\n            parentContainer.after(button);\n        } else {\n            this.#commentButton = this.#firstElement.container;\n            for (const element of this.trigger){\n                element.ariaHasPopup = \"dialog\";\n                element.ariaControls = \"commentPopup\";\n                element.addEventListener(\"keydown\", this.#boundKeyDown, {\n                    signal\n                });\n                element.addEventListener(\"click\", togglePopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerenter\", showPopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerleave\", hidePopup, {\n                    signal\n                });\n                element.classList.add(\"popupTriggerArea\");\n            }\n        }\n    }\n    #updateCommentButtonPosition() {\n        if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {\n            return;\n        }\n        this.renderCommentButton();\n        const [x, y] = this.#commentButtonPosition;\n        const { style } = this.#commentButton;\n        style.left = `calc(${x}%)`;\n        style.top = `calc(${y}% - var(--comment-button-dim))`;\n    }\n    #updateColor() {\n        if (this.#firstElement.extraPopupElement) {\n            return;\n        }\n        this.renderCommentButton();\n        this.#commentButton.style.backgroundColor = this.commentButtonColor || \"\";\n    }\n    get commentButtonColor() {\n        const { color, opacity } = this.#firstElement.commentData;\n        if (!color) {\n            return null;\n        }\n        return this.#parent._commentManager.makeCommentColor(color, opacity);\n    }\n    focusCommentButton() {\n        setTimeout(()=>{\n            this.#commentButton?.focus();\n        }, 0);\n    }\n    getData() {\n        const { richText, color, opacity, creationDate, modificationDate } = this.#firstElement.commentData;\n        return {\n            contentsObj: {\n                str: this.comment\n            },\n            richText,\n            color,\n            opacity,\n            creationDate,\n            modificationDate\n        };\n    }\n    get elementBeforePopup() {\n        return this.#commentButton;\n    }\n    get comment() {\n        this.#commentText ||= this.#firstElement.commentText;\n        return this.#commentText;\n    }\n    set comment(text) {\n        if (text === this.comment) {\n            return;\n        }\n        this.#firstElement.commentText = this.#commentText = text;\n    }\n    get parentBoundingClientRect() {\n        return this.#firstElement.layer.getBoundingClientRect();\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentButton) {\n            return;\n        }\n        this.#commentButton.classList.toggle(\"selected\", selected);\n        this.#commentButton.ariaExpanded = hasPopup;\n    }\n    setSelectedCommentButton(selected) {\n        this.#commentButton.classList.toggle(\"selected\", selected);\n    }\n    get commentPopupPosition() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        const { x, y, height } = this.#commentButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#firstElement.layer.getBoundingClientRect();\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPosition(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    get commentButtonPosition() {\n        return this.#commentButtonPosition;\n    }\n    get commentButtonWidth() {\n        return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;\n    }\n    editComment(options) {\n        const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map((x)=>x / 100);\n        const parentDimensions = this.parentBoundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        if (this.#titleObj?.str) {\n            const title = document.createElement(\"span\");\n            title.className = \"title\";\n            header.append(title);\n            ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        }\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"time\");\n            modificationDate.className = \"popupDate\";\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            modificationDate.dateTime = this.#dateObj.toISOString();\n            header.append(modificationDate);\n        }\n        renderRichText({\n            html: this.#html || this.#contentsObj.str,\n            dir: this.#contentsObj?.dir,\n            className: \"popupContent\"\n        }, popup);\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popup, deleted }) {\n        if (this.#commentManager) {\n            if (deleted) {\n                this.remove();\n                this.#commentText = null;\n            } else if (popup) {\n                if (popup.deleted) {\n                    this.remove();\n                } else {\n                    this.#updateColor();\n                    this.#commentText = popup.text;\n                }\n            }\n            if (rect) {\n                this.#commentButtonPosition = null;\n                this.#setCommentButtonPosition();\n                this.#updateCommentButtonPosition();\n            }\n            return;\n        }\n        if (deleted || popup?.deleted) {\n            this.remove();\n            return;\n        }\n        this.#addEventListeners();\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popup && popup.text) {\n            this.#richText = this.#makePopupContent(popup.text);\n            this.#dateObj = PDFDateString.toDateObject(popup.date);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    remove() {\n        this.#popupAbortController?.abort();\n        this.#popupAbortController = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#wasVisible = false;\n        this.#pinned = false;\n        this.#commentButton?.remove();\n        this.#commentButton = null;\n        if (this.trigger) {\n            for (const element of this.trigger){\n                element.classList.remove(\"popupTriggerArea\");\n            }\n        }\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        if (this.#commentManager) {\n            this.#commentManager.toggleCommentPopup(this, false);\n            return;\n        }\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (this.#commentManager) {\n            return;\n        }\n        this.#addEventListeners();\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        if (this.#commentManager) {\n            return false;\n        }\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef }, width, height } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        if (overlaidText) {\n            const mark = document.createElement(\"mark\");\n            mark.classList.add(\"overlaidText\");\n            mark.textContent = overlaidText;\n            this.container.append(mark);\n        }\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        if (overlaidText) {\n            const strikeout = document.createElement(\"s\");\n            strikeout.classList.add(\"overlaidText\");\n            strikeout.textContent = overlaidText;\n            this.container.append(strikeout);\n        }\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #annotationStorage;\n    #editableAnnotations;\n    #structTreeLayer;\n    #linkService;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer, commentManager, linkService, annotationStorage }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#annotationStorage = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.#linkService = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.#linkService = linkService || null;\n        this.#annotationStorage = annotationStorage || new AnnotationStorage();\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n        this._commentManager = commentManager || null;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id, popupElements) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        if (popupElements) {\n            popupElements.at(-1).container.after(element);\n        } else {\n            this.div.append(element);\n            this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n        }\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: this.#linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: this.#annotationStorage,\n            enableComment: params.enableComment === true,\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id, elementParams.elements);\n            element.extraPopupElement?.popup?.renderCommentButton();\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    async addLinkAnnotations(annotations) {\n        const elementParams = {\n            data: null,\n            layer: this.div,\n            linkService: this.#linkService,\n            svgFactory: new DOMSVGFactory(),\n            parent: this\n        };\n        for (const data of annotations){\n            data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            const rendered = element.render();\n            await this.#appendElement(rendered, data.id, null);\n        }\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n            const editableAnnotation = this.#editableAnnotations.get(id);\n            if (!editableAnnotation) {\n                continue;\n            }\n            if (editableAnnotation._hasNoCanvas) {\n                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n                editableAnnotation._hasNoCanvas = false;\n            } else {\n                editableAnnotation.canvas = canvas;\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n    addFakeAnnotation(editor) {\n        const { div } = this;\n        const { id, rotation } = editor;\n        const element = new EditorAnnotationElement({\n            data: {\n                id,\n                rect: editor.getPDFRect(),\n                rotation\n            },\n            editor,\n            layer: div,\n            parent: this,\n            enableComment: !!this._commentManager,\n            linkService: this.#linkService,\n            annotationStorage: this.#annotationStorage\n        });\n        const htmlElement = element.render();\n        div.append(htmlElement);\n        this.#accessibilityManager?.moveElementInDOM(div, htmlElement, htmlElement, false);\n        element.createOrUpdatePopup();\n        return element;\n    }\n    static get _defaultBorderStyle() {\n        return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n            width: 1,\n            rawWidth: 1,\n            style: AnnotationBorderStyleType.SOLID,\n            dashArray: [\n                3\n            ],\n            horizontalCornerRadius: 0,\n            verticalCornerRadius: 0\n        }));\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self1)=>self1.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this._colorPicker = null;\n        this.color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n        }\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.color\n            ]\n        ];\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.FREETEXT_COLOR;\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    onUpdatedColor() {\n        this.editorDiv.style.color = this.color;\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.color = col;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (!super.enableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n        return true;\n    }\n    disableEditMode() {\n        if (!super.disableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n        return true;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    get canChangeContent() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy || this.annotationElementId) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        if (this._isCopy || this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this._moveAfterPaste(baseX, baseY);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = Math.sumPrecise(bufferBefore.map((line)=>line.length));\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    getPDFRect() {\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        return this.getRect(padding, padding);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef, richText, contentsObj, creationDate, modificationDate }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null,\n                richText,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent()\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (!content) {\n            return null;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {\n                text: this.#content\n            }\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.firstPoint = [\n            NaN,\n            NaN\n        ];\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        const minMax = [\n            lastX,\n            lastY,\n            lastX,\n            lastY\n        ];\n        let firstPointX = lastX;\n        let firstPointY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        const bezierBbox = new Float32Array(4);\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            const x = outline[i + 4], y = outline[i + 5];\n            if (isNaN(outline[i])) {\n                Util.pointBoundingBox(x, y, minMax);\n                if (firstPointY > y) {\n                    firstPointX = x;\n                    firstPointY = y;\n                } else if (firstPointY === y) {\n                    firstPointX = ltrCallback(firstPointX, x);\n                }\n                if (lastPointY < y) {\n                    lastPointX = x;\n                    lastPointY = y;\n                } else if (lastPointY === y) {\n                    lastPointX = ltrCallback(lastPointX, x);\n                }\n            } else {\n                bezierBbox[0] = bezierBbox[1] = Infinity;\n                bezierBbox[2] = bezierBbox[3] = -Infinity;\n                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);\n                Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);\n                if (firstPointY > bezierBbox[1]) {\n                    firstPointX = bezierBbox[0];\n                    firstPointY = bezierBbox[1];\n                } else if (firstPointY === bezierBbox[1]) {\n                    firstPointX = ltrCallback(firstPointX, bezierBbox[0]);\n                }\n                if (lastPointY < bezierBbox[3]) {\n                    lastPointX = bezierBbox[2];\n                    lastPointY = bezierBbox[3];\n                } else if (lastPointY === bezierBbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bezierBbox[2]);\n                }\n            }\n            lastX = x;\n            lastY = y;\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minMax[0] - this.#innerMargin;\n        bbox[1] = minMax[1] - this.#innerMargin;\n        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n        this.firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #firstPoint;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        const minMax = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n        }\n        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n        const shiftedMinX = minMax[0] - innerMargin;\n        const shiftedMinY = minMax[1] - innerMargin;\n        let firstPointX = isLTR ? -Infinity : Infinity;\n        let firstPointY = Infinity;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2, left] = edge;\n            if (!left && isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.max(firstPointX, x);\n                }\n            } else if (left && !isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.min(firstPointX, x);\n                }\n            }\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, firstPoint, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.firstPoint = firstPoint;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #firstPoint;\n    #lastPoint;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#firstPoint = null;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { firstPoint } = this.#highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - this.x) / this.width,\n            (firstPoint[1] - this.y) / this.height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { firstPoint } = highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - x) / width,\n            (firstPoint[1] - y) / height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    get commentButtonPosition() {\n        return this.#firstPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    onUpdatedColor() {\n        this.parent?.drawLayer.updateProperties(this.#id, {\n            root: {\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            }\n        });\n        this.#colorPicker?.updateColor(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.opacity = opa;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.getNonHCMColorName(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    get toolbarButtons() {\n        if (this._uiManager.highlightColors) {\n            const colorPicker = this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            return [\n                [\n                    \"colorPicker\",\n                    colorPicker\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        this.setDims(this.width, this.height);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        this.setDims(this.width, this.height);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n            editor.rotate(editor.parentRotation);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n        const serialized = super.serialize(isForCopying);\n        Object.assign(serialized, {\n            color,\n            opacity: this.opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(serialized.rect)\n        });\n        this.addComment(serialized);\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return this.hasEditedComment || serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            if (!name.startsWith(\"_\")) {\n                this.updateProperty(name, value);\n            }\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._colorPicker = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        this._addOutlines(params);\n    }\n    onUpdatedColor() {\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    _addOutlines(params) {\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n        }\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n            if (type === this.colorType) {\n                this.onUpdatedColor();\n            }\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(_x, _y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox()\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            this.setDims();\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        this.setDims();\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event?.target === parent.div) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getPDFRect()\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    get thickness() {\n        return this.#thickness;\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12 && isNaN(line[6])) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new this.prototype.constructor();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    Util.pointBoundingBox(line[i], line[i + 1], bbox);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    constructor(viewerParameters){\n        super();\n        this._viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this._viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n        this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.INK_COLOR;\n    }\n    get color() {\n        return this._drawingOptions.stroke;\n    }\n    get opacity() {\n        return this._drawingOptions[\"stroke-opacity\"];\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            }\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points,\n            popup: this.comment\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/drawers/contour.js\nclass ContourDrawOutline extends InkDrawOutline {\n    toSVGPath() {\n        let path = super.toSVGPath();\n        if (!path.endsWith(\"Z\")) {\n            path += \"Z\";\n        }\n        return path;\n    }\n}\n; // ./src/display/editor/drawers/signaturedraw.js\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n    static #PARAMETERS = {\n        maxDim: 512,\n        sigmaSFactor: 0.02,\n        sigmaR: 25,\n        kernelSize: 16\n    };\n    static #neighborIndexToId(i0, j0, i, j) {\n        i -= i0;\n        j -= j0;\n        if (i === 0) {\n            return j > 0 ? 0 : 4;\n        }\n        if (i === 1) {\n            return j + 6;\n        }\n        return 2 - j;\n    }\n    static #neighborIdToIndex = new Int32Array([\n        0,\n        1,\n        -1,\n        1,\n        -1,\n        0,\n        -1,\n        -1,\n        0,\n        -1,\n        1,\n        -1,\n        1,\n        0,\n        1,\n        1\n    ]);\n    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (-k + id - offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (k + id + offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #findContours(buf, width, height, threshold) {\n        const N = buf.length;\n        const types = new Int32Array(N);\n        for(let i = 0; i < N; i++){\n            types[i] = buf[i] <= threshold ? 1 : 0;\n        }\n        for(let i = 1; i < height - 1; i++){\n            types[i * width] = types[i * width + width - 1] = 0;\n        }\n        for(let i = 0; i < width; i++){\n            types[i] = types[width * height - 1 - i] = 0;\n        }\n        let nbd = 1;\n        let lnbd;\n        const contours = [];\n        for(let i = 1; i < height - 1; i++){\n            lnbd = 1;\n            for(let j = 1; j < width - 1; j++){\n                const ij = i * width + j;\n                const pix = types[ij];\n                if (pix === 0) {\n                    continue;\n                }\n                let i2 = i;\n                let j2 = j;\n                if (pix === 1 && types[ij - 1] === 0) {\n                    nbd += 1;\n                    j2 -= 1;\n                } else if (pix >= 1 && types[ij + 1] === 0) {\n                    nbd += 1;\n                    j2 += 1;\n                    if (pix > 1) {\n                        lnbd = pix;\n                    }\n                } else {\n                    if (pix !== 1) {\n                        lnbd = Math.abs(pix);\n                    }\n                    continue;\n                }\n                const points = [\n                    j,\n                    i\n                ];\n                const isHole = j2 === j + 1;\n                const contour = {\n                    isHole,\n                    points,\n                    id: nbd,\n                    parent: 0\n                };\n                contours.push(contour);\n                let contour0;\n                for (const c of contours){\n                    if (c.id === lnbd) {\n                        contour0 = c;\n                        break;\n                    }\n                }\n                if (!contour0) {\n                    contour.parent = isHole ? lnbd : 0;\n                } else if (contour0.isHole) {\n                    contour.parent = isHole ? contour0.parent : lnbd;\n                } else {\n                    contour.parent = isHole ? lnbd : contour0.parent;\n                }\n                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n                if (k === -1) {\n                    types[ij] = -nbd;\n                    if (types[ij] !== 1) {\n                        lnbd = Math.abs(types[ij]);\n                    }\n                    continue;\n                }\n                let shiftI = this.#neighborIdToIndex[2 * k];\n                let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n                const i1 = i + shiftI;\n                const j1 = j + shiftJ;\n                i2 = i1;\n                j2 = j1;\n                let i3 = i;\n                let j3 = j;\n                while(true){\n                    const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n                    shiftI = this.#neighborIdToIndex[2 * kk];\n                    shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n                    const i4 = i3 + shiftI;\n                    const j4 = j3 + shiftJ;\n                    points.push(j4, i4);\n                    const ij3 = i3 * width + j3;\n                    if (types[ij3 + 1] === 0) {\n                        types[ij3] = -nbd;\n                    } else if (types[ij3] === 1) {\n                        types[ij3] = nbd;\n                    }\n                    if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n                        if (types[ij] !== 1) {\n                            lnbd = Math.abs(types[ij]);\n                        }\n                        break;\n                    } else {\n                        i2 = i3;\n                        j2 = j3;\n                        i3 = i4;\n                        j3 = j4;\n                    }\n                }\n            }\n        }\n        return contours;\n    }\n    static #douglasPeuckerHelper(points, start, end, output) {\n        if (end - start <= 4) {\n            for(let i = start; i < end - 2; i += 2){\n                output.push(points[i], points[i + 1]);\n            }\n            return;\n        }\n        const ax = points[start];\n        const ay = points[start + 1];\n        const abx = points[end - 4] - ax;\n        const aby = points[end - 3] - ay;\n        const dist = Math.hypot(abx, aby);\n        const nabx = abx / dist;\n        const naby = aby / dist;\n        const aa = nabx * ay - naby * ax;\n        const m = aby / abx;\n        const invS = 1 / dist;\n        const phi = Math.atan(m);\n        const cosPhi = Math.cos(phi);\n        const sinPhi = Math.sin(phi);\n        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n        const poly = invS * (1 - tmax + tmax ** 2);\n        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n        let dmax = 0;\n        let index = start;\n        for(let i = start + 2; i < end - 2; i += 2){\n            const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n        if (dmax > (dist * partialPhi) ** 2) {\n            this.#douglasPeuckerHelper(points, start, index + 2, output);\n            this.#douglasPeuckerHelper(points, index, end, output);\n        } else {\n            output.push(ax, ay);\n        }\n    }\n    static #douglasPeucker(points) {\n        const output = [];\n        const len = points.length;\n        this.#douglasPeuckerHelper(points, 0, len, output);\n        output.push(points[len - 2], points[len - 1]);\n        return output.length <= 4 ? null : output;\n    }\n    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n        const kernel = new Float32Array(kernelSize ** 2);\n        const sigmaS2 = -2 * sigmaS ** 2;\n        const halfSize = kernelSize >> 1;\n        for(let i = 0; i < kernelSize; i++){\n            const x = (i - halfSize) ** 2;\n            for(let j = 0; j < kernelSize; j++){\n                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n            }\n        }\n        const rangeValues = new Float32Array(256);\n        const sigmaR2 = -2 * sigmaR ** 2;\n        for(let i = 0; i < 256; i++){\n            rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n        }\n        const N = buf.length;\n        const out = new Uint8Array(N);\n        const histogram = new Uint32Array(256);\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const ij = i * width + j;\n                const center = buf[ij];\n                let sum = 0;\n                let norm = 0;\n                for(let k = 0; k < kernelSize; k++){\n                    const y = i + k - halfSize;\n                    if (y < 0 || y >= height) {\n                        continue;\n                    }\n                    for(let l = 0; l < kernelSize; l++){\n                        const x = j + l - halfSize;\n                        if (x < 0 || x >= width) {\n                            continue;\n                        }\n                        const neighbour = buf[y * width + x];\n                        const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n                        sum += neighbour * w;\n                        norm += w;\n                    }\n                }\n                const pix = out[ij] = Math.round(sum / norm);\n                histogram[pix]++;\n            }\n        }\n        return [\n            out,\n            histogram\n        ];\n    }\n    static #getHistogram(buf) {\n        const histogram = new Uint32Array(256);\n        for (const g of buf){\n            histogram[g]++;\n        }\n        return histogram;\n    }\n    static #toUint8(buf) {\n        const N = buf.length;\n        const out = new Uint8ClampedArray(N >> 2);\n        let max = -Infinity;\n        let min = Infinity;\n        for(let i = 0, ii = out.length; i < ii; i++){\n            const pix = out[i] = buf[i << 2];\n            max = Math.max(max, pix);\n            min = Math.min(min, pix);\n        }\n        const ratio = 255 / (max - min);\n        for(let i = 0, ii = out.length; i < ii; i++){\n            out[i] = (out[i] - min) * ratio;\n        }\n        return out;\n    }\n    static #guessThreshold(histogram) {\n        let i;\n        let M = -Infinity;\n        let L = -Infinity;\n        const min = histogram.findIndex((v)=>v !== 0);\n        let pos = min;\n        let spos = min;\n        for(i = min; i < 256; i++){\n            const v = histogram[i];\n            if (v > M) {\n                if (i - pos > L) {\n                    L = i - pos;\n                    spos = i - 1;\n                }\n                M = v;\n                pos = i;\n            }\n        }\n        for(i = spos - 1; i >= 0; i--){\n            if (histogram[i] > histogram[i + 1]) {\n                break;\n            }\n        }\n        return i;\n    }\n    static #getGrayPixels(bitmap) {\n        const originalBitmap = bitmap;\n        const { width, height } = bitmap;\n        const { maxDim } = this.#PARAMETERS;\n        let newWidth = width;\n        let newHeight = height;\n        if (width > maxDim || height > maxDim) {\n            let prevWidth = width;\n            let prevHeight = height;\n            let steps = Math.log2(Math.max(width, height) / maxDim);\n            const isteps = Math.floor(steps);\n            steps = steps === isteps ? isteps - 1 : isteps;\n            for(let i = 0; i < steps; i++){\n                newWidth = Math.ceil(prevWidth / 2);\n                newHeight = Math.ceil(prevHeight / 2);\n                const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                const ctx = offscreen.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                prevWidth = newWidth;\n                prevHeight = newHeight;\n                if (bitmap !== originalBitmap) {\n                    bitmap.close();\n                }\n                bitmap = offscreen.transferToImageBitmap();\n            }\n            const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n            newWidth = Math.round(newWidth * ratio);\n            newHeight = Math.round(newHeight * ratio);\n        }\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, newWidth, newHeight);\n        ctx.filter = \"grayscale(1)\";\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n        const uint8Buf = this.#toUint8(grayImage);\n        return [\n            uint8Buf,\n            newWidth,\n            newHeight\n        ];\n    }\n    static extractContoursFromText(text, { fontFamily, fontStyle, fontWeight }, pageWidth, pageHeight, rotation, innerMargin) {\n        let canvas = new OffscreenCanvas(1, 1);\n        let ctx = canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        const fontSize = 200;\n        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const { actualBoundingBoxLeft, actualBoundingBoxRight, actualBoundingBoxAscent, actualBoundingBoxDescent, fontBoundingBoxAscent, fontBoundingBoxDescent, width } = ctx.measureText(text);\n        const SCALE = 1.5;\n        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n        ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            willReadFrequently: true\n        });\n        ctx.font = font;\n        ctx.filter = \"grayscale(1)\";\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = \"black\";\n        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n        const histogram = this.#getHistogram(uint8Buf);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(buffer, width, height, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width,\n                height\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static processDrawnLines({ lines, pageWidth, pageHeight, rotation, innerMargin, mustSmooth, areContours }) {\n        if (rotation % 180 !== 0) {\n            [pageWidth, pageHeight] = [\n                pageHeight,\n                pageWidth\n            ];\n        }\n        const { curves, width, height } = lines;\n        const thickness = lines.thickness ?? 0;\n        const linesAndPoints = [];\n        const ratio = Math.min(pageWidth / width, pageHeight / height);\n        const xScale = ratio / pageWidth;\n        const yScale = ratio / pageHeight;\n        const newCurves = [];\n        for (const { points } of curves){\n            const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n            if (!reducedPoints) {\n                continue;\n            }\n            newCurves.push(reducedPoints);\n            const len = reducedPoints.length;\n            const newPoints = new Float32Array(len);\n            const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n            linesAndPoints.push({\n                line,\n                points: newPoints\n            });\n            if (len === 2) {\n                newPoints[0] = reducedPoints[0] * xScale;\n                newPoints[1] = reducedPoints[1] * yScale;\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    newPoints[0],\n                    newPoints[1]\n                ], 0);\n                continue;\n            }\n            let [x1, y1, x2, y2] = reducedPoints;\n            x1 *= xScale;\n            y1 *= yScale;\n            x2 *= xScale;\n            y2 *= yScale;\n            newPoints.set([\n                x1,\n                y1,\n                x2,\n                y2\n            ], 0);\n            line.set([\n                NaN,\n                NaN,\n                NaN,\n                NaN,\n                x1,\n                y1\n            ], 0);\n            for(let i = 4; i < len; i += 2){\n                const x = newPoints[i] = reducedPoints[i] * xScale;\n                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                [x1, y1, x2, y2] = [\n                    x2,\n                    y2,\n                    x,\n                    y\n                ];\n            }\n        }\n        if (linesAndPoints.length === 0) {\n            return null;\n        }\n        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n        return {\n            outline,\n            newCurves,\n            areContours,\n            thickness,\n            width,\n            height\n        };\n    }\n    static async compressSignature({ outlines, areContours, thickness, width, height }) {\n        let minDiff = Infinity;\n        let maxDiff = -Infinity;\n        let outlinesLength = 0;\n        for (const points of outlines){\n            outlinesLength += points.length;\n            for(let i = 2, ii = points.length; i < ii; i++){\n                const dx = points[i] - points[i - 2];\n                minDiff = Math.min(minDiff, dx);\n                maxDiff = Math.max(maxDiff, dx);\n            }\n        }\n        let bufferType;\n        if (minDiff >= -128 && maxDiff <= 127) {\n            bufferType = Int8Array;\n        } else if (minDiff >= -32768 && maxDiff <= 32767) {\n            bufferType = Int16Array;\n        } else {\n            bufferType = Int32Array;\n        }\n        const len = outlines.length;\n        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n        const header = new Uint32Array(headerLength);\n        let offset = 0;\n        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n        header[offset++] = 0;\n        header[offset++] = width;\n        header[offset++] = height;\n        header[offset++] = areContours ? 0 : 1;\n        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n        header[offset++] = len;\n        header[offset++] = bufferType.BYTES_PER_ELEMENT;\n        for (const points of outlines){\n            header[offset++] = points.length - 2;\n            header[offset++] = points[0];\n            header[offset++] = points[1];\n        }\n        const cs = new CompressionStream(\"deflate-raw\");\n        const writer = cs.writable.getWriter();\n        await writer.ready;\n        writer.write(header);\n        const BufferCtor = bufferType.prototype.constructor;\n        for (const points of outlines){\n            const diffs = new BufferCtor(points.length - 2);\n            for(let i = 2, ii = points.length; i < ii; i++){\n                diffs[i - 2] = points[i] - points[i - 2];\n            }\n            writer.write(diffs);\n        }\n        writer.close();\n        const buf = await new Response(cs.readable).arrayBuffer();\n        const bytes = new Uint8Array(buf);\n        return toBase64Util(bytes);\n    }\n    static async decompressSignature(signatureData) {\n        try {\n            const bytes = fromBase64Util(signatureData);\n            const { readable, writable } = new DecompressionStream(\"deflate-raw\");\n            const writer = writable.getWriter();\n            await writer.ready;\n            writer.write(bytes).then(async ()=>{\n                await writer.ready;\n                await writer.close();\n            }).catch(()=>{});\n            let data = null;\n            let offset = 0;\n            for await (const chunk of readable){\n                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n                data.set(chunk, offset);\n                offset += chunk.length;\n            }\n            const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n            const version = header[1];\n            if (version !== 0) {\n                throw new Error(`Invalid version: ${version}`);\n            }\n            const width = header[2];\n            const height = header[3];\n            const areContours = header[4] === 0;\n            const thickness = header[5];\n            const numberOfDrawings = header[6];\n            const bufferType = header[7];\n            const outlines = [];\n            const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n            let diffs;\n            switch(bufferType){\n                case Int8Array.BYTES_PER_ELEMENT:\n                    diffs = new Int8Array(data.buffer, diffsOffset);\n                    break;\n                case Int16Array.BYTES_PER_ELEMENT:\n                    diffs = new Int16Array(data.buffer, diffsOffset);\n                    break;\n                case Int32Array.BYTES_PER_ELEMENT:\n                    diffs = new Int32Array(data.buffer, diffsOffset);\n                    break;\n            }\n            offset = 0;\n            for(let i = 0; i < numberOfDrawings; i++){\n                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n                const points = new Float32Array(len + 2);\n                outlines.push(points);\n                for(let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++){\n                    points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n                }\n                for(let j = 0; j < len; j++){\n                    points[j + 2] = points[j] + diffs[offset++];\n                }\n            }\n            return {\n                areContours,\n                thickness,\n                outlines,\n                width,\n                height\n            };\n        } catch (e) {\n            warn(`decompressSignature: ${e}`);\n            return null;\n        }\n    }\n}\n; // ./src/display/editor/signature.js\nclass SignatureOptions extends DrawingOptions {\n    constructor(){\n        super();\n        super.updateProperties({\n            fill: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 0\n        });\n    }\n    clone() {\n        const clone = new SignatureOptions();\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n    constructor(viewerParameters){\n        super(viewerParameters);\n        super.updateProperties({\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 1\n        });\n    }\n    clone() {\n        const clone = new DrawnSignatureOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass SignatureEditor extends DrawingEditor {\n    #isExtracted;\n    #description;\n    #signatureData;\n    #signatureUUID;\n    static{\n        this._type = \"signature\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.SIGNATURE;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            mustBeCommitted: true,\n            name: \"signatureEditor\"\n        });\n        this.#isExtracted = false;\n        this.#description = null;\n        this.#signatureData = null;\n        this.#signatureUUID = null;\n        this._willKeepAspectRatio = true;\n        this.#signatureData = params.signatureData || null;\n        this.#description = null;\n        this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new SignatureOptions();\n        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map());\n    }\n    static get isDrawer() {\n        return false;\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"signature\",\n            hasDescription: !!this.#description\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasDescriptionStats = data.get(\"hasDescription\");\n        return {\n            hasAltText: hasDescriptionStats.get(true) ?? 0,\n            hasNoAltText: hasDescriptionStats.get(false) ?? 0\n        };\n    }\n    get isResizable() {\n        return true;\n    }\n    onScaleChanging() {\n        if (this._drawId === null) {\n            return;\n        }\n        super.onScaleChanging();\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        const { _isCopy } = this;\n        if (_isCopy) {\n            this._isCopy = false;\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        if (this._drawId === null) {\n            if (this.#signatureData) {\n                const { lines, mustSmooth, areContours, description, uuid, heightInPage } = this.#signatureData;\n                const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n                const outline = SignatureExtractor.processDrawnLines({\n                    lines,\n                    pageWidth,\n                    pageHeight,\n                    rotation,\n                    innerMargin: SignatureEditor._INNER_MARGIN,\n                    mustSmooth,\n                    areContours\n                });\n                this.addSignature(outline, heightInPage, description, uuid);\n            } else {\n                this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    description: \"\"\n                }));\n                this.div.hidden = true;\n                this._uiManager.getSignature(this);\n            }\n        } else {\n            this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                description: this.#description || \"\"\n            }));\n        }\n        if (_isCopy) {\n            this._isCopy = true;\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return this.div;\n    }\n    setUuid(uuid) {\n        this.#signatureUUID = uuid;\n        this.addEditToolbar();\n    }\n    getUuid() {\n        return this.#signatureUUID;\n    }\n    get description() {\n        return this.#description;\n    }\n    set description(description) {\n        this.#description = description;\n        if (!this.div) {\n            return;\n        }\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n            description\n        }));\n        super.addEditToolbar().then((toolbar)=>{\n            toolbar?.updateEditSignatureButton(description);\n        });\n    }\n    getSignaturePreview() {\n        const { newCurves, areContours, thickness, width, height } = this.#signatureData;\n        const maxDim = Math.max(width, height);\n        const outlineData = SignatureExtractor.processDrawnLines({\n            lines: {\n                curves: newCurves.map((points)=>({\n                        points\n                    })),\n                thickness,\n                width,\n                height\n            },\n            pageWidth: maxDim,\n            pageHeight: maxDim,\n            rotation: 0,\n            innerMargin: 0,\n            mustSmooth: false,\n            areContours\n        });\n        return {\n            areContours,\n            outline: outlineData.outline\n        };\n    }\n    get toolbarButtons() {\n        if (this._uiManager.signatureManager) {\n            return [\n                [\n                    \"editSignature\",\n                    this._uiManager.signatureManager\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    addSignature(data, heightInPage, description, uuid) {\n        const { x: savedX, y: savedY } = this;\n        const { outline } = this.#signatureData = data;\n        this.#isExtracted = outline instanceof ContourDrawOutline;\n        this.description = description;\n        let drawingOptions;\n        if (this.#isExtracted) {\n            drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            drawingOptions.updateProperties({\n                \"stroke-width\": outline.thickness\n            });\n        }\n        this._addOutlines({\n            drawOutlines: outline,\n            drawingOptions\n        });\n        const [, pageHeight] = this.pageDimensions;\n        let newHeight = heightInPage / pageHeight;\n        newHeight = newHeight >= 1 ? 0.5 : newHeight;\n        this.width *= newHeight / this.height;\n        if (this.width >= 1) {\n            newHeight *= 0.9 / this.width;\n            this.width = 0.9;\n        }\n        this.height = newHeight;\n        this.setDims();\n        this.x = savedX;\n        this.y = savedY;\n        this.center();\n        this._onResized();\n        this.onScaleChanging();\n        this.rotate();\n        this._uiManager.addToAnnotationStorage(this);\n        this.setUuid(uuid);\n        this._reportTelemetry({\n            action: \"pdfjs.signature.inserted\",\n            data: {\n                hasBeenSaved: !!uuid,\n                hasDescription: !!description\n            }\n        });\n        this.div.hidden = false;\n    }\n    getFromImage(bitmap) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getFromText(text, fontInfo) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getDrawnSignature(curves) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.processDrawnLines({\n            lines: curves,\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin: SignatureEditor._INNER_MARGIN,\n            mustSmooth: false,\n            areContours: false\n        });\n    }\n    createDrawingOptions({ areContours, thickness }) {\n        if (areContours) {\n            this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            this._drawingOptions.updateProperties({\n                \"stroke-width\": thickness\n            });\n        }\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            isSignature: true,\n            areContours: this.#isExtracted,\n            color: [\n                0,\n                0,\n                0\n            ],\n            thickness: this.#isExtracted ? 0 : thickness\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.paths = {\n                lines,\n                points\n            };\n            serialized.uuid = this.#signatureUUID;\n            serialized.isCopy = true;\n        } else {\n            serialized.lines = lines;\n        }\n        if (this.#description) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: this.#description\n            };\n        }\n        return serialized;\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        if (data.areContours) {\n            return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n        }\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#isExtracted = data.areContours;\n        editor.description = data.accessibilityData?.alt || \"\";\n        editor.#signatureUUID = data.uuid;\n        return editor;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #missingCanvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#missingCanvas = false;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n        this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static isHandlingMimeForPasting(mime) {\n        return SupportedImageMimeTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor({\n            mode: AnnotationEditorType.STAMP\n        }, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this.addEditToolbar().then(()=>{\n                this._editToolbar.hide();\n                this._uiManager.editAltText(this, true);\n            });\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = SupportedImageMimeTypes.join(\",\");\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n    }\n    get toolbarButtons() {\n        return [\n            [\n                \"altText\",\n                this.createAltText()\n            ]\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.createAltText();\n        if (!this.#missingCanvas) {\n            if (this.#bitmap) {\n                this.#createCanvas();\n            } else {\n                this.#getBitmap();\n            }\n        }\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    setCanvas(annotationElementId, canvas) {\n        const { id: bitmapId, bitmap } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n        canvas.remove();\n        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n            this.#bitmapId = bitmapId;\n            if (bitmap) {\n                this.#bitmap = bitmap;\n            }\n            this.#missingCanvas = false;\n            this.#createCanvas();\n        }\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        this.setDims();\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (ColorScheme.isDarkMode) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        let missingCanvas = false;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef, richText, contentsObj, creationDate, modificationDate }, container, parent: { page: { pageNumber } }, canvas } = data;\n            let bitmapId, bitmap;\n            if (canvas) {\n                delete data.canvas;\n                ({ id: bitmapId, bitmap } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n                canvas.remove();\n            } else {\n                missingCanvas = true;\n                data._hasNoCanvas = true;\n            }\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId,\n                bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (missingCanvas) {\n            uiManager.addMissingCanvas(data.id, editor);\n            editor.#missingCanvas = true;\n        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            bitmapId: this.#bitmapId,\n            isSvg: this.#isSvg\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            serialized.isCopy = true;\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n            serialized.id = this.annotationElementId;\n            delete serialized.bitmapId;\n            return serialized;\n        }\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #textLayerDblClickAC;\n    #lastPointerDownTimestamp;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor,\n        SignatureEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        this.#textLayerDblClickAC = null;\n        this.#lastPointerDownTimestamp = -1;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(options) {\n        this.#uiManager.updateToolbar(options);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.div.classList.toggle(\"nonEditing\", true);\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        classList.toggle(\"nonEditing\", false);\n        if (mode === AnnotationEditorType.POPUP) {\n            classList.toggle(\"commentEditing\", true);\n        } else {\n            classList.toggle(\"commentEditing\", false);\n            for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n                classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n            }\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    get #allEditorsIterator() {\n        return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        this.div.classList.toggle(\"nonEditing\", false);\n        this.#textLayerDblClickAC?.abort();\n        this.#textLayerDblClickAC = null;\n        const annotationElementIds = new Set();\n        for (const editor of this.#allEditorsIterator){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            for (const editable of annotationLayer.getEditableAnnotations()){\n                editable.hide();\n                if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                    continue;\n                }\n                if (annotationElementIds.has(editable.data.id)) {\n                    continue;\n                }\n                const editor = await this.deserialize(editable);\n                if (!editor) {\n                    continue;\n                }\n                this.addOrRebuild(editor);\n                editor.enableEditing();\n            }\n        }\n        this.#isEnabling = false;\n        this.#uiManager._eventBus.dispatch(\"editorsrendered\", {\n            source: this,\n            pageNumber: this.pageIndex + 1\n        });\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        this.div.classList.toggle(\"nonEditing\", true);\n        if (this.#textLayer && !this.#textLayerDblClickAC) {\n            this.#textLayerDblClickAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", (e)=>{\n                const DBL_CLICK_THRESHOLD = 500;\n                const { clientX, clientY, timeStamp } = e;\n                const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n                if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n                    this.#lastPointerDownTimestamp = timeStamp;\n                    return;\n                }\n                this.#lastPointerDownTimestamp = -1;\n                const { classList } = this.div;\n                classList.toggle(\"getElements\", true);\n                const elements = document.elementsFromPoint(clientX, clientY);\n                classList.toggle(\"getElements\", false);\n                if (!this.div.contains(elements[0])) {\n                    return;\n                }\n                let id;\n                const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n                for (const element of elements){\n                    if (regex.test(element.id)) {\n                        id = element.id;\n                        break;\n                    }\n                }\n                if (!id) {\n                    return;\n                }\n                const editor = this.#editors.get(id);\n                if (editor?.annotationElementId === null) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.dblclick(e);\n                }\n            }, {\n                signal,\n                capture: true\n            });\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            const changedAnnotations = new Map();\n            const resetAnnotations = new Map();\n            for (const editor of this.#allEditorsIterator){\n                editor.disableEditing();\n                if (!editor.annotationElementId) {\n                    editor.updateFakeAnnotationElement(annotationLayer);\n                    continue;\n                }\n                if (editor.serialize() !== null) {\n                    changedAnnotations.set(editor.annotationElementId, editor);\n                    continue;\n                } else {\n                    resetAnnotations.set(editor.annotationElementId, editor);\n                }\n                this.getEditableAnnotation(editor.annotationElementId)?.show();\n                editor.remove();\n            }\n            const editables = annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    editable.updateEdited({\n                        deleted: true\n                    });\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getEditorByUID(uid) {\n        for (const editor of this.#editors.values()){\n            if (editor.uid === uid) {\n                return editor;\n            }\n        }\n        return null;\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    async pasteEditor(options, params) {\n        this.updateToolbar(options);\n        await this.#uiManager.updateMode(options.mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    get boundingClientRect() {\n        return this.div.getBoundingClientRect();\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.boundingClientRect;\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor(data = {}) {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        const currentMode = this.#uiManager.getMode();\n        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus({\n            preventScroll: true\n        });\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #mapping;\n    #toUpdate;\n    static #id = 0;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\n{\n    globalThis._pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}globalThis.pdfjsLib = {\n    AbortException: AbortException,\n    AnnotationEditorLayer: AnnotationEditorLayer,\n    AnnotationEditorParamsType: AnnotationEditorParamsType,\n    AnnotationEditorType: AnnotationEditorType,\n    AnnotationEditorUIManager: AnnotationEditorUIManager,\n    AnnotationLayer: AnnotationLayer,\n    AnnotationMode: AnnotationMode,\n    AnnotationType: AnnotationType,\n    applyOpacity: applyOpacity,\n    build: build,\n    ColorPicker: ColorPicker,\n    createValidAbsoluteUrl: createValidAbsoluteUrl,\n    CSSConstants: CSSConstants,\n    DOMSVGFactory: DOMSVGFactory,\n    DrawLayer: DrawLayer,\n    FeatureTest: util_FeatureTest,\n    fetchData: fetchData,\n    findContrastColor: findContrastColor,\n    getDocument: getDocument,\n    getFilenameFromUrl: getFilenameFromUrl,\n    getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n    getRGB: getRGB,\n    getUuid: getUuid,\n    getXfaPageViewport: getXfaPageViewport,\n    GlobalWorkerOptions: GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException: InvalidPDFException,\n    isDataScheme: isDataScheme,\n    isPdfFile: isPdfFile,\n    isValidExplicitDest: isValidExplicitDest,\n    MathClamp: MathClamp,\n    noContextMenu: noContextMenu,\n    normalizeUnicode: normalizeUnicode,\n    OPS: OPS,\n    OutputScale: OutputScale,\n    PasswordResponses: PasswordResponses,\n    PDFDataRangeTransport: PDFDataRangeTransport,\n    PDFDateString: PDFDateString,\n    PDFWorker: PDFWorker,\n    PermissionFlag: PermissionFlag,\n    PixelsPerInch: PixelsPerInch,\n    RenderingCancelledException: RenderingCancelledException,\n    renderRichText: renderRichText,\n    ResponseException: ResponseException,\n    setLayerDimensions: setLayerDimensions,\n    shadow: shadow,\n    SignatureExtractor: SignatureExtractor,\n    stopEvent: stopEvent,\n    SupportedImageMimeTypes: SupportedImageMimeTypes,\n    TextLayer: TextLayer,\n    TouchManager: TouchManager,\n    updateUrlHash: updateUrlHash,\n    Util: Util,\n    VerbosityLevel: VerbosityLevel,\n    version: version,\n    XfaLayer: XfaLayer\n};\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9sZWdhY3kvYnVpbGQvcGRmLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVEOzs7Q0FHQyxHQUNELE1BQU0sR0FBRyxJQUFJQSxzQkFBdUI7SUFFcEMsR0FBRyxHQUFHLElBQ04sR0FBRyxHQUFJLENBQUNDLFFBQVFDLDBCQUEwQkMsOEJBQW1CQTtRQUc3RCxJQUFJQyxhQUFhRCw4QkFBbUJBLENBQUM7UUFFckNGLE9BQU9JLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1lBQzNCLE9BQU8sT0FBT0EsTUFBTSxXQUFXQSxPQUFPLE9BQU9GLFdBQVdFO1FBQzFEO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLElBQ04sR0FBRyxHQUFJLENBQUNMLFFBQVFDLDBCQUEwQkMsK0JBQW1CQTtRQUc3RCxJQUFJSSxPQUFPSiwrQkFBbUJBLENBQUM7UUFDL0IsSUFBSUssWUFBWUwsK0JBQW1CQSxDQUFDO1FBQ3BDLElBQUlNLFdBQVdOLCtCQUFtQkEsQ0FBQztRQUNuQyxJQUFJTyxjQUFjUCwrQkFBbUJBLENBQUM7UUFDdEMsSUFBSVEsb0JBQW9CUiwrQkFBbUJBLENBQUM7UUFFNUMsSUFBSVMsYUFBYUM7UUFFakJaLE9BQU9JLE9BQU8sR0FBRyxTQUFVUyxRQUFRLEVBQUVDLGFBQWE7WUFDaEQsSUFBSUMsaUJBQWlCQyxVQUFVQyxNQUFNLEdBQUcsSUFBSVAsa0JBQWtCRyxZQUFZQztZQUMxRSxJQUFJUCxVQUFVUSxpQkFBaUIsT0FBT1AsU0FBU0YsS0FBS1MsZ0JBQWdCRjtZQUNwRSxNQUFNLElBQUlGLFdBQVdGLFlBQVlJLFlBQVk7UUFDL0M7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ0sseUJBQXlCakIsMEJBQTBCQywr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QUNQQyxhQUFhQTtJQUNibnRGLHdCQUF3QkE7SUFDeEJrWixjQUFjQTtJQUNkazRFLGVBQWVBO0lBQ2Z1MkIsV0FBV0E7SUFDWGx6RCxhQUFhbHlEO0lBQ2I4TixXQUFXQTtJQUNYZ0ssbUJBQW1CQTtJQUNuQm9qRSxhQUFhQTtJQUNiL3BFLG9CQUFvQkE7SUFDcEJFLHVCQUF1QkE7SUFDdkJzQyxRQUFRQTtJQUNSMUwsU0FBU0E7SUFDVHdMLG9CQUFvQkE7SUFDcEJ1MkQscUJBQXFCQTtJQUNyQjdZLFdBQVc3L0Q7SUFDWHNOLHFCQUFxQkE7SUFDckJrUyxjQUFjQTtJQUNkRyxXQUFXQTtJQUNYNG5DLHFCQUFxQkE7SUFDckI5dkMsV0FBV0E7SUFDWHVKLGVBQWVBO0lBQ2Z6SyxrQkFBa0JBO0lBQ2xCbFIsS0FBS0E7SUFDTHdlLGFBQWFBO0lBQ2IzWSxtQkFBbUJBO0lBQ25CKytFLHVCQUF1QkE7SUFDdkIzb0UsZUFBZUE7SUFDZjZvRSxXQUFXQTtJQUNYdHJGLGdCQUFnQkE7SUFDaEJ3ZCxlQUFlQTtJQUNmaUQsNkJBQTZCQTtJQUM3QjRILGdCQUFnQkE7SUFDaEIzWixtQkFBbUJBO0lBQ25COFYsb0JBQW9CQTtJQUNwQnZXLFFBQVFBO0lBQ1IrNEcsb0JBQW9CQTtJQUNwQjNrRyxXQUFXQTtJQUNYK0QseUJBQXlCQTtJQUN6QmtoRSxXQUFXQTtJQUNYMzZDLGNBQWNBO0lBQ2Q3K0IsZUFBZUE7SUFDZitDLE1BQU1BO0lBQ056SyxnQkFBZ0JBO0lBQ2hCdGtCLFNBQVNBO0lBQ1Q0NEIsVUFBVUE7QUFDWjtBQUV3NkIsQ0FFeDZCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4cGVuc2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2xlZ2FjeS9idWlsZC9wZGYubWpzP2E0NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyNCBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqXG4gKiBwZGZqc1ZlcnNpb24gPSA1LjQuMjk2XG4gKiBwZGZqc0J1aWxkID0gZjU2ZGM4NjAxXG4gKi9cbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gMzQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciB0cnlUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyMyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MSk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QoY2FsbChpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjUyKTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG5cbnZhciBmaW5kV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdmaW5kJywgVHlwZUVycm9yKTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5maW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmZpbmRcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IGZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZmluZFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmaW5kV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHByZWRpY2F0ZSk7XG5cbiAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiBpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24gKHZhbHVlLCBzdG9wKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBjb3VudGVyKyspKSByZXR1cm4gc3RvcCh2YWx1ZSk7XG4gICAgfSwgeyBJU19SRUNPUkQ6IHRydWUsIElOVEVSUlVQVEVEOiB0cnVlIH0pLnJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI4Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDM1MCkuQ09ORklHVVJBQkxFKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzA2KTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTgxKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoc3RyaW5nU2xpY2UoJFN0cmluZyhuYW1lKSwgMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyByZXBsYWNlKCRTdHJpbmcobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS4qJC8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093bihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gam9pbihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093bihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgKERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzOTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ1Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgYW5VaW50OEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTU0KTtcbnZhciBub3REZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2OSk7XG5cbnZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMS50b1N0cmluZyk7XG5cbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsVGhpcy5VaW50OEFycmF5O1xuXG52YXIgSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgPSAhVWludDhBcnJheSB8fCAhVWludDhBcnJheS5wcm90b3R5cGUudG9IZXggfHwgIShmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHRhcmdldCA9IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NV0pO1xuICAgIHJldHVybiB0YXJnZXQudG9IZXgoKSA9PT0gJ2ZmZmZmZmZmZmZmZmZmZmYnO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gYFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvSGV4YCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5YnVmZmVyLWJhc2U2NFxuaWYgKFVpbnQ4QXJyYXkpICQoeyB0YXJnZXQ6ICdVaW50OEFycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgfSwge1xuICB0b0hleDogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgYW5VaW50OEFycmF5KHRoaXMpO1xuICAgIG5vdERldGFjaGVkKHRoaXMuYnVmZmVyKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZXggPSBudW1iZXJUb1N0cmluZyh0aGlzW2ldLCAxNik7XG4gICAgICByZXN1bHQgKz0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlY29yZCwgZm4sIElURVJBVE9SX0lOU1RFQURfT0ZfUkVDT1JEKSB7XG4gIHZhciBpdGVyYXRvciA9IElURVJBVE9SX0lOU1RFQURfT0ZfUkVDT1JEID8gcmVjb3JkIDogcmVjb3JkLml0ZXJhdG9yO1xuICB2YXIgbmV4dCA9IHJlY29yZC5uZXh0O1xuICB2YXIgc3RlcCwgcmVzdWx0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICByZXN1bHQgPSBmbihzdGVwLnZhbHVlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgZ2V0SXRlcmF0b3JGbGF0dGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODY0Nik7XG52YXIgY3JlYXRlSXRlcmF0b3JQcm94eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQ2Mik7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG52YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcblxudmFyIEZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFXG4gICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKCdmbGF0TWFwJywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbnZhciBmbGF0TWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhRkxBVF9NQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SXG4gICYmIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ2ZsYXRNYXAnLCBUeXBlRXJyb3IpO1xuXG52YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBGTEFUX01BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgfHwgZmxhdE1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yO1xuXG52YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICB2YXIgbWFwcGVyID0gdGhpcy5tYXBwZXI7XG4gIHZhciByZXN1bHQsIGlubmVyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGlubmVyID0gdGhpcy5pbm5lcikgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwoaW5uZXIubmV4dCwgaW5uZXIuaXRlcmF0b3IpKTtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikgeyBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7IH1cblxuICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwodGhpcy5uZXh0LCBpdGVyYXRvcikpO1xuXG4gICAgaWYgKHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmUpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmlubmVyID0gZ2V0SXRlcmF0b3JGbGF0dGVuYWJsZShtYXBwZXIocmVzdWx0LnZhbHVlLCB0aGlzLmNvdW50ZXIrKyksIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7IH1cbiAgfVxufSk7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUuZmxhdE1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5mbGF0bWFwXG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKG1hcHBlcikge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUobWFwcGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZmxhdE1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBtYXBwZXIpO1xuXG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvclByb3h5KGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpLCB7XG4gICAgICBtYXBwZXI6IG1hcHBlcixcbiAgICAgIGlubmVyOiBudWxsXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1NSk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Nzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MjUpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZihQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gU2hvdWxkIHRocm93IGFuIGVycm9yIG9uIGludmFsaWQgaXRlcmF0b3Jcbi8vIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvMzM2ODM5MTE1XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmd1bWVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8taXRlcmF0b3IgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIG1ldGhvZCA9IHR5cGVvZiBJdGVyYXRvciA9PSAnZnVuY3Rpb24nICYmIEl0ZXJhdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgaWYgKG1ldGhvZCkgdHJ5IHtcbiAgICBtZXRob2QuY2FsbCh7IG5leHQ6IG51bGwgfSwgYXJndW1lbnQpLm5leHQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MjUpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDQwKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU1KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjYpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTE3KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyNjkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdCkpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SKVxuICAgIHx8IGdldE1ldGhvZChpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDQ6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBhbHBoYWJldCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbHBoYWJldDtcbiAgaWYgKGFscGhhYmV0ID09PSB1bmRlZmluZWQgfHwgYWxwaGFiZXQgPT09ICdiYXNlNjQnIHx8IGFscGhhYmV0ID09PSAnYmFzZTY0dXJsJykgcmV0dXJuIGFscGhhYmV0IHx8ICdiYXNlNjQnO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcignSW5jb3JyZWN0IGBhbHBoYWJldGAgb3B0aW9uJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDcyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MjgpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzI3KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExMDM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExMDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnQmlnSW50NjRBcnJheScgfHwga2xhc3MgPT09ICdCaWdVaW50NjRBcnJheSc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTQ4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NTIpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcblxudmFyIGV2ZXJ5V2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdldmVyeScsIFR5cGVFcnJvcik7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvci5wcm90b3R5cGUuZXZlcnlcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IGV2ZXJ5V2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcblxuICAgIHZhciByZWNvcmQgPSBnZXRJdGVyYXRvckRpcmVjdCh0aGlzKTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgcmV0dXJuICFpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24gKHZhbHVlLCBzdG9wKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSh2YWx1ZSwgY291bnRlcisrKSkgcmV0dXJuIHN0b3AoKTtcbiAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSwgSU5URVJSVVBURUQ6IHRydWUgfSkuc3RvcHBlZDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExODE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oODYyMik7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2OTkpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjI5KTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMTkpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMSk7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsVGhpcy5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbFRoaXMuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHN0b3JlLnNldChpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldChpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBzdG9yZS5oYXMoaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdHJ1bmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MSk7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTM4NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJzLCBraW5kLCB2YWx1ZSkge1xuICBmb3IgKHZhciBpID0gaXRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoaXRlcnNbaV0gPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gaXRlcmF0b3JDbG9zZShpdGVyc1tpXS5pdGVyYXRvciwga2luZCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBraW5kID0gJ3Rocm93JztcbiAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgfVxuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU0ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIFY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTE5KTtcbnZhciBFTlZJUk9OTUVOVCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIxNSk7XG5cbnZhciBzdHJ1Y3R1cmVkQ2xvbmUgPSBnbG9iYWxUaGlzLnN0cnVjdHVyZWRDbG9uZTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIXN0cnVjdHVyZWRDbG9uZSAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBwcmV2ZW50IFY4IEFycmF5QnVmZmVyRGV0YWNoaW5nIHByb3RlY3RvciBjZWxsIGludmFsaWRhdGlvbiBhbmQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxuICBpZiAoKEVOVklST05NRU5UID09PSAnREVOTycgJiYgVjggPiA5MikgfHwgKEVOVklST05NRU5UID09PSAnTk9ERScgJiYgVjggPiA5NCkgfHwgKEVOVklST05NRU5UID09PSAnQlJPV1NFUicgJiYgVjggPiA5NykpIHJldHVybiBmYWxzZTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgdmFyIGNsb25lID0gc3RydWN0dXJlZENsb25lKGJ1ZmZlciwgeyB0cmFuc2ZlcjogW2J1ZmZlcl0gfSk7XG4gIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aCAhPT0gMCB8fCBjbG9uZS5ieXRlTGVuZ3RoICE9PSA4O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1NDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXyg2NjMyKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTYyNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKHt9LmlzUHJvdG90eXBlT2YpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjg5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGFwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzQ1KTtcbnZhciBzbGljZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY4MCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwNDMpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgcGVyZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwMyk7XG5cbnZhciBQcm9taXNlID0gZ2xvYmFsVGhpcy5Qcm9taXNlO1xuXG52YXIgQUNDRVBUX0FSR1VNRU5UUyA9IGZhbHNlO1xuLy8gQXZvaWRpbmcgdGhlIHVzZSBvZiBwb2x5ZmlsbHMgb2YgdGhlIHByZXZpb3VzIGl0ZXJhdGlvbiBvZiB0aGlzIHByb3Bvc2FsXG4vLyB0aGF0IGRvZXMgbm90IGFjY2VwdCBhcmd1bWVudHMgb2YgdGhlIGNhbGxiYWNrXG52YXIgRk9SQ0VEID0gIVByb21pc2UgfHwgIVByb21pc2VbJ3RyeSddIHx8IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICBQcm9taXNlWyd0cnknXShmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICBBQ0NFUFRfQVJHVU1FTlRTID0gYXJndW1lbnQgPT09IDg7XG4gIH0sIDgpO1xufSkuZXJyb3IgfHwgIUFDQ0VQVF9BUkdVTUVOVFM7XG5cbi8vIGBQcm9taXNlLnRyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UudHJ5XG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZShhcmd1bWVudHMsIDEpIDogW107XG4gICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXBwbHkoYUNhbGxhYmxlKGNhbGxiYWNrZm4pLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICAgIChyZXN1bHQuZXJyb3IgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY5ODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciB1bmlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDIwNCk7XG52YXIgc2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MzUpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgRk9SQ0VEID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ3VuaW9uJykgfHwgIXNldE1ldGhvZEdldEtleXNCZWZvcmVDbG9uaW5nKCd1bmlvbicpO1xuXG4vLyBgU2V0LnByb3RvdHlwZS51bmlvbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUudW5pb25cbiQoeyB0YXJnZXQ6ICdTZXQnLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICB1bmlvbjogdW5pb25cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzAxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDYyKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzE5KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODQpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xuXG52YXIgTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKCdtYXAnLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xudmFyIG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgIU1BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1JcbiAgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignbWFwJywgVHlwZUVycm9yKTtcblxudmFyIEZPUkNFRCA9IElTX1BVUkUgfHwgTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcjtcblxudmFyIEl0ZXJhdG9yUHJveHkgPSBjcmVhdGVJdGVyYXRvclByb3h5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgdmFyIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwodGhpcy5uZXh0LCBpdGVyYXRvcikpO1xuICB2YXIgZG9uZSA9IHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmU7XG4gIGlmICghZG9uZSkgcmV0dXJuIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIHRoaXMubWFwcGVyLCBbcmVzdWx0LnZhbHVlLCB0aGlzLmNvdW50ZXIrK10sIHRydWUpO1xufSk7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLm1hcFxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwcGVyKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShtYXBwZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAobWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBtYXBwZXIpO1xuXG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvclByb3h5KGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpLCB7XG4gICAgICBtYXBwZXI6IG1hcHBlclxuICAgIH0pO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTc2Nzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gYEdldEl0ZXJhdG9yRGlyZWN0KG9iailgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRpdGVyYXRvcmRpcmVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgaXRlcmF0b3I6IG9iaixcbiAgICBuZXh0OiBvYmoubmV4dCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTgyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzk3KTtcbnZhciBpbmRleE9mID0gKF9fd2VicGFja19yZXF1aXJlX18oOTYxNykuaW5kZXhPZik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIxKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBtYWtlQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjgzKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvci5nZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3IuZ2V0LCBuYW1lLCB7IGdldHRlcjogdHJ1ZSB9KTtcbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLnNldCwgbmFtZSwgeyBzZXR0ZXI6IHRydWUgfSk7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eS5mKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxOTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmcoaXQpLCA4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMjExOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjMwMzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xuXG52YXIgVWludDhBcnJheSA9IGdsb2JhbFRoaXMuVWludDhBcnJheTtcbnZhciBTeW50YXhFcnJvciA9IGdsb2JhbFRoaXMuU3ludGF4RXJyb3I7XG52YXIgcGFyc2VJbnQgPSBnbG9iYWxUaGlzLnBhcnNlSW50O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE5PVF9IRVggPSAvW15cXGRhLWZdL2k7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKE5PVF9IRVguZXhlYyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgaW50bykge1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0cmluZ0xlbmd0aCAlIDIgIT09IDApIHRocm93IG5ldyBTeW50YXhFcnJvcignU3RyaW5nIHNob3VsZCBiZSBhbiBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzJyk7XG4gIHZhciBtYXhMZW5ndGggPSBpbnRvID8gbWluKGludG8ubGVuZ3RoLCBzdHJpbmdMZW5ndGggLyAyKSA6IHN0cmluZ0xlbmd0aCAvIDI7XG4gIHZhciBieXRlcyA9IGludG8gfHwgbmV3IFVpbnQ4QXJyYXkobWF4TGVuZ3RoKTtcbiAgdmFyIHJlYWQgPSAwO1xuICB2YXIgd3JpdHRlbiA9IDA7XG4gIHdoaWxlICh3cml0dGVuIDwgbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGhleGl0cyA9IHN0cmluZ1NsaWNlKHN0cmluZywgcmVhZCwgcmVhZCArPSAyKTtcbiAgICBpZiAoZXhlYyhOT1RfSEVYLCBoZXhpdHMpKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N0cmluZyBzaG91bGQgb25seSBjb250YWluIGhleCBjaGFyYWN0ZXJzJyk7XG4gICAgYnl0ZXNbd3JpdHRlbisrXSA9IHBhcnNlSW50KGhleGl0cywgMTYpO1xuICB9XG4gIHJldHVybiB7IGJ5dGVzOiBieXRlcywgcmVhZDogcmVhZCB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM2MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODAxKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODcyNyk7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIxKTtcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1NSk7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTE5KTtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWFzc2lnbm1lbnQgLS0gYXZvaWQgbWVtb3J5IGxlYWtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0NzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgaXNTdXBlcnNldE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTI3KTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTE2KTtcblxudmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKCdpc1N1cGVyc2V0T2YnLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiAhcmVzdWx0O1xufSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmlzU3VwZXJzZXRPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaXNzdXBlcnNldG9mXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUIH0sIHtcbiAgaXNTdXBlcnNldE9mOiBpc1N1cGVyc2V0T2Zcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNDg5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDYyKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzE5KTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mzk1KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODQpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xuXG52YXIgRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKCdmaWx0ZXInLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xudmFyIGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgIUZJTFRFUl9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1JcbiAgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZmlsdGVyJywgVHlwZUVycm9yKTtcblxudmFyIEZPUkNFRCA9IElTX1BVUkUgfHwgRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcjtcblxudmFyIEl0ZXJhdG9yUHJveHkgPSBjcmVhdGVJdGVyYXRvclByb3h5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlO1xuICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgdmFyIHJlc3VsdCwgZG9uZSwgdmFsdWU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcmVzdWx0ID0gYW5PYmplY3QoY2FsbChuZXh0LCBpdGVyYXRvcikpO1xuICAgIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIHByZWRpY2F0ZSwgW3ZhbHVlLCB0aGlzLmNvdW50ZXIrK10sIHRydWUpKSByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5maWx0ZXJcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUocHJlZGljYXRlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcblxuICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGVcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI1Mjk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbi8vIGBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaXRlcnJlc3VsdG9iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiBkb25lIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjAzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQsICRkZWZhdWx0KSB7XG4gIHJldHVybiBhcmd1bWVudCA9PT0gdW5kZWZpbmVkID8gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyAnJyA6ICRkZWZhdWx0IDogdG9TdHJpbmcoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjY1Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA4MCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODIzKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMDkpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTk4KTtcbnZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjI1KTtcbnZhciBnZXRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTEpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX1JFQ09SRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19SRUNPUkQpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJyk7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0KHZhbHVlKTtcbiAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgIH0gcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICB9O1xuXG4gIGlmIChJU19SRUNPUkQpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlLml0ZXJhdG9yO1xuICB9IGVsc2UgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGl0ZXJhYmxlKSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gSVNfUkVDT1JEID8gaXRlcmFibGUubmV4dCA6IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3Nzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1Nyk7XG52YXIgZ2V0TWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY2KTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjcwKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3ODc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5ODEpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oNjExOSk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjExKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzT3duKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3OTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyODA0OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG52YXIgY29tbW9uQWxwaGFiZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xudmFyIGJhc2U2NEFscGhhYmV0ID0gY29tbW9uQWxwaGFiZXQgKyAnKy8nO1xudmFyIGJhc2U2NFVybEFscGhhYmV0ID0gY29tbW9uQWxwaGFiZXQgKyAnLV8nO1xuXG52YXIgaW52ZXJzZSA9IGZ1bmN0aW9uIChjaGFyYWN0ZXJzKSB7XG4gIC8vIFRPRE86IHVzZSBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaW4gYGNvcmUtanNANGBcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKDsgaW5kZXggPCA2NDsgaW5kZXgrKykgcmVzdWx0W2NoYXJhY3RlcnMuY2hhckF0KGluZGV4KV0gPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpMmM6IGJhc2U2NEFscGhhYmV0LFxuICBjMmk6IGludmVyc2UoYmFzZTY0QWxwaGFiZXQpLFxuICBpMmNVcmw6IGJhc2U2NFVybEFscGhhYmV0LFxuICBjMmlVcmw6IGludmVyc2UoYmFzZTY0VXJsQWxwaGFiZXQpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyODEyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IG5ldyAkVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjgzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG5cbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWxUaGlzLm5hdmlnYXRvcjtcbnZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxubW9kdWxlLmV4cG9ydHMgPSB1c2VyQWdlbnQgPyBTdHJpbmcodXNlckFnZW50KSA6ICcnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTY3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA2KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTApO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUwNik7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IHVuY3VycnlUaGlzQWNjZXNzb3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsICdzZXQnKTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIHJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gTztcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzA2ODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIGJhc2VkIG9uIFNoZXdjaHVrJ3MgYWxnb3JpdGhtIGZvciBleGFjdGx5IGZsb2F0aW5nIHBvaW50IGFkZGl0aW9uXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbWF0aC1zdW0vYmxvYi8zNTEzZDU4MzIzYTFhZTI1NTYwZTg3MDBhYTUyOTQ1MDBjNmM5Mjg3L3BvbHlmaWxsL3BvbHlmaWxsLm1qc1xudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjUyKTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyICRJbmZpbml0eSA9IEluZmluaXR5O1xudmFyICROYU4gPSBOYU47XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG52YXIgUE9XXzJfMTAyMyA9IHBvdygyLCAxMDIzKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcG93KDIsIDUzKSAtIDE7IC8vIDIgKiogNTMgLSAxID09PSA5MDA3MTk5MjU0NzQwOTkyXG52YXIgTUFYX0RPVUJMRSA9IE51bWJlci5NQVhfVkFMVUU7IC8vIDIgKiogMTAyNCAtIDIgKiogKDEwMjMgLSA1MikgPT09IDEuNzk3NjkzMTM0ODYyMzE1NzA4MTVlKzMwOFxudmFyIE1BWF9VTFAgPSBwb3coMiwgOTcxKTsgLy8gMiAqKiAoMTAyMyAtIDUyKSA9PT0gMS45OTU4NDAzMDk1MzQ3MTk4MTE2NmUrMjkyXG5cbnZhciBOT1RfQV9OVU1CRVIgPSB7fTtcbnZhciBNSU5VU19JTkZJTklUWSA9IHt9O1xudmFyIFBMVVNfSU5GSU5JVFkgPSB7fTtcbnZhciBNSU5VU19aRVJPID0ge307XG52YXIgRklOSVRFID0ge307XG5cbi8vIHByZXJlcXVpc2l0ZTogYWJzKHgpID49IGFicyh5KVxudmFyIHR3b3N1bSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciBoaSA9IHggKyB5O1xuICB2YXIgbG8gPSB5IC0gKGhpIC0geCk7XG4gIHJldHVybiB7IGhpOiBoaSwgbG86IGxvIH07XG59O1xuXG4vLyBgTWF0aC5zdW1QcmVjaXNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW1hdGgtc3VtXG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gb2tcbiAgc3VtUHJlY2lzZTogZnVuY3Rpb24gc3VtUHJlY2lzZShpdGVtcykge1xuICAgIHZhciBudW1iZXJzID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgc3RhdGUgPSBNSU5VU19aRVJPO1xuXG4gICAgaXRlcmF0ZShpdGVtcywgZnVuY3Rpb24gKG4pIHtcbiAgICAgIGlmICgrK2NvdW50ID49IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IG5ldyAkUmFuZ2VFcnJvcignTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICBpZiAodHlwZW9mIG4gIT0gJ251bWJlcicpIHRocm93IG5ldyAkVHlwZUVycm9yKCdWYWx1ZSBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgIGlmIChzdGF0ZSAhPT0gTk9UX0FfTlVNQkVSKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICAgIGlmIChuICE9PSBuKSBzdGF0ZSA9IE5PVF9BX05VTUJFUjtcbiAgICAgICAgZWxzZSBpZiAobiA9PT0gJEluZmluaXR5KSBzdGF0ZSA9IHN0YXRlID09PSBNSU5VU19JTkZJTklUWSA/IE5PVF9BX05VTUJFUiA6IFBMVVNfSU5GSU5JVFk7XG4gICAgICAgIGVsc2UgaWYgKG4gPT09IC0kSW5maW5pdHkpIHN0YXRlID0gc3RhdGUgPT09IFBMVVNfSU5GSU5JVFkgPyBOT1RfQV9OVU1CRVIgOiBNSU5VU19JTkZJTklUWTtcbiAgICAgICAgZWxzZSBpZiAoKG4gIT09IDAgfHwgKDEgLyBuKSA9PT0gJEluZmluaXR5KSAmJiAoc3RhdGUgPT09IE1JTlVTX1pFUk8gfHwgc3RhdGUgPT09IEZJTklURSkpIHtcbiAgICAgICAgICBzdGF0ZSA9IEZJTklURTtcbiAgICAgICAgICBwdXNoKG51bWJlcnMsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIE5PVF9BX05VTUJFUjogcmV0dXJuICROYU47XG4gICAgICBjYXNlIE1JTlVTX0lORklOSVRZOiByZXR1cm4gLSRJbmZpbml0eTtcbiAgICAgIGNhc2UgUExVU19JTkZJTklUWTogcmV0dXJuICRJbmZpbml0eTtcbiAgICAgIGNhc2UgTUlOVVNfWkVSTzogcmV0dXJuIC0wO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFscyA9IFtdO1xuICAgIHZhciBvdmVyZmxvdyA9IDA7IC8vIGNvbmNlcHR1YWxseSAyICoqIDEwMjQgdGltZXMgdGhpcyB2YWx1ZTsgdGhlIGZpbmFsIHBhcnRpYWwgaXMgYmlhc2VkIGJ5IHRoaXMgYW1vdW50XG4gICAgdmFyIHgsIHksIHN1bSwgaGksIGxvLCB0bXA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSBudW1iZXJzW2ldO1xuICAgICAgdmFyIGFjdHVhbGx5VXNlZFBhcnRpYWxzID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydGlhbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgeSA9IHBhcnRpYWxzW2pdO1xuICAgICAgICBpZiAoYWJzKHgpIDwgYWJzKHkpKSB7XG4gICAgICAgICAgdG1wID0geDtcbiAgICAgICAgICB4ID0geTtcbiAgICAgICAgICB5ID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHR3b3N1bSh4LCB5KTtcbiAgICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICAgIGxvID0gc3VtLmxvO1xuICAgICAgICBpZiAoYWJzKGhpKSA9PT0gJEluZmluaXR5KSB7XG4gICAgICAgICAgdmFyIHNpZ24gPSBoaSA9PT0gJEluZmluaXR5ID8gMSA6IC0xO1xuICAgICAgICAgIG92ZXJmbG93ICs9IHNpZ247XG5cbiAgICAgICAgICB4ID0gKHggLSAoc2lnbiAqIFBPV18yXzEwMjMpKSAtIChzaWduICogUE9XXzJfMTAyMyk7XG4gICAgICAgICAgaWYgKGFicyh4KSA8IGFicyh5KSkge1xuICAgICAgICAgICAgdG1wID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VtID0gdHdvc3VtKHgsIHkpO1xuICAgICAgICAgIGhpID0gc3VtLmhpO1xuICAgICAgICAgIGxvID0gc3VtLmxvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsbyAhPT0gMCkgcGFydGlhbHNbYWN0dWFsbHlVc2VkUGFydGlhbHMrK10gPSBsbztcbiAgICAgICAgeCA9IGhpO1xuICAgICAgfVxuICAgICAgcGFydGlhbHMubGVuZ3RoID0gYWN0dWFsbHlVc2VkUGFydGlhbHM7XG4gICAgICBpZiAoeCAhPT0gMCkgcHVzaChwYXJ0aWFscywgeCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgZXhhY3Qgc3VtIG9mIHBhcnRpYWxzLCBzdG9wcGluZyBvbmNlIHdlIGxvc2UgcHJlY2lzaW9uXG4gICAgdmFyIG4gPSBwYXJ0aWFscy5sZW5ndGggLSAxO1xuICAgIGhpID0gMDtcbiAgICBsbyA9IDA7XG5cbiAgICBpZiAob3ZlcmZsb3cgIT09IDApIHtcbiAgICAgIHZhciBuZXh0ID0gbiA+PSAwID8gcGFydGlhbHNbbl0gOiAwO1xuICAgICAgbi0tO1xuICAgICAgaWYgKGFicyhvdmVyZmxvdykgPiAxIHx8IChvdmVyZmxvdyA+IDAgJiYgbmV4dCA+IDApIHx8IChvdmVyZmxvdyA8IDAgJiYgbmV4dCA8IDApKSB7XG4gICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyAkSW5maW5pdHkgOiAtJEluZmluaXR5O1xuICAgICAgfVxuICAgICAgLy8gaGVyZSB3ZSBhY3R1YWxseSBoYXZlIHRvIGRvIHRoZSBhcml0aG1ldGljXG4gICAgICAvLyBkcm9wIGEgZmFjdG9yIG9mIDIgc28gd2UgY2FuIGRvIGl0IHdpdGhvdXQgb3ZlcmZsb3dcbiAgICAgIC8vIGFzc2VydChhYnMob3ZlcmZsb3cpID09PSAxKVxuICAgICAgc3VtID0gdHdvc3VtKG92ZXJmbG93ICogUE9XXzJfMTAyMywgbmV4dCAvIDIpO1xuICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICBsbyA9IHN1bS5sbztcbiAgICAgIGxvICo9IDI7XG4gICAgICBpZiAoYWJzKDIgKiBoaSkgPT09ICRJbmZpbml0eSkge1xuICAgICAgICAvLyByb3VuZGluZyB0byB0aGUgbWF4aW11bSB2YWx1ZVxuICAgICAgICBpZiAoaGkgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChoaSA9PT0gUE9XXzJfMTAyMyAmJiBsbyA9PT0gLShNQVhfVUxQIC8gMikgJiYgbiA+PSAwICYmIHBhcnRpYWxzW25dIDwgMCkgPyBNQVhfRE9VQkxFIDogJEluZmluaXR5O1xuICAgICAgICB9IHJldHVybiAoaGkgPT09IC1QT1dfMl8xMDIzICYmIGxvID09PSAoTUFYX1VMUCAvIDIpICYmIG4gPj0gMCAmJiBwYXJ0aWFsc1tuXSA+IDApID8gLU1BWF9ET1VCTEUgOiAtJEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobG8gIT09IDApIHtcbiAgICAgICAgcGFydGlhbHNbKytuXSA9IGxvO1xuICAgICAgICBsbyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGhpICo9IDI7XG4gICAgfVxuXG4gICAgd2hpbGUgKG4gPj0gMCkge1xuICAgICAgc3VtID0gdHdvc3VtKGhpLCBwYXJ0aWFsc1tuLS1dKTtcbiAgICAgIGhpID0gc3VtLmhpO1xuICAgICAgbG8gPSBzdW0ubG87XG4gICAgICBpZiAobG8gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChuID49IDAgJiYgKChsbyA8IDAgJiYgcGFydGlhbHNbbl0gPCAwKSB8fCAobG8gPiAwICYmIHBhcnRpYWxzW25dID4gMCkpKSB7XG4gICAgICB5ID0gbG8gKiAyO1xuICAgICAgeCA9IGhpICsgeTtcbiAgICAgIGlmICh5ID09PSB4IC0gaGkpIGhpID0geDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTY3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTY3KTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIGlzQ2FsbGFibGUoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMyMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4MTEpO1xudmFyIGFycmF5QnVmZmVyQnl0ZUxlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzM5NCk7XG5cbnZhciBEYXRhVmlldyA9IGdsb2JhbFRoaXMuRGF0YVZpZXc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSIHx8IGFycmF5QnVmZmVyQnl0ZUxlbmd0aChPKSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcgLS0gdGhyb3dlclxuICAgIG5ldyBEYXRhVmlldyhPKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzOTI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMS50b1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDgwKTtcbnZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDAyKTtcbnZhciBjbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTI4Nik7XG52YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE3MCk7XG52YXIgZ2V0U2V0UmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzg5KTtcbnZhciBpdGVyYXRlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDY5KTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDcpO1xuXG52YXIgaGFzID0gU2V0SGVscGVycy5oYXM7XG52YXIgcmVtb3ZlID0gU2V0SGVscGVycy5yZW1vdmU7XG5cbi8vIGBTZXQucHJvdG90eXBlLmRpZmZlcmVuY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRpZmZlcmVuY2Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlmZmVyZW5jZShvdGhlcikge1xuICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiAgaWYgKHNpemUoTykgPD0gb3RoZXJSZWMuc2l6ZSkgaXRlcmF0ZVNldChPLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChvdGhlclJlYy5pbmNsdWRlcyhlKSkgcmVtb3ZlKHJlc3VsdCwgZSk7XG4gIH0pO1xuICBlbHNlIGl0ZXJhdGVTaW1wbGUob3RoZXJSZWMuZ2V0SXRlcmF0b3IoKSwgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwgZSkpIHJlbW92ZShyZXN1bHQsIGUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0NjM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdzdHJpbmcnKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBzdHJpbmcnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1MDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzUG9zc2libGVQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5MjUpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNQb3NzaWJsZVByb3RvdHlwZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1Nzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjY1Mik7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xuXG52YXIgc29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignc29tZScsIFR5cGVFcnJvcik7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5zb21lXG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBzb21lV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICBzb21lOiBmdW5jdGlvbiBzb21lKHByZWRpY2F0ZSkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUocHJlZGljYXRlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHNvbWVXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoc29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBwcmVkaWNhdGUpO1xuXG4gICAgdmFyIHJlY29yZCA9IGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICByZXR1cm4gaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RvcCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgY291bnRlcisrKSkgcmV0dXJuIHN0b3AoKTtcbiAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSwgSU5URVJSVVBURUQ6IHRydWUgfSkuc3RvcHBlZDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM2NTA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpO1xudmFyIGNsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjg2KTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG5cbnZhciBhZGQgPSBTZXRIZWxwZXJzLmFkZDtcbnZhciBoYXMgPSBTZXRIZWxwZXJzLmhhcztcbnZhciByZW1vdmUgPSBTZXRIZWxwZXJzLnJlbW92ZTtcblxuLy8gYFNldC5wcm90b3R5cGUuc3ltbWV0cmljRGlmZmVyZW5jZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuc3ltbWV0cmljZGlmZmVyZW5jZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKG90aGVyKSB7XG4gIHZhciBPID0gYVNldCh0aGlzKTtcbiAgdmFyIGtleXNJdGVyID0gZ2V0U2V0UmVjb3JkKG90aGVyKS5nZXRJdGVyYXRvcigpO1xuICB2YXIgcmVzdWx0ID0gY2xvbmUoTyk7XG4gIGl0ZXJhdGVTaW1wbGUoa2V5c0l0ZXIsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGhhcyhPLCBlKSkgcmVtb3ZlKHJlc3VsdCwgZSk7XG4gICAgZWxzZSBhZGQocmVzdWx0LCBlKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MjkpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzcxNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzI0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT09IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzc4OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xuXG52YXIgSU5WQUxJRF9TSVpFID0gJ0ludmFsaWQgc2l6ZSc7XG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbnZhciBTZXRSZWNvcmQgPSBmdW5jdGlvbiAoc2V0LCBpbnRTaXplKSB7XG4gIHRoaXMuc2V0ID0gc2V0O1xuICB0aGlzLnNpemUgPSBtYXgoaW50U2l6ZSwgMCk7XG4gIHRoaXMuaGFzID0gYUNhbGxhYmxlKHNldC5oYXMpO1xuICB0aGlzLmtleXMgPSBhQ2FsbGFibGUoc2V0LmtleXMpO1xufTtcblxuU2V0UmVjb3JkLnByb3RvdHlwZSA9IHtcbiAgZ2V0SXRlcmF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SXRlcmF0b3JEaXJlY3QoYW5PYmplY3QoY2FsbCh0aGlzLmtleXMsIHRoaXMuc2V0KSkpO1xuICB9LFxuICBpbmNsdWRlczogZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGNhbGwodGhpcy5oYXMsIHRoaXMuc2V0LCBpdCk7XG4gIH1cbn07XG5cbi8vIGBHZXRTZXRSZWNvcmRgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXNldC1tZXRob2RzLyNzZWMtZ2V0c2V0cmVjb3JkXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgYW5PYmplY3Qob2JqKTtcbiAgdmFyIG51bVNpemUgPSArb2JqLnNpemU7XG4gIC8vIE5PVEU6IElmIHNpemUgaXMgdW5kZWZpbmVkLCB0aGVuIG51bVNpemUgd2lsbCBiZSBOYU5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgaWYgKG51bVNpemUgIT09IG51bVNpemUpIHRocm93IG5ldyAkVHlwZUVycm9yKElOVkFMSURfU0laRSk7XG4gIHZhciBpbnRTaXplID0gdG9JbnRlZ2VyT3JJbmZpbml0eShudW1TaXplKTtcbiAgaWYgKGludFNpemUgPCAwKSB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoSU5WQUxJRF9TSVpFKTtcbiAgcmV0dXJuIG5ldyBTZXRSZWNvcmQob2JqLCBpbnRTaXplKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM4Mzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIHNpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNzApO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0NjkpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4OSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmlzU3Vic2V0T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmlzc3Vic2V0b2Zcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdWJzZXRPZihvdGhlcikge1xuICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gIGlmIChzaXplKE8pID4gb3RoZXJSZWMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlcmF0ZShPLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghb3RoZXJSZWMuaW5jbHVkZXMoZSkpIHJldHVybiBmYWxzZTtcbiAgfSwgdHJ1ZSkgIT09IGZhbHNlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzg1Mzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBpc0Rpc2pvaW50RnJvbSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ0OSk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxNik7XG5cbnZhciBJTkNPUlJFQ1QgPSAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnaXNEaXNqb2ludEZyb20nLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiAhcmVzdWx0O1xufSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmlzRGlzam9pbnRGcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5pc2Rpc2pvaW50ZnJvbVxuJCh7IHRhcmdldDogJ1NldCcsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVCB9LCB7XG4gIGlzRGlzam9pbnRGcm9tOiBpc0Rpc2pvaW50RnJvbVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM5MjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc09iamVjdChhcmd1bWVudCkgfHwgYXJndW1lbnQgPT09IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzOTcyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoYXJndW1lbnQgPT09IHVuZGVmaW5lZCB8fCBpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxMTQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5ODEpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTk4KTtcbnZhciBzZXRBcnJheUxlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUyNyk7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODM3KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG5cbnZhciBJTkNPUlJFQ1RfVE9fTEVOR1RIID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW10ucHVzaC5jYWxsKHsgbGVuZ3RoOiAweDEwMDAwMDAwMCB9LCAxKSAhPT0gNDI5NDk2NzI5Nztcbn0pO1xuXG4vLyBWOCA8PSAxMjEgYW5kIFNhZmFyaSA8PSAxNS40OyBGRiA8IDIzIHRocm93cyBJbnRlcm5hbEVycm9yXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMjY4MVxudmFyIHByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5wdXNoKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59O1xuXG52YXIgRk9SQ0VEID0gSU5DT1JSRUNUX1RPX0xFTkdUSCB8fCAhcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoKCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucHVzaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wdXNoXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgcHVzaDogZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobGVuICsgYXJnQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgICAgT1tsZW5dID0gYXJndW1lbnRzW2ldO1xuICAgICAgbGVuKys7XG4gICAgfVxuICAgIHNldEFycmF5TGVuZ3RoKE8sIGxlbik7XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxMTc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxNDk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIGlmIChpdCA9PT0gaXQpIHJldHVybiBpdDtcbiAgdGhyb3cgbmV3ICRSYW5nZUVycm9yKCdOYU4gaXMgbm90IGFsbG93ZWQnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxNTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTUpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gUGVyZm9ybSA/IFJlcXVpcmVJbnRlcm5hbFNsb3QoYXJndW1lbnQsIFtbVHlwZWRBcnJheU5hbWVdXSlcbi8vIElmIGFyZ3VtZW50LltbVHlwZWRBcnJheU5hbWVdXSBpcyBub3QgXCJVaW50OEFycmF5XCIsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnVWludDhBcnJheScpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhbiBVaW50OEFycmF5Jyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjA0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDgwKTtcbnZhciBhZGQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg0NDAyKS5hZGQpO1xudmFyIGNsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjg2KTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG5cbi8vIGBTZXQucHJvdG90eXBlLnVuaW9uYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS51bmlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bmlvbihvdGhlcikge1xuICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gIHZhciBrZXlzSXRlciA9IGdldFNldFJlY29yZChvdGhlcikuZ2V0SXRlcmF0b3IoKTtcbiAgdmFyIHJlc3VsdCA9IGNsb25lKE8pO1xuICBpdGVyYXRlU2ltcGxlKGtleXNJdGVyLCBmdW5jdGlvbiAoaXQpIHtcbiAgICBhZGQocmVzdWx0LCBpdCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIwOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjI3KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyNjkpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIxNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vKiBnbG9iYWwgQnVuLCBEZW5vIC0tIGRldGVjdGlvbiAqL1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgzOSk7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjE5NSk7XG5cbnZhciB1c2VyQWdlbnRTdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gdXNlckFnZW50LnNsaWNlKDAsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh1c2VyQWdlbnRTdGFydHNXaXRoKCdCdW4vJykpIHJldHVybiAnQlVOJztcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ0Nsb3VkZmxhcmUtV29ya2VycycpKSByZXR1cm4gJ0NMT1VERkxBUkUnO1xuICBpZiAodXNlckFnZW50U3RhcnRzV2l0aCgnRGVuby8nKSkgcmV0dXJuICdERU5PJztcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ05vZGUuanMvJykpIHJldHVybiAnTk9ERSc7XG4gIGlmIChnbG9iYWxUaGlzLkJ1biAmJiB0eXBlb2YgQnVuLnZlcnNpb24gPT0gJ3N0cmluZycpIHJldHVybiAnQlVOJztcbiAgaWYgKGdsb2JhbFRoaXMuRGVubyAmJiB0eXBlb2YgRGVuby52ZXJzaW9uID09ICdvYmplY3QnKSByZXR1cm4gJ0RFTk8nO1xuICBpZiAoY2xhc3NvZihnbG9iYWxUaGlzLnByb2Nlc3MpID09PSAncHJvY2VzcycpIHJldHVybiAnTk9ERSc7XG4gIGlmIChnbG9iYWxUaGlzLndpbmRvdyAmJiBnbG9iYWxUaGlzLmRvY3VtZW50KSByZXR1cm4gJ0JST1dTRVInO1xuICByZXR1cm4gJ1JFU1QnO1xufSkoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIyNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBhU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYzKTtcbnZhciBhblVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNTQpO1xudmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY5KTtcbnZhciAkZnJvbUhleCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwMyk7XG5cbi8vIGBVaW50OEFycmF5LnByb3RvdHlwZS5zZXRGcm9tSGV4YCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5YnVmZmVyLWJhc2U2NFxuaWYgKGdsb2JhbFRoaXMuVWludDhBcnJheSkgJCh7IHRhcmdldDogJ1VpbnQ4QXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIHNldEZyb21IZXg6IGZ1bmN0aW9uIHNldEZyb21IZXgoc3RyaW5nKSB7XG4gICAgYW5VaW50OEFycmF5KHRoaXMpO1xuICAgIGFTdHJpbmcoc3RyaW5nKTtcbiAgICBub3REZXRhY2hlZCh0aGlzLmJ1ZmZlcik7XG4gICAgdmFyIHJlYWQgPSAkZnJvbUhleChzdHJpbmcsIHRoaXMpLnJlYWQ7XG4gICAgcmV0dXJuIHsgcmVhZDogcmVhZCwgd3JpdHRlbjogcmVhZCAvIDIgfTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXygzMDY4KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDI3MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Mzc2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTk1KTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT09ICdBcnJheSc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDAyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zZXQgLS0gc2FmZVxudmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc2V0IC0tIHNhZmVcbiAgU2V0OiBTZXQsXG4gIGFkZDogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmFkZCksXG4gIGhhczogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmhhcyksXG4gIHJlbW92ZTogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlWydkZWxldGUnXSksXG4gIHByb3RvOiBTZXRQcm90b3R5cGVcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0NDk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIGhhcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpLmhhcyk7XG52YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE3MCk7XG52YXIgZ2V0U2V0UmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzg5KTtcbnZhciBpdGVyYXRlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDY5KTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5pc0Rpc2pvaW50RnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaXNkaXNqb2ludGZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEaXNqb2ludEZyb20ob3RoZXIpIHtcbiAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICBpZiAoc2l6ZShPKSA8PSBvdGhlclJlYy5zaXplKSByZXR1cm4gaXRlcmF0ZVNldChPLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChvdGhlclJlYy5pbmNsdWRlcyhlKSkgcmV0dXJuIGZhbHNlO1xuICB9LCB0cnVlKSAhPT0gZmFsc2U7XG4gIHZhciBpdGVyYXRvciA9IG90aGVyUmVjLmdldEl0ZXJhdG9yKCk7XG4gIHJldHVybiBpdGVyYXRlU2ltcGxlKGl0ZXJhdG9yLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChoYXMoTywgZSkpIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgZmFsc2UpO1xuICB9KSAhPT0gZmFsc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDgzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBnZXRCdWlsdEluTm9kZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG52YXIgUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NDgpO1xuXG52YXIgc3RydWN0dXJlZENsb25lID0gZ2xvYmFsVGhpcy5zdHJ1Y3R1cmVkQ2xvbmU7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsVGhpcy5BcnJheUJ1ZmZlcjtcbnZhciAkTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWxUaGlzLk1lc3NhZ2VDaGFubmVsO1xudmFyIGRldGFjaCA9IGZhbHNlO1xudmFyIFdvcmtlclRocmVhZHMsIGNoYW5uZWwsIGJ1ZmZlciwgJGRldGFjaDtcblxuaWYgKFBST1BFUl9TVFJVQ1RVUkVEX0NMT05FX1RSQU5TRkVSKSB7XG4gIGRldGFjaCA9IGZ1bmN0aW9uICh0cmFuc2ZlcmFibGUpIHtcbiAgICBzdHJ1Y3R1cmVkQ2xvbmUodHJhbnNmZXJhYmxlLCB7IHRyYW5zZmVyOiBbdHJhbnNmZXJhYmxlXSB9KTtcbiAgfTtcbn0gZWxzZSBpZiAoJEFycmF5QnVmZmVyKSB0cnkge1xuICBpZiAoISRNZXNzYWdlQ2hhbm5lbCkge1xuICAgIFdvcmtlclRocmVhZHMgPSBnZXRCdWlsdEluTm9kZU1vZHVsZSgnd29ya2VyX3RocmVhZHMnKTtcbiAgICBpZiAoV29ya2VyVGhyZWFkcykgJE1lc3NhZ2VDaGFubmVsID0gV29ya2VyVGhyZWFkcy5NZXNzYWdlQ2hhbm5lbDtcbiAgfVxuXG4gIGlmICgkTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3ICRNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoMik7XG5cbiAgICAkZGV0YWNoID0gZnVuY3Rpb24gKHRyYW5zZmVyYWJsZSkge1xuICAgICAgY2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZShudWxsLCBbdHJhbnNmZXJhYmxlXSk7XG4gICAgfTtcblxuICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMikge1xuICAgICAgJGRldGFjaChidWZmZXIpO1xuICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSBkZXRhY2ggPSAkZGV0YWNoO1xuICAgIH1cbiAgfVxufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRldGFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQ5NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTE5KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG5cbnZhciAkU3RyaW5nID0gZ2xvYmFsVGhpcy5TdHJpbmc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCdzeW1ib2wgZGV0ZWN0aW9uJyk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgLy8gbmI6IERvIG5vdCBjYWxsIGBTdHJpbmdgIGRpcmVjdGx5IHRvIGF2b2lkIHRoaXMgYmVpbmcgb3B0aW1pemVkIG91dCB0byBgc3ltYm9sKycnYCB3aGljaCB3aWxsLFxuICAvLyBvZiBjb3Vyc2UsIGZhaWwuXG4gIHJldHVybiAhJFN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDUyNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNzYpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBTYWZhcmkgPCAxMyBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpbiB0aGlzIGNhc2VcbnZhciBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPSBERVNDUklQVE9SUyAmJiAhZnVuY3Rpb24gKCkge1xuICAvLyBtYWtlcyBubyBzZW5zZSB3aXRob3V0IHByb3BlciBzdHJpY3QgbW9kZSBzdXBwb3J0XG4gIGlmICh0aGlzICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLmxlbmd0aCA9IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0lMRU5UX09OX05PTl9XUklUQUJMRV9MRU5HVEhfU0VUID8gZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICBpZiAoaXNBcnJheShPKSAmJiAhZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sICdsZW5ndGgnKS53cml0YWJsZSkge1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCdDYW5ub3Qgc2V0IHJlYWQgb25seSAubGVuZ3RoJyk7XG4gIH0gcmV0dXJuIE8ubGVuZ3RoID0gbGVuZ3RoO1xufSA6IGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgcmV0dXJuIE8ubGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDU0OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWEyNjIvcHVsbC8zNDY3XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgRXhwZWN0ZWRFcnJvcikge1xuICB2YXIgSXRlcmF0b3IgPSBnbG9iYWxUaGlzLkl0ZXJhdG9yO1xuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvciAmJiBJdGVyYXRvci5wcm90b3R5cGU7XG4gIHZhciBtZXRob2QgPSBJdGVyYXRvclByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZVtNRVRIT0RfTkFNRV07XG5cbiAgdmFyIENMT1NFRCA9IGZhbHNlO1xuXG4gIGlmIChtZXRob2QpIHRyeSB7XG4gICAgbWV0aG9kLmNhbGwoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiB0cnVlIH07IH0sXG4gICAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkgeyBDTE9TRUQgPSB0cnVlOyB9XG4gICAgfSwgLTEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTExOTVcbiAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEV4cGVjdGVkRXJyb3IpKSBDTE9TRUQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghQ0xPU0VEKSByZXR1cm4gbWV0aG9kO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDU3Njpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICBjaGVjayh0eXBlb2YgdGhpcyA9PSAnb2JqZWN0JyAmJiB0aGlzKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDYwMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODQwKTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NSk7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MTIpO1xuXG52YXIgJFVSTFNlYXJjaFBhcmFtcyA9IFVSTFNlYXJjaFBhcmFtcztcbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSAkVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZTtcbnZhciBhcHBlbmQgPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuYXBwZW5kKTtcbnZhciAkZGVsZXRlID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlWydkZWxldGUnXSk7XG52YXIgZm9yRWFjaCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5mb3JFYWNoKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG52YXIgcGFyYW1zID0gbmV3ICRVUkxTZWFyY2hQYXJhbXMoJ2E9MSZhPTImYj0zJyk7XG5cbnBhcmFtc1snZGVsZXRlJ10oJ2EnLCAxKTtcbi8vIGB1bmRlZmluZWRgIGNhc2UgaXMgYSBDaHJvbWl1bSAxMTcgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xNDIyMlxucGFyYW1zWydkZWxldGUnXSgnYicsIHVuZGVmaW5lZCk7XG5cbmlmIChwYXJhbXMgKyAnJyAhPT0gJ2E9MicpIHtcbiAgZGVmaW5lQnVpbHRJbihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdkZWxldGUnLCBmdW5jdGlvbiAobmFtZSAvKiAsIHZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyICR2YWx1ZSA9IGxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgaWYgKGxlbmd0aCAmJiAkdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRkZWxldGUodGhpcywgbmFtZSk7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3JFYWNoKHRoaXMsIGZ1bmN0aW9uICh2LCBrKSB7IC8vIGFsc28gdmFsaWRhdGVzIGB0aGlzYFxuICAgICAgcHVzaChlbnRyaWVzLCB7IGtleTogaywgdmFsdWU6IHYgfSk7XG4gICAgfSk7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgobGVuZ3RoLCAxKTtcbiAgICB2YXIga2V5ID0gdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIHZhbHVlID0gdG9TdHJpbmcoJHZhbHVlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBkaW5kZXggPSAwO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBlbnRyaWVzTGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXNMZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIGlmIChmb3VuZCB8fCBlbnRyeS5rZXkgPT09IGtleSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICRkZWxldGUodGhpcywgZW50cnkua2V5KTtcbiAgICAgIH0gZWxzZSBkaW5kZXgrKztcbiAgICB9XG4gICAgd2hpbGUgKGRpbmRleCA8IGVudHJpZXNMZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tkaW5kZXgrK107XG4gICAgICBpZiAoIShlbnRyeS5rZXkgPT09IGtleSAmJiBlbnRyeS52YWx1ZSA9PT0gdmFsdWUpKSBhcHBlbmQodGhpcywgZW50cnkua2V5LCBlbnRyeS52YWx1ZSk7XG4gICAgfVxuICB9LCB7IGVudW1lcmFibGU6IHRydWUsIHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDYyODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjA0Myk7XG5cbi8vIGBQcm9taXNlLndpdGhSZXNvbHZlcnNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLndpdGhSZXNvbHZlcnNcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSB9LCB7XG4gIHdpdGhSZXNvbHZlcnM6IGZ1bmN0aW9uIHdpdGhSZXNvbHZlcnMoKSB7XG4gICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvbWlzZTogcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZSxcbiAgICAgIHJlc29sdmU6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUsXG4gICAgICByZWplY3Q6IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdFxuICAgIH07XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjQ0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODExKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTUpO1xudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODIzKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2OTkpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwNik7XG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYyNSk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3ODcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTY3KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzM5Mik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4MSk7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsVGhpcy5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5ICYmIEludDhBcnJheS5wcm90b3R5cGU7XG52YXIgVWludDhDbGFtcGVkQXJyYXkgPSBnbG9iYWxUaGlzLlVpbnQ4Q2xhbXBlZEFycmF5O1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlID0gVWludDhDbGFtcGVkQXJyYXkgJiYgVWludDhDbGFtcGVkQXJyYXkucHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoSW50OEFycmF5KTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5UHJvdG90eXBlICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheVByb3RvdHlwZSk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgVFlQRURfQVJSQVlfVEFHID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9ICdUeXBlZEFycmF5Q29uc3RydWN0b3InO1xuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IE5BVElWRV9BUlJBWV9CVUZGRVIgJiYgISFzZXRQcm90b3R5cGVPZiAmJiBjbGFzc29mKGdsb2JhbFRoaXMub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3J1xuICAgIHx8IGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdCk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvdG8pO1xuICByZXR1cm4gKHN0YXRlICYmIGhhc093bihzdGF0ZSwgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IpKSA/IHN0YXRlW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA6IGdldFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcihwcm90byk7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YoaXQpO1xuICByZXR1cm4gaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24oQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzVHlwZWRBcnJheShpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChpc0NhbGxhYmxlKEMpICYmICghc2V0UHJvdG90eXBlT2YgfHwgaXNQcm90b3R5cGVPZihUeXBlZEFycmF5LCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHRyeVRvU3RyaW5nKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkLCBvcHRpb25zKSB7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKGZvcmNlZCkgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsVGhpc1tBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZKSkgdHJ5IHtcbiAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIG9sZCBXZWJLaXQgYnVnIC0gc29tZSBtZXRob2RzIGFyZSBub24tY29uZmlndXJhYmxlXG4gICAgICB0cnkge1xuICAgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICB9XG4gIGlmICghVHlwZWRBcnJheVByb3RvdHlwZVtLRVldIHx8IGZvcmNlZCkge1xuICAgIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheVByb3RvdHlwZSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eVxuICAgICAgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVByb3RvdHlwZVtLRVldIHx8IHByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gIHZhciBBUlJBWSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICBpZiAoIURFU0NSSVBUT1JTKSByZXR1cm47XG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgIGlmIChmb3JjZWQpIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXNbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB0cnkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVCdWlsdEluKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIFR5cGVkQXJyYXlbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsVGhpc1tBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgICAgIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXNbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3RvcjtcbiAgZWxzZSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gZmFsc2U7XG59XG5cbmZvciAoTkFNRSBpbiBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgQ29uc3RydWN0b3IgPSBnbG9iYWxUaGlzW05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGVuZm9yY2VJbnRlcm5hbFN0YXRlKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIWlzQ2FsbGFibGUoVHlwZWRBcnJheSkgfHwgVHlwZWRBcnJheSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3cgLS0gc2FmZVxuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXNbTkFNRV0pIHNldFByb3RvdHlwZU9mKGdsb2JhbFRoaXNbTkFNRV0sIFR5cGVkQXJyYXkpO1xuICB9XG59XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSB8fCBUeXBlZEFycmF5UHJvdG90eXBlID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXNbTkFNRV0pIHNldFByb3RvdHlwZU9mKGdsb2JhbFRoaXNbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gb25lIG1vcmUgb2JqZWN0IGluIFVpbnQ4Q2xhbXBlZEFycmF5IHByb3RvdHlwZSBjaGFpblxuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUpICE9PSBUeXBlZEFycmF5UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbn1cblxuaWYgKERFU0NSSVBUT1JTICYmICFoYXNPd24oVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBR10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoZ2xvYmFsVGhpc1tOQU1FXSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWxUaGlzW05BTUVdLCBUWVBFRF9BUlJBWV9UQUcsIE5BTUUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxuICBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXG4gIGFUeXBlZEFycmF5OiBhVHlwZWRBcnJheSxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgZXhwb3J0VHlwZWRBcnJheU1ldGhvZDogZXhwb3J0VHlwZWRBcnJheU1ldGhvZCxcbiAgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDogZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCxcbiAgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gIGlzVmlldzogaXNWaWV3LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSxcbiAgVHlwZWRBcnJheVByb3RvdHlwZTogVHlwZWRBcnJheVByb3RvdHlwZVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDY1OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5ODApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3Rba2V5XSA9IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDkwMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxudmFyIGRvY3VtZW50QWxsID0gdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnICYmIGRvY3VtZW50LmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5MTM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkxNyk7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2ODYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTY5KTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzUxKTtcblxudmFyIGNyZWF0ZVNldExpa2UgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4ge1xuICAgIHNpemU6IHNpemUsXG4gICAgaGFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjcmVhdGVTZXRMaWtlV2l0aEluZmluaXR5U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBoYXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlJyk7XG4gICAgfVxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIFNldCA9IGdldEJ1aWx0SW4oJ1NldCcpO1xuICB0cnkge1xuICAgIG5ldyBTZXQoKVtuYW1lXShjcmVhdGVTZXRMaWtlKDApKTtcbiAgICB0cnkge1xuICAgICAgLy8gbGF0ZSBzcGVjIGNoYW5nZSwgZWFybHkgV2ViS2l0IH4gU2FmYXJpIDE3IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHBhc3MgaXRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNldC1tZXRob2RzL3B1bGwvODhcbiAgICAgIC8vIGFsc28gY292ZXJlZCBlbmdpbmVzIHdpdGhcbiAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNzI2NzlcbiAgICAgIG5ldyBTZXQoKVtuYW1lXShjcmVhdGVTZXRMaWtlKC0xKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIGVhcmx5IFY4IGltcGxlbWVudGF0aW9uIGJ1Z1xuICAgICAgLy8gaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy8zNTEzMzI2MzRcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBTZXQoKVtuYW1lXShjcmVhdGVTZXRMaWtlV2l0aEluZmluaXR5U2l6ZSgtSW5maW5pdHkpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgc2V0LmFkZCgxKTtcbiAgICAgICAgc2V0LmFkZCgyKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNldFtuYW1lXShjcmVhdGVTZXRMaWtlV2l0aEluZmluaXR5U2l6ZShJbmZpbml0eSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTcyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgbm90QU5hTiA9IF9fd2VicGFja19yZXF1aXJlX18oNDE0OSk7XG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1OTApO1xudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NjIpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xuXG52YXIgdGFrZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcigndGFrZScsIFJhbmdlRXJyb3IpO1xuXG52YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICBpZiAoIXRoaXMucmVtYWluaW5nLS0pIHtcbiAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgdW5kZWZpbmVkKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gYW5PYmplY3QoY2FsbCh0aGlzLm5leHQsIGl0ZXJhdG9yKSk7XG4gIHZhciBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgaWYgKCFkb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xufSk7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUudGFrZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS50YWtlXG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIHx8IHRha2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gIHRha2U6IGZ1bmN0aW9uIHRha2UobGltaXQpIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcmVtYWluaW5nO1xuICAgIHRyeSB7XG4gICAgICByZW1haW5pbmcgPSB0b1Bvc2l0aXZlSW50ZWdlcihub3RBTmFOKCtsaW1pdCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGFrZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbCh0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHJlbWFpbmluZyk7XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yUHJveHkoZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyksIHtcbiAgICAgIHJlbWFpbmluZzogcmVtYWluaW5nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTc5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjk4MCk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKS5mKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3OSk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNjcpO1xudmFyIG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjAzKTtcbnZhciBET01FeGNlcHRpb25Db25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMDIpO1xudmFyIGNsZWFyRXJyb3JTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oODU3NCk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xuXG52YXIgRE9NX0VYQ0VQVElPTiA9ICdET01FeGNlcHRpb24nO1xudmFyIEVycm9yID0gZ2V0QnVpbHRJbignRXJyb3InKTtcbnZhciBOYXRpdmVET01FeGNlcHRpb24gPSBnZXRCdWlsdEluKERPTV9FWENFUFRJT04pO1xuXG52YXIgJERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbigpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCBET01FeGNlcHRpb25Qcm90b3R5cGUpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1lc3NhZ2UgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChhcmd1bWVudHNMZW5ndGggPCAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgdmFyIG5hbWUgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChhcmd1bWVudHNMZW5ndGggPCAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCAnRXJyb3InKTtcbiAgdmFyIHRoYXQgPSBuZXcgTmF0aXZlRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpO1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSBET01fRVhDRVBUSU9OO1xuICBkZWZpbmVQcm9wZXJ0eSh0aGF0LCAnc3RhY2snLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgY2xlYXJFcnJvclN0YWNrKGVycm9yLnN0YWNrLCAxKSkpO1xuICBpbmhlcml0SWZSZXF1aXJlZCh0aGF0LCB0aGlzLCAkRE9NRXhjZXB0aW9uKTtcbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG52YXIgRE9NRXhjZXB0aW9uUHJvdG90eXBlID0gJERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBOYXRpdmVET01FeGNlcHRpb24ucHJvdG90eXBlO1xuXG52YXIgRVJST1JfSEFTX1NUQUNLID0gJ3N0YWNrJyBpbiBuZXcgRXJyb3IoRE9NX0VYQ0VQVElPTik7XG52YXIgRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0sgPSAnc3RhY2snIGluIG5ldyBOYXRpdmVET01FeGNlcHRpb24oMSwgMik7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBkZXNjcmlwdG9yID0gTmF0aXZlRE9NRXhjZXB0aW9uICYmIERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgRE9NX0VYQ0VQVElPTik7XG5cbi8vIEJ1biB+IDAuMS4xIERPTUV4Y2VwdGlvbiBoYXZlIGluY29ycmVjdCBkZXNjcmlwdG9yIGFuZCB3ZSBjYW4ndCByZWRlZmluZSBpdFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0phcnJlZC1TdW1uZXIvYnVuL2lzc3Vlcy8zOTlcbnZhciBCVUdHWV9ERVNDUklQVE9SID0gISFkZXNjcmlwdG9yICYmICEoZGVzY3JpcHRvci53cml0YWJsZSAmJiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSk7XG5cbnZhciBGT1JDRURfQ09OU1RSVUNUT1IgPSBFUlJPUl9IQVNfU1RBQ0sgJiYgIUJVR0dZX0RFU0NSSVBUT1IgJiYgIURPTV9FWENFUFRJT05fSEFTX1NUQUNLO1xuXG4vLyBgRE9NRXhjZXB0aW9uYCBjb25zdHJ1Y3RvciBwYXRjaCBmb3IgYC5zdGFja2Agd2hlcmUgaXQncyByZXF1aXJlZFxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ET01FeGNlcHRpb24tc3BlY2lhbG5lc3NcbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgRk9SQ0VEX0NPTlNUUlVDVE9SIH0sIHsgLy8gVE9ETzogZml4IGV4cG9ydCBsb2dpY1xuICBET01FeGNlcHRpb246IEZPUkNFRF9DT05TVFJVQ1RPUiA/ICRET01FeGNlcHRpb24gOiBOYXRpdmVET01FeGNlcHRpb25cbn0pO1xuXG52YXIgUG9seWZpbGxlZERPTUV4Y2VwdGlvbiA9IGdldEJ1aWx0SW4oRE9NX0VYQ0VQVElPTik7XG52YXIgUG9seWZpbGxlZERPTUV4Y2VwdGlvblByb3RvdHlwZSA9IFBvbHlmaWxsZWRET01FeGNlcHRpb24ucHJvdG90eXBlO1xuXG5pZiAoUG9seWZpbGxlZERPTUV4Y2VwdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gUG9seWZpbGxlZERPTUV4Y2VwdGlvbikge1xuICBpZiAoIUlTX1BVUkUpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgUG9seWZpbGxlZERPTUV4Y2VwdGlvbikpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIERPTUV4Y2VwdGlvbkNvbnN0YW50cykgaWYgKGhhc093bihET01FeGNlcHRpb25Db25zdGFudHMsIGtleSkpIHtcbiAgICB2YXIgY29uc3RhbnQgPSBET01FeGNlcHRpb25Db25zdGFudHNba2V5XTtcbiAgICB2YXIgY29uc3RhbnROYW1lID0gY29uc3RhbnQucztcbiAgICBpZiAoIWhhc093bihQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uLCBjb25zdGFudE5hbWUpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uLCBjb25zdGFudE5hbWUsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig2LCBjb25zdGFudC5jKSk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMDI6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJbmRleFNpemVFcnJvcjogeyBzOiAnSU5ERVhfU0laRV9FUlInLCBjOiAxLCBtOiAxIH0sXG4gIERPTVN0cmluZ1NpemVFcnJvcjogeyBzOiAnRE9NU1RSSU5HX1NJWkVfRVJSJywgYzogMiwgbTogMCB9LFxuICBIaWVyYXJjaHlSZXF1ZXN0RXJyb3I6IHsgczogJ0hJRVJBUkNIWV9SRVFVRVNUX0VSUicsIGM6IDMsIG06IDEgfSxcbiAgV3JvbmdEb2N1bWVudEVycm9yOiB7IHM6ICdXUk9OR19ET0NVTUVOVF9FUlInLCBjOiA0LCBtOiAxIH0sXG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvcjogeyBzOiAnSU5WQUxJRF9DSEFSQUNURVJfRVJSJywgYzogNSwgbTogMSB9LFxuICBOb0RhdGFBbGxvd2VkRXJyb3I6IHsgczogJ05PX0RBVEFfQUxMT1dFRF9FUlInLCBjOiA2LCBtOiAwIH0sXG4gIE5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yOiB7IHM6ICdOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlInLCBjOiA3LCBtOiAxIH0sXG4gIE5vdEZvdW5kRXJyb3I6IHsgczogJ05PVF9GT1VORF9FUlInLCBjOiA4LCBtOiAxIH0sXG4gIE5vdFN1cHBvcnRlZEVycm9yOiB7IHM6ICdOT1RfU1VQUE9SVEVEX0VSUicsIGM6IDksIG06IDEgfSxcbiAgSW5Vc2VBdHRyaWJ1dGVFcnJvcjogeyBzOiAnSU5VU0VfQVRUUklCVVRFX0VSUicsIGM6IDEwLCBtOiAxIH0sXG4gIEludmFsaWRTdGF0ZUVycm9yOiB7IHM6ICdJTlZBTElEX1NUQVRFX0VSUicsIGM6IDExLCBtOiAxIH0sXG4gIFN5bnRheEVycm9yOiB7IHM6ICdTWU5UQVhfRVJSJywgYzogMTIsIG06IDEgfSxcbiAgSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yOiB7IHM6ICdJTlZBTElEX01PRElGSUNBVElPTl9FUlInLCBjOiAxMywgbTogMSB9LFxuICBOYW1lc3BhY2VFcnJvcjogeyBzOiAnTkFNRVNQQUNFX0VSUicsIGM6IDE0LCBtOiAxIH0sXG4gIEludmFsaWRBY2Nlc3NFcnJvcjogeyBzOiAnSU5WQUxJRF9BQ0NFU1NfRVJSJywgYzogMTUsIG06IDEgfSxcbiAgVmFsaWRhdGlvbkVycm9yOiB7IHM6ICdWQUxJREFUSU9OX0VSUicsIGM6IDE2LCBtOiAwIH0sXG4gIFR5cGVNaXNtYXRjaEVycm9yOiB7IHM6ICdUWVBFX01JU01BVENIX0VSUicsIGM6IDE3LCBtOiAxIH0sXG4gIFNlY3VyaXR5RXJyb3I6IHsgczogJ1NFQ1VSSVRZX0VSUicsIGM6IDE4LCBtOiAxIH0sXG4gIE5ldHdvcmtFcnJvcjogeyBzOiAnTkVUV09SS19FUlInLCBjOiAxOSwgbTogMSB9LFxuICBBYm9ydEVycm9yOiB7IHM6ICdBQk9SVF9FUlInLCBjOiAyMCwgbTogMSB9LFxuICBVUkxNaXNtYXRjaEVycm9yOiB7IHM6ICdVUkxfTUlTTUFUQ0hfRVJSJywgYzogMjEsIG06IDEgfSxcbiAgUXVvdGFFeGNlZWRlZEVycm9yOiB7IHM6ICdRVU9UQV9FWENFRURFRF9FUlInLCBjOiAyMiwgbTogMSB9LFxuICBUaW1lb3V0RXJyb3I6IHsgczogJ1RJTUVPVVRfRVJSJywgYzogMjMsIG06IDEgfSxcbiAgSW52YWxpZE5vZGVUeXBlRXJyb3I6IHsgczogJ0lOVkFMSURfTk9ERV9UWVBFX0VSUicsIGM6IDI0LCBtOiAxIH0sXG4gIERhdGFDbG9uZUVycm9yOiB7IHM6ICdEQVRBX0NMT05FX0VSUicsIGM6IDI1LCBtOiAxIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMjQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgc3ltbWV0cmljRGlmZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzY1MCk7XG52YXIgc2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MzUpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgRk9SQ0VEID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ3N5bW1ldHJpY0RpZmZlcmVuY2UnKSB8fCAhc2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmcoJ3N5bW1ldHJpY0RpZmZlcmVuY2UnKTtcblxuLy8gYFNldC5wcm90b3R5cGUuc3ltbWV0cmljRGlmZmVyZW5jZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuc3ltbWV0cmljZGlmZmVyZW5jZVxuJCh7IHRhcmdldDogJ1NldCcsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHN5bW1ldHJpY0RpZmZlcmVuY2U6IHN5bW1ldHJpY0RpZmZlcmVuY2Vcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDMxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzUxKTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQ4MCk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzE3KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUxNjk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzRGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyMzgpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzRGV0YWNoZWQoaXQpKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignQXJyYXlCdWZmZXIgaXMgZGV0YWNoZWQnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTE3MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcwNik7XG52YXIgU2V0SGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQwMik7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihTZXRIZWxwZXJzLnByb3RvLCAnc2l6ZScsICdnZXQnKSB8fCBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBzZXQuc2l6ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyMTM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgYXJyYXlGcm9tQ29uc3RydWN0b3JBbmRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzcwKTtcbnZhciAkZnJvbUJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oOTE0Myk7XG5cbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsVGhpcy5VaW50OEFycmF5O1xuXG52YXIgSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgPSAhVWludDhBcnJheSB8fCAhVWludDhBcnJheS5mcm9tQmFzZTY0IHx8ICFmdW5jdGlvbiAoKSB7XG4gIC8vIFdlYmtpdCBub3QgdGhyb3cgYW4gZXJyb3Igb24gb2RkIGxlbmd0aCBzdHJpbmdcbiAgdHJ5IHtcbiAgICBVaW50OEFycmF5LmZyb21CYXNlNjQoJ2EnKTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdHJ5IHtcbiAgICBVaW50OEFycmF5LmZyb21CYXNlNjQoJycsIG51bGwpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KCk7XG5cbi8vIGBVaW50OEFycmF5LmZyb21CYXNlNjRgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXlidWZmZXItYmFzZTY0XG5pZiAoVWludDhBcnJheSkgJCh7IHRhcmdldDogJ1VpbnQ4QXJyYXknLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTIH0sIHtcbiAgZnJvbUJhc2U2NDogZnVuY3Rpb24gZnJvbUJhc2U2NChzdHJpbmcgLyogLCBvcHRpb25zICovKSB7XG4gICAgdmFyIHJlc3VsdCA9ICRmcm9tQmFzZTY0KHN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIG51bGwsIDB4MUZGRkZGRkZGRkZGRkYpO1xuICAgIHJldHVybiBhcnJheUZyb21Db25zdHJ1Y3RvckFuZExpc3QoVWludDhBcnJheSwgcmVzdWx0LmJ5dGVzKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTk4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGxpc3QsICRsZW5ndGgpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gJGxlbmd0aCA6IGxlbmd0aE9mQXJyYXlMaWtlKGxpc3QpO1xuICB2YXIgcmVzdWx0ID0gbmV3IENvbnN0cnVjdG9yKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Mzk3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA1NSk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2MTA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOTEpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjIzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbl9fd2VicGFja19yZXF1aXJlX18oNDU2KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIHVuY3VycnlUaGlzQWNjZXNzb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MDYpO1xudmFyIHRvSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2OTYpO1xudmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY5KTtcbnZhciBhcnJheUJ1ZmZlckJ5dGVMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczOTQpO1xudmFyIGRldGFjaFRyYW5zZmVyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ4Myk7XG52YXIgUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NDgpO1xuXG52YXIgc3RydWN0dXJlZENsb25lID0gZ2xvYmFsVGhpcy5zdHJ1Y3R1cmVkQ2xvbmU7XG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWxUaGlzLkFycmF5QnVmZmVyO1xudmFyIERhdGFWaWV3ID0gZ2xvYmFsVGhpcy5EYXRhVmlldztcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IEFycmF5QnVmZmVyLnByb3RvdHlwZTtcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3LnByb3RvdHlwZTtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzKEFycmF5QnVmZmVyUHJvdG90eXBlLnNsaWNlKTtcbnZhciBpc1Jlc2l6YWJsZSA9IHVuY3VycnlUaGlzQWNjZXNzb3IoQXJyYXlCdWZmZXJQcm90b3R5cGUsICdyZXNpemFibGUnLCAnZ2V0Jyk7XG52YXIgbWF4Qnl0ZUxlbmd0aCA9IHVuY3VycnlUaGlzQWNjZXNzb3IoQXJyYXlCdWZmZXJQcm90b3R5cGUsICdtYXhCeXRlTGVuZ3RoJywgJ2dldCcpO1xudmFyIGdldEludDggPSB1bmN1cnJ5VGhpcyhEYXRhVmlld1Byb3RvdHlwZS5nZXRJbnQ4KTtcbnZhciBzZXRJbnQ4ID0gdW5jdXJyeVRoaXMoRGF0YVZpZXdQcm90b3R5cGUuc2V0SW50OCk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFBST1BFUl9TVFJVQ1RVUkVEX0NMT05FX1RSQU5TRkVSIHx8IGRldGFjaFRyYW5zZmVyYWJsZSkgJiYgZnVuY3Rpb24gKGFycmF5QnVmZmVyLCBuZXdMZW5ndGgsIHByZXNlcnZlUmVzaXphYmlsaXR5KSB7XG4gIHZhciBieXRlTGVuZ3RoID0gYXJyYXlCdWZmZXJCeXRlTGVuZ3RoKGFycmF5QnVmZmVyKTtcbiAgdmFyIG5ld0J5dGVMZW5ndGggPSBuZXdMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ5dGVMZW5ndGggOiB0b0luZGV4KG5ld0xlbmd0aCk7XG4gIHZhciBmaXhlZExlbmd0aCA9ICFpc1Jlc2l6YWJsZSB8fCAhaXNSZXNpemFibGUoYXJyYXlCdWZmZXIpO1xuICB2YXIgbmV3QnVmZmVyO1xuICBub3REZXRhY2hlZChhcnJheUJ1ZmZlcik7XG4gIGlmIChQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUikge1xuICAgIGFycmF5QnVmZmVyID0gc3RydWN0dXJlZENsb25lKGFycmF5QnVmZmVyLCB7IHRyYW5zZmVyOiBbYXJyYXlCdWZmZXJdIH0pO1xuICAgIGlmIChieXRlTGVuZ3RoID09PSBuZXdCeXRlTGVuZ3RoICYmIChwcmVzZXJ2ZVJlc2l6YWJpbGl0eSB8fCBmaXhlZExlbmd0aCkpIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfVxuICBpZiAoYnl0ZUxlbmd0aCA+PSBuZXdCeXRlTGVuZ3RoICYmICghcHJlc2VydmVSZXNpemFiaWxpdHkgfHwgZml4ZWRMZW5ndGgpKSB7XG4gICAgbmV3QnVmZmVyID0gc2xpY2UoYXJyYXlCdWZmZXIsIDAsIG5ld0J5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvcHRpb25zID0gcHJlc2VydmVSZXNpemFiaWxpdHkgJiYgIWZpeGVkTGVuZ3RoICYmIG1heEJ5dGVMZW5ndGggPyB7IG1heEJ5dGVMZW5ndGg6IG1heEJ5dGVMZW5ndGgoYXJyYXlCdWZmZXIpIH0gOiB1bmRlZmluZWQ7XG4gICAgbmV3QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG5ld0J5dGVMZW5ndGgsIG9wdGlvbnMpO1xuICAgIHZhciBhID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB2YXIgYiA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuICAgIHZhciBjb3B5TGVuZ3RoID0gbWluKG5ld0J5dGVMZW5ndGgsIGJ5dGVMZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29weUxlbmd0aDsgaSsrKSBzZXRJbnQ4KGIsIGksIGdldEludDgoYSwgaSkpO1xuICB9XG4gIGlmICghUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIpIGRldGFjaFRyYW5zZmVyYWJsZShhcnJheUJ1ZmZlcik7XG4gIHJldHVybiBuZXdCdWZmZXI7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzQ1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzYyOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSB8fCB7fSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODEyKTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQxNik7XG5cbnZhciBVUkwgPSBnZXRCdWlsdEluKCdVUkwnKTtcblxuLy8gYFVSTC5wYXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtY2FucGFyc2VcbiQoeyB0YXJnZXQ6ICdVUkwnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCB9LCB7XG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cmwpIHtcbiAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHVybFN0cmluZyA9IHRvU3RyaW5nKHVybCk7XG4gICAgdmFyIGJhc2UgPSBsZW5ndGggPCAyIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TdHJpbmcoYXJndW1lbnRzWzFdKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nLCBiYXNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTg1NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3NzcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFRvQmlnSW50YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9iaWdpbnRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBwcmltID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcbiAgaWYgKHR5cGVvZiBwcmltID09ICdudW1iZXInKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWJpZ2ludCAtLSBzYWZlXG4gIHJldHVybiBCaWdJbnQocHJpbSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1ODc2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGlzU3Vic2V0T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzgpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgSU5DT1JSRUNUID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ2lzU3Vic2V0T2YnLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuLy8gYFNldC5wcm90b3R5cGUuaXNTdWJzZXRPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaXNzdWJzZXRvZlxuJCh7IHRhcmdldDogJ1NldCcsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVCB9LCB7XG4gIGlzU3Vic2V0T2Y6IGlzU3Vic2V0T2Zcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTE3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwNTUpO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT09IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk2Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDExNyk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDQzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZShyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjA4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NzYpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNik7XG5cbnZhciBiaW5kID0gdW5jdXJyeVRoaXModW5jdXJyeVRoaXMuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlKGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTE5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3NDUpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzM5Mik7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTkzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBFTlZJUk9OTUVOVCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIxNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRU5WSVJPTk1FTlQgPT09ICdOT0RFJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjE5ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMTQpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYyNjk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYyNzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MzE5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjM5NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjUxODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gKF9fd2VicGFja19yZXF1aXJlX18oNzM0NykuZik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Njk5KTtcbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODQwKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQzMyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc0MCk7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3OTYpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsVGhpcztcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxUaGlzW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsVGhpc1tUQVJHRVRdICYmIGdsb2JhbFRoaXNbVEFSR0VUXS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1NzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwNik7XG52YXIgaXNEZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIzOCk7XG5cbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IEFycmF5QnVmZmVyLnByb3RvdHlwZTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS5kZXRhY2hlZGAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1hcnJheWJ1ZmZlci5wcm90b3R5cGUuZGV0YWNoZWRcbmlmIChERVNDUklQVE9SUyAmJiAhKCdkZXRhY2hlZCcgaW4gQXJyYXlCdWZmZXJQcm90b3R5cGUpKSB7XG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgJ2RldGFjaGVkJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRldGFjaGVkKCkge1xuICAgICAgcmV0dXJuIGlzRGV0YWNoZWQodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjYzMjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciAkZnJvbUJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oOTE0Myk7XG52YXIgYW5VaW50OEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTU0KTtcblxudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWxUaGlzLlVpbnQ4QXJyYXk7XG5cbnZhciBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyA9ICFVaW50OEFycmF5IHx8ICFVaW50OEFycmF5LnByb3RvdHlwZS5zZXRGcm9tQmFzZTY0IHx8ICFmdW5jdGlvbiAoKSB7XG4gIHZhciB0YXJnZXQgPSBuZXcgVWludDhBcnJheShbMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTVdKTtcbiAgdHJ5IHtcbiAgICB0YXJnZXQuc2V0RnJvbUJhc2U2NCgnJywgbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIC8vIFdlYmtpdCBub3QgdGhyb3cgYW4gZXJyb3Igb24gb2RkIGxlbmd0aCBzdHJpbmdcbiAgdHJ5IHtcbiAgICB0YXJnZXQuc2V0RnJvbUJhc2U2NCgnYScpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB0cnkge1xuICAgIHRhcmdldC5zZXRGcm9tQmFzZTY0KCdNall5Wmc9PT0nKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdGFyZ2V0WzBdID09PSA1MCAmJiB0YXJnZXRbMV0gPT09IDU0ICYmIHRhcmdldFsyXSA9PT0gNTAgJiYgdGFyZ2V0WzNdID09PSAyNTUgJiYgdGFyZ2V0WzRdID09PSAyNTU7XG4gIH1cbn0oKTtcblxuLy8gYFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldEZyb21CYXNlNjRgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXlidWZmZXItYmFzZTY0XG5pZiAoVWludDhBcnJheSkgJCh7IHRhcmdldDogJ1VpbnQ4QXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyB9LCB7XG4gIHNldEZyb21CYXNlNjQ6IGZ1bmN0aW9uIHNldEZyb21CYXNlNjQoc3RyaW5nIC8qICwgb3B0aW9ucyAqLykge1xuICAgIGFuVWludDhBcnJheSh0aGlzKTtcblxuICAgIHZhciByZXN1bHQgPSAkZnJvbUJhc2U2NChzdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGlzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4geyByZWFkOiByZXN1bHQucmVhZCwgd3JpdHRlbjogcmVzdWx0LndyaXR0ZW4gfTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2OTk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxMyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTgwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY3MDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgbWV0aG9kKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHJldHVybiB1bmN1cnJ5VGhpcyhhQ2FsbGFibGUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODAxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2ODYpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzk3KTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcyKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4MjM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4Mzc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93ICRUeXBlRXJyb3IoJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCcpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxMyk7XG52YXIgbWFrZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4Myk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MzMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk1NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQwKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBjbGFzc29mUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTk1KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5Njk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzc3KTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU3KTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5ODA6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ5NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJlxuICAhU3ltYm9sLnNoYW0gJiZcbiAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA1NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTk1KTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QoaXQpO1xufSA6ICRPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGhhcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpLmhhcyk7XG5cbi8vIFBlcmZvcm0gPyBSZXF1aXJlSW50ZXJuYWxTbG90KE0sIFtbU2V0RGF0YV1dKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaGFzKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzM0Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzczKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5ODApO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTM5Nyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oNjk2OSk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkxNyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24oTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIWNhbGwocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiwgTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzM5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcwNik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjE5NSk7XG5cbnZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbFRoaXMuQXJyYXlCdWZmZXI7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsVGhpcy5UeXBlRXJyb3I7XG5cbi8vIEluY2x1ZGVzXG4vLyAtIFBlcmZvcm0gPyBSZXF1aXJlSW50ZXJuYWxTbG90KE8sIFtbQXJyYXlCdWZmZXJEYXRhXV0pLlxuLy8gLSBJZiBJc1NoYXJlZEFycmF5QnVmZmVyKE8pIGlzIHRydWUsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlCdWZmZXIgJiYgdW5jdXJyeVRoaXNBY2Nlc3NvcihBcnJheUJ1ZmZlci5wcm90b3R5cGUsICdieXRlTGVuZ3RoJywgJ2dldCcpIHx8IGZ1bmN0aW9uIChPKSB7XG4gIGlmIChjbGFzc29mKE8pICE9PSAnQXJyYXlCdWZmZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheUJ1ZmZlciBleHBlY3RlZCcpO1xuICByZXR1cm4gTy5ieXRlTGVuZ3RoO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQxNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcmVsYXRpdmUtdXJsLXN0eWxlIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciB1cmwgPSBuZXcgVVJMKCdiP2E9MSZiPTImYz0zJywgJ2h0dHBzOi8vYScpO1xuICB2YXIgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgdmFyIHBhcmFtczIgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPTEmYT0yJmI9MycpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcGFyYW1zWydkZWxldGUnXSgnYicpO1xuICAgIHJlc3VsdCArPSBrZXkgKyB2YWx1ZTtcbiAgfSk7XG4gIHBhcmFtczJbJ2RlbGV0ZSddKCdhJywgMik7XG4gIC8vIGB1bmRlZmluZWRgIGNhc2UgaXMgYSBDaHJvbWl1bSAxMTcgYnVnXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTE0MjIyXG4gIHBhcmFtczJbJ2RlbGV0ZSddKCdiJywgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIChJU19QVVJFICYmICghdXJsLnRvSlNPTiB8fCAhcGFyYW1zMi5oYXMoJ2EnLCAxKSB8fCBwYXJhbXMyLmhhcygnYScsIDIpIHx8ICFwYXJhbXMyLmhhcygnYScsIHVuZGVmaW5lZCkgfHwgcGFyYW1zMi5oYXMoJ2InKSkpXG4gICAgfHwgKCFwYXJhbXMuc2l6ZSAmJiAoSVNfUFVSRSB8fCAhREVTQ1JJUFRPUlMpKVxuICAgIHx8ICFwYXJhbXMuc29ydFxuICAgIHx8IHVybC5ocmVmICE9PSAnaHR0cHM6Ly9hL2MlMjBkP2E9MSZjPTMnXG4gICAgfHwgcGFyYW1zLmdldCgnYycpICE9PSAnMydcbiAgICB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MSdcbiAgICB8fCAhcGFyYW1zW0lURVJBVE9SXVxuICAgIC8vIHRocm93cyBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hQGInKS51c2VybmFtZSAhPT0gJ2EnXG4gICAgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPWInKSkuZ2V0KCdhJykgIT09ICdiJ1xuICAgIC8vIG5vdCBwdW55Y29kZWQgaW4gRWRnZVxuICAgIHx8IG5ldyBVUkwoJ2h0dHBzOi8v0YLQtdGB0YInKS5ob3N0ICE9PSAneG4tLWUxYXliYydcbiAgICAvLyBub3QgZXNjYXBlZCBpbiBDaHJvbWUgNjItXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHBzOi8veCcsIHVuZGVmaW5lZCkuaG9zdCAhPT0gJ3gnO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc0NzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOTUpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpcyhmbik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTY2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgxMik7XG5cbnZhciAkVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xudmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9ICRVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xudmFyIGdldEFsbCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5nZXRBbGwpO1xudmFyICRoYXMgPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuaGFzKTtcbnZhciBwYXJhbXMgPSBuZXcgJFVSTFNlYXJjaFBhcmFtcygnYT0xJyk7XG5cbi8vIGB1bmRlZmluZWRgIGNhc2UgaXMgYSBDaHJvbWl1bSAxMTcgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xNDIyMlxuaWYgKHBhcmFtcy5oYXMoJ2EnLCAyKSB8fCAhcGFyYW1zLmhhcygnYScsIHVuZGVmaW5lZCkpIHtcbiAgZGVmaW5lQnVpbHRJbihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdoYXMnLCBmdW5jdGlvbiBoYXMobmFtZSAvKiAsIHZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyICR2YWx1ZSA9IGxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgaWYgKGxlbmd0aCAmJiAkdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRoYXModGhpcywgbmFtZSk7XG4gICAgdmFyIHZhbHVlcyA9IGdldEFsbCh0aGlzLCBuYW1lKTsgLy8gYWxzbyB2YWxpZGF0ZXMgYHRoaXNgXG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgobGVuZ3RoLCAxKTtcbiAgICB2YXIgdmFsdWUgPSB0b1N0cmluZygkdmFsdWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgaWYgKHZhbHVlc1tpbmRleCsrXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIH0gcmV0dXJuIGZhbHNlO1xuICB9LCB7IGVudW1lcmFibGU6IHRydWUsIHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzU4ODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjUyKTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG5cbnZhciBmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdmb3JFYWNoJywgVHlwZUVycm9yKTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmZvcmVhY2hcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IGZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgYUNhbGxhYmxlKGZuKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwoZm9yRWFjaFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBmbik7XG5cbiAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIGl0ZXJhdGUocmVjb3JkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGZuKHZhbHVlLCBjb3VudGVyKyspO1xuICAgIH0sIHsgSVNfUkVDT1JEOiB0cnVlIH0pO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzYyOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MzMpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFRoaXNbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcblxuKHN0b3JlLnZlcnNpb25zIHx8IChzdG9yZS52ZXJzaW9ucyA9IFtdKSkucHVzaCh7XG4gIHZlcnNpb246ICczLjQ1LjEnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyNSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjQ1LjEvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2NDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZGlmZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ0MCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgU0VUX0xJS0VfSU5DT1JSRUNUX0JFSEFWSU9SID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ2RpZmZlcmVuY2UnLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQuc2l6ZSA9PT0gMDtcbn0pO1xuXG52YXIgRk9SQ0VEID0gU0VUX0xJS0VfSU5DT1JSRUNUX0JFSEFWSU9SIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI4ODU5NVxuICB2YXIgc2V0TGlrZSA9IHtcbiAgICBzaXplOiAxLFxuICAgIGhhczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkb25lID0gaW5kZXgrKyA+IDE7XG4gICAgICAgICAgaWYgKGJhc2VTZXQuaGFzKDEpKSBiYXNlU2V0LmNsZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogZG9uZSwgdmFsdWU6IDIgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zZXQgLS0gdGVzdGluZ1xuICB2YXIgYmFzZVNldCA9IG5ldyBTZXQoWzEsIDIsIDMsIDRdKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXNldC1wcm90b3R5cGUtZGlmZmVyZW5jZSAtLSB0ZXN0aW5nXG4gIHJldHVybiBiYXNlU2V0LmRpZmZlcmVuY2Uoc2V0TGlrZSkuc2l6ZSAhPT0gMztcbn0pO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgZGlmZmVyZW5jZTogZGlmZmVyZW5jZVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2NTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM2MCk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3ODcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gIWlzT2JqZWN0KEl0ZXJhdG9yUHJvdG90eXBlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5lbHNlIGlmIChJU19QVVJFKSBJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZShJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjgwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoW10uc2xpY2UpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njk2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkxKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oODAxNCk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbi8vIGBUb0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IG5ldyAkUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIG9yIGluZGV4Jyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMzEpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzM0Nyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc1MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxMTcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzUxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxUaGlzW25hbWVzcGFjZV0pIDogZ2xvYmFsVGhpc1tuYW1lc3BhY2VdICYmIGdsb2JhbFRoaXNbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgxMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gJ3VuZGVmaW5lZCc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc5MzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgJHRyYW5zZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjM2KTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS50cmFuc2ZlclRvRml4ZWRMZW5ndGhgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheWJ1ZmZlci5wcm90b3R5cGUudHJhbnNmZXJ0b2ZpeGVkbGVuZ3RoXG5pZiAoJHRyYW5zZmVyKSAkKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSB9LCB7XG4gIHRyYW5zZmVyVG9GaXhlZExlbmd0aDogZnVuY3Rpb24gdHJhbnNmZXJUb0ZpeGVkTGVuZ3RoKCkge1xuICAgIHJldHVybiAkdHJhbnNmZXIodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAwNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgaW50ZXJzZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzUwKTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTE2KTtcblxudmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKCdpbnRlcnNlY3Rpb24nLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQuc2l6ZSA9PT0gMiAmJiByZXN1bHQuaGFzKDEpICYmIHJlc3VsdC5oYXMoMik7XG59KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBlcy9uby1zZXQsIGVzL25vLXNldC1wcm90b3R5cGUtaW50ZXJzZWN0aW9uIC0tIHRlc3RpbmdcbiAgcmV0dXJuIFN0cmluZyhBcnJheS5mcm9tKG5ldyBTZXQoWzEsIDIsIDNdKS5pbnRlcnNlY3Rpb24obmV3IFNldChbMywgMl0pKSkpICE9PSAnMywyJztcbn0pO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3Rpb25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmludGVyc2VjdGlvblxuJCh7IHRhcmdldDogJ1NldCcsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVCB9LCB7XG4gIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAxNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5MSk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBsZW4gPSB0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KTtcbiAgcmV0dXJuIGxlbiA+IDAgPyBtaW4obGVuLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxMDA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgJHRyYW5zZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjM2KTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS50cmFuc2ZlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS50cmFuc2ZlclxuaWYgKCR0cmFuc2ZlcikgJCh7IHRhcmdldDogJ0FycmF5QnVmZmVyJywgcHJvdG86IHRydWUgfSwge1xuICB0cmFuc2ZlcjogZnVuY3Rpb24gdHJhbnNmZXIoKSB7XG4gICAgcmV0dXJuICR0cmFuc2Zlcih0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxMTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc5KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3ODcpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwNik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NTkpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3NjU3KS5JdGVyYXRvclByb3RvdHlwZSk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xuXG52YXIgQ09OU1RSVUNUT1IgPSAnY29uc3RydWN0b3InO1xudmFyIElURVJBVE9SID0gJ0l0ZXJhdG9yJztcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBOYXRpdmVJdGVyYXRvciA9IGdsb2JhbFRoaXNbSVRFUkFUT1JdO1xuXG4vLyBGRjU2LSBoYXZlIG5vbi1zdGFuZGFyZCBnbG9iYWwgaGVscGVyIGBJdGVyYXRvcmBcbnZhciBGT1JDRUQgPSBJU19QVVJFXG4gIHx8ICFpc0NhbGxhYmxlKE5hdGl2ZUl0ZXJhdG9yKVxuICB8fCBOYXRpdmVJdGVyYXRvci5wcm90b3R5cGUgIT09IEl0ZXJhdG9yUHJvdG90eXBlXG4gIC8vIEZGNDQtIG5vbi1zdGFuZGFyZCBgSXRlcmF0b3JgIHBhc3NlcyBwcmV2aW91cyB0ZXN0c1xuICB8fCAhZmFpbHMoZnVuY3Rpb24gKCkgeyBOYXRpdmVJdGVyYXRvcih7fSk7IH0pO1xuXG52YXIgSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yKCkge1xuICBhbkluc3RhbmNlKHRoaXMsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgaWYgKGdldFByb3RvdHlwZU9mKHRoaXMpID09PSBJdGVyYXRvclByb3RvdHlwZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Fic3RyYWN0IGNsYXNzIEl0ZXJhdG9yIG5vdCBkaXJlY3RseSBjb25zdHJ1Y3RhYmxlJyk7XG59O1xuXG52YXIgZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihJdGVyYXRvclByb3RvdHlwZSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHJlcGxhY2VtZW50KSB7XG4gICAgICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgICAgICBpZiAodGhpcyA9PT0gSXRlcmF0b3JQcm90b3R5cGUpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiWW91IGNhbid0IHJlZGVmaW5lIHRoaXMgcHJvcGVydHlcIik7XG4gICAgICAgIGlmIChoYXNPd24odGhpcywga2V5KSkgdGhpc1trZXldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIGVsc2UgY3JlYXRlUHJvcGVydHkodGhpcywga2V5LCByZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBJdGVyYXRvclByb3RvdHlwZVtrZXldID0gdmFsdWU7XG59O1xuXG5pZiAoIWhhc093bihJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIGRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IoVE9fU1RSSU5HX1RBRywgSVRFUkFUT1IpO1xuXG5pZiAoRk9SQ0VEIHx8ICFoYXNPd24oSXRlcmF0b3JQcm90b3R5cGUsIENPTlNUUlVDVE9SKSB8fCBJdGVyYXRvclByb3RvdHlwZVtDT05TVFJVQ1RPUl0gPT09IE9iamVjdCkge1xuICBkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yKENPTlNUUlVDVE9SLCBJdGVyYXRvckNvbnN0cnVjdG9yKTtcbn1cblxuSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBJdGVyYXRvclByb3RvdHlwZTtcblxuLy8gYEl0ZXJhdG9yYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvclxuJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgSXRlcmF0b3I6IEl0ZXJhdG9yQ29uc3RydWN0b3Jcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MjI3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3NDUpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzkyKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDk1KTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA0MCk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sWydmb3InXSB8fCBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpXG4gICAgICA/IFN5bWJvbFtuYW1lXVxuICAgICAgOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyMzU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJHBhcnNlSW50ID0gcGFyc2VJbnQ7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBhdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgc2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcblxudmFyIGNvZGVQb2ludHMgPSB7XG4gICdcXFxcXCInOiAnXCInLFxuICAnXFxcXFxcXFwnOiAnXFxcXCcsXG4gICdcXFxcLyc6ICcvJyxcbiAgJ1xcXFxiJzogJ1xcYicsXG4gICdcXFxcZic6ICdcXGYnLFxuICAnXFxcXG4nOiAnXFxuJyxcbiAgJ1xcXFxyJzogJ1xccicsXG4gICdcXFxcdCc6ICdcXHQnXG59O1xuXG52YXIgSVNfNF9IRVhfRElHSVRTID0gL15bXFxkYS1mXXs0fSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tY29udHJvbC1jaGFyYWN0ZXIgLS0gc2FmZVxudmFyIElTX0MwX0NPTlRST0xfQ09ERSA9IC9eW1xcdTAwMDAtXFx1MDAxRl0kLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCBpKSB7XG4gIHZhciB1bnRlcm1pbmF0ZWQgPSB0cnVlO1xuICB2YXIgdmFsdWUgPSAnJztcbiAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdmFyIGNociA9IGF0KHNvdXJjZSwgaSk7XG4gICAgaWYgKGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICB2YXIgdHdvQ2hhcnMgPSBzbGljZShzb3VyY2UsIGksIGkgKyAyKTtcbiAgICAgIGlmIChoYXNPd24oY29kZVBvaW50cywgdHdvQ2hhcnMpKSB7XG4gICAgICAgIHZhbHVlICs9IGNvZGVQb2ludHNbdHdvQ2hhcnNdO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHR3b0NoYXJzID09PSAnXFxcXHUnKSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgdmFyIGZvdXJIZXhEaWdpdHMgPSBzbGljZShzb3VyY2UsIGksIGkgKyA0KTtcbiAgICAgICAgaWYgKCFleGVjKElTXzRfSEVYX0RJR0lUUywgZm91ckhleERpZ2l0cykpIHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ0JhZCBVbmljb2RlIGVzY2FwZSBhdDogJyArIGkpO1xuICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoJHBhcnNlSW50KGZvdXJIZXhEaWdpdHMsIDE2KSk7XG4gICAgICAgIGkgKz0gNDtcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdVbmtub3duIGVzY2FwZSBzZXF1ZW5jZTogXCInICsgdHdvQ2hhcnMgKyAnXCInKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gJ1wiJykge1xuICAgICAgdW50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICBpKys7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4ZWMoSVNfQzBfQ09OVFJPTF9DT0RFLCBjaHIpKSB0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdCYWQgY29udHJvbCBjaGFyYWN0ZXIgaW4gc3RyaW5nIGxpdGVyYWwgYXQ6ICcgKyBpKTtcbiAgICAgIHZhbHVlICs9IGNocjtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgaWYgKHVudGVybWluYXRlZCkgdGhyb3cgbmV3ICRTeW50YXhFcnJvcignVW50ZXJtaW5hdGVkIHN0cmluZyBhdDogJyArIGkpO1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGVuZDogaSB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODIzNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjUyKTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG52YXIgYXBwbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3NDUpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTE2NTFcbnZhciBGQUlMU19PTl9JTklUSUFMX1VOREVGSU5FRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWl0ZXJhdG9yLXByb3RvdHlwZS1yZWR1Y2UsIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzLCBhcnJheS1jYWxsYmFjay1yZXR1cm4gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgW10ua2V5cygpLnJlZHVjZShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIHVuZGVmaW5lZCk7XG59KTtcblxudmFyIHJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUZBSUxTX09OX0lOSVRJQUxfVU5ERUZJTkVEICYmIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ3JlZHVjZScsICRUeXBlRXJyb3IpO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5yZWR1Y2VcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX0lOSVRJQUxfVU5ERUZJTkVEIHx8IHJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UocmVkdWNlciAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUocmVkdWNlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBub0luaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoIDwgMjtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSBub0luaXRpYWwgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgaWYgKHJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSB7XG4gICAgICByZXR1cm4gYXBwbHkocmVkdWNlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIG5vSW5pdGlhbCA/IFtyZWR1Y2VyXSA6IFtyZWR1Y2VyLCBhY2N1bXVsYXRvcl0pO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIGl0ZXJhdGUocmVjb3JkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChub0luaXRpYWwpIHtcbiAgICAgICAgbm9Jbml0aWFsID0gZmFsc2U7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2N1bXVsYXRvciA9IHJlZHVjZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBjb3VudGVyKTtcbiAgICAgIH1cbiAgICAgIGNvdW50ZXIrKztcbiAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSB9KTtcbiAgICBpZiAobm9Jbml0aWFsKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGl0ZXJhdG9yIHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgzMzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNzYpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NSk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTgpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjU5KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgcGFyc2VKU09OU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjM1KTtcbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDk1KTtcblxudmFyIEpTT04gPSBnbG9iYWxUaGlzLkpTT047XG52YXIgTnVtYmVyID0gZ2xvYmFsVGhpcy5OdW1iZXI7XG52YXIgU3ludGF4RXJyb3IgPSBnbG9iYWxUaGlzLlN5bnRheEVycm9yO1xudmFyIG5hdGl2ZVBhcnNlID0gSlNPTiAmJiBKU09OLnBhcnNlO1xudmFyIGVudW1lcmFibGVPd25Qcm9wZXJ0aWVzID0gZ2V0QnVpbHRJbignT2JqZWN0JywgJ2tleXMnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxudmFyIElTX0RJR0lUID0gL15cXGQkLztcbnZhciBJU19OT05fWkVST19ESUdJVCA9IC9eWzEtOV0kLztcbnZhciBJU19OVU1CRVJfU1RBUlQgPSAvXltcXGQtXSQvO1xudmFyIElTX1dISVRFU1BBQ0UgPSAvXltcXHRcXG5cXHIgXSQvO1xuXG52YXIgUFJJTUlUSVZFID0gMDtcbnZhciBPQkpFQ1QgPSAxO1xuXG52YXIgJHBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICBzb3VyY2UgPSB0b1N0cmluZyhzb3VyY2UpO1xuICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHNvdXJjZSwgMCwgJycpO1xuICB2YXIgcm9vdCA9IGNvbnRleHQucGFyc2UoKTtcbiAgdmFyIHZhbHVlID0gcm9vdC52YWx1ZTtcbiAgdmFyIGVuZEluZGV4ID0gY29udGV4dC5za2lwKElTX1dISVRFU1BBQ0UsIHJvb3QuZW5kKTtcbiAgaWYgKGVuZEluZGV4IDwgc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBleHRyYSBjaGFyYWN0ZXI6IFwiJyArIGF0KHNvdXJjZSwgZW5kSW5kZXgpICsgJ1wiIGFmdGVyIHRoZSBwYXJzZWQgZGF0YSBhdDogJyArIGVuZEluZGV4KTtcbiAgfVxuICByZXR1cm4gaXNDYWxsYWJsZShyZXZpdmVyKSA/IGludGVybmFsaXplKHsgJyc6IHZhbHVlIH0sICcnLCByZXZpdmVyLCByb290KSA6IHZhbHVlO1xufTtcblxudmFyIGludGVybmFsaXplID0gZnVuY3Rpb24gKGhvbGRlciwgbmFtZSwgcmV2aXZlciwgbm9kZSkge1xuICB2YXIgdmFsID0gaG9sZGVyW25hbWVdO1xuICB2YXIgdW5tb2RpZmllZCA9IG5vZGUgJiYgdmFsID09PSBub2RlLnZhbHVlO1xuICB2YXIgY29udGV4dCA9IHVubW9kaWZpZWQgJiYgdHlwZW9mIG5vZGUuc291cmNlID09ICdzdHJpbmcnID8geyBzb3VyY2U6IG5vZGUuc291cmNlIH0gOiB7fTtcbiAgdmFyIGVsZW1lbnRSZWNvcmRzTGVuLCBrZXlzLCBsZW4sIGksIFA7XG4gIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgdmFyIG5vZGVJc0FycmF5ID0gaXNBcnJheSh2YWwpO1xuICAgIHZhciBub2RlcyA9IHVubW9kaWZpZWQgPyBub2RlLm5vZGVzIDogbm9kZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgIGlmIChub2RlSXNBcnJheSkge1xuICAgICAgZWxlbWVudFJlY29yZHNMZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSh2YWwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGludGVybmFsaXplUHJvcGVydHkodmFsLCBpLCBpbnRlcm5hbGl6ZSh2YWwsICcnICsgaSwgcmV2aXZlciwgaSA8IGVsZW1lbnRSZWNvcmRzTGVuID8gbm9kZXNbaV0gOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGVudW1lcmFibGVPd25Qcm9wZXJ0aWVzKHZhbCk7XG4gICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShrZXlzKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBQID0ga2V5c1tpXTtcbiAgICAgICAgaW50ZXJuYWxpemVQcm9wZXJ0eSh2YWwsIFAsIGludGVybmFsaXplKHZhbCwgUCwgcmV2aXZlciwgaGFzT3duKG5vZGVzLCBQKSA/IG5vZGVzW1BdIDogdW5kZWZpbmVkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWxsKHJldml2ZXIsIGhvbGRlciwgbmFtZSwgdmFsLCBjb250ZXh0KTtcbn07XG5cbnZhciBpbnRlcm5hbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSk7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGRlbGV0ZSBvYmplY3Rba2V5XTtcbiAgZWxzZSBjcmVhdGVQcm9wZXJ0eShvYmplY3QsIGtleSwgdmFsdWUpO1xufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZCwgc291cmNlLCBub2Rlcykge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZW5kID0gZW5kO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcblxudmFyIENvbnRleHQgPSBmdW5jdGlvbiAoc291cmNlLCBpbmRleCkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxuLy8gaHR0cHM6Ly93d3cuanNvbi5vcmcvanNvbi1lbi5odG1sXG5Db250ZXh0LnByb3RvdHlwZSA9IHtcbiAgZm9yazogZnVuY3Rpb24gKG5leHRJbmRleCkge1xuICAgIHJldHVybiBuZXcgQ29udGV4dCh0aGlzLnNvdXJjZSwgbmV4dEluZGV4KTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgdGhpcy5pbmRleCk7XG4gICAgdmFyIGZvcmsgPSB0aGlzLmZvcmsoaSk7XG4gICAgdmFyIGNociA9IGF0KHNvdXJjZSwgaSk7XG4gICAgaWYgKGV4ZWMoSVNfTlVNQkVSX1NUQVJULCBjaHIpKSByZXR1cm4gZm9yay5udW1iZXIoKTtcbiAgICBzd2l0Y2ggKGNocikge1xuICAgICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBmb3JrLm9iamVjdCgpO1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBmb3JrLmFycmF5KCk7XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBmb3JrLnN0cmluZygpO1xuICAgICAgY2FzZSAndCc6XG4gICAgICAgIHJldHVybiBmb3JrLmtleXdvcmQodHJ1ZSk7XG4gICAgICBjYXNlICdmJzpcbiAgICAgICAgcmV0dXJuIGZvcmsua2V5d29yZChmYWxzZSk7XG4gICAgICBjYXNlICduJzpcbiAgICAgICAgcmV0dXJuIGZvcmsua2V5d29yZChudWxsKTtcbiAgICB9IHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJyArIGNociArICdcIiBhdDogJyArIGkpO1xuICB9LFxuICBub2RlOiBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIG5vZGVzKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBlbmQsIHR5cGUgPyBudWxsIDogc2xpY2UodGhpcy5zb3VyY2UsIHN0YXJ0LCBlbmQpLCBub2Rlcyk7XG4gIH0sXG4gIG9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyAxO1xuICAgIHZhciBleHBlY3RLZXlwYWlyID0gZmFsc2U7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgaSA9IHRoaXMudW50aWwoWydcIicsICd9J10sIGkpO1xuICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICd9JyAmJiAhZXhwZWN0S2V5cGFpcikge1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUGFyc2luZyB0aGUga2V5XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mb3JrKGkpLnN0cmluZygpO1xuICAgICAgdmFyIGtleSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIGkgPSByZXN1bHQuZW5kO1xuICAgICAgaSA9IHRoaXMudW50aWwoWyc6J10sIGkpICsgMTtcbiAgICAgIC8vIFBhcnNpbmcgdmFsdWVcbiAgICAgIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gICAgICByZXN1bHQgPSB0aGlzLmZvcmsoaSkucGFyc2UoKTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KG5vZGVzLCBrZXksIHJlc3VsdCk7XG4gICAgICBjcmVhdGVQcm9wZXJ0eShvYmplY3QsIGtleSwgcmVzdWx0LnZhbHVlKTtcbiAgICAgIGkgPSB0aGlzLnVudGlsKFsnLCcsICd9J10sIHJlc3VsdC5lbmQpO1xuICAgICAgdmFyIGNociA9IGF0KHNvdXJjZSwgaSk7XG4gICAgICBpZiAoY2hyID09PSAnLCcpIHtcbiAgICAgICAgZXhwZWN0S2V5cGFpciA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAnfScpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9kZShPQkpFQ1QsIG9iamVjdCwgdGhpcy5pbmRleCwgaSwgbm9kZXMpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyAxO1xuICAgIHZhciBleHBlY3RFbGVtZW50ID0gZmFsc2U7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBpID0gdGhpcy5za2lwKElTX1dISVRFU1BBQ0UsIGkpO1xuICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICddJyAmJiAhZXhwZWN0RWxlbWVudCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZm9yayhpKS5wYXJzZSgpO1xuICAgICAgcHVzaChub2RlcywgcmVzdWx0KTtcbiAgICAgIHB1c2goYXJyYXksIHJlc3VsdC52YWx1ZSk7XG4gICAgICBpID0gdGhpcy51bnRpbChbJywnLCAnXSddLCByZXN1bHQuZW5kKTtcbiAgICAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnLCcpIHtcbiAgICAgICAgZXhwZWN0RWxlbWVudCA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoYXQoc291cmNlLCBpKSA9PT0gJ10nKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5vZGUoT0JKRUNULCBhcnJheSwgdGhpcy5pbmRleCwgaSwgbm9kZXMpO1xuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUpTT05TdHJpbmcodGhpcy5zb3VyY2UsIHRoaXMuaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKFBSSU1JVElWRSwgcGFyc2VkLnZhbHVlLCBpbmRleCwgcGFyc2VkLmVuZCk7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgdmFyIGkgPSBzdGFydEluZGV4O1xuICAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnLScpIGkrKztcbiAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJzAnKSBpKys7XG4gICAgZWxzZSBpZiAoZXhlYyhJU19OT05fWkVST19ESUdJVCwgYXQoc291cmNlLCBpKSkpIGkgPSB0aGlzLnNraXAoSVNfRElHSVQsIGkgKyAxKTtcbiAgICBlbHNlIHRocm93IG5ldyBTeW50YXhFcnJvcignRmFpbGVkIHRvIHBhcnNlIG51bWJlciBhdDogJyArIGkpO1xuICAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnLicpIGkgPSB0aGlzLnNraXAoSVNfRElHSVQsIGkgKyAxKTtcbiAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJ2UnIHx8IGF0KHNvdXJjZSwgaSkgPT09ICdFJykge1xuICAgICAgaSsrO1xuICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICcrJyB8fCBhdChzb3VyY2UsIGkpID09PSAnLScpIGkrKztcbiAgICAgIHZhciBleHBvbmVudFN0YXJ0SW5kZXggPSBpO1xuICAgICAgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgaSk7XG4gICAgICBpZiAoZXhwb25lbnRTdGFydEluZGV4ID09PSBpKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgbnVtYmVyJ3MgZXhwb25lbnQgdmFsdWUgYXQ6IFwiICsgaSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5vZGUoUFJJTUlUSVZFLCBOdW1iZXIoc2xpY2Uoc291cmNlLCBzdGFydEluZGV4LCBpKSksIHN0YXJ0SW5kZXgsIGkpO1xuICB9LFxuICBrZXl3b3JkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIga2V5d29yZCA9ICcnICsgdmFsdWU7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB2YXIgZW5kSW5kZXggPSBpbmRleCArIGtleXdvcmQubGVuZ3RoO1xuICAgIGlmIChzbGljZSh0aGlzLnNvdXJjZSwgaW5kZXgsIGVuZEluZGV4KSAhPT0ga2V5d29yZCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgdmFsdWUgYXQ6ICcgKyBpbmRleCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShQUklNSVRJVkUsIHZhbHVlLCBpbmRleCwgZW5kSW5kZXgpO1xuICB9LFxuICBza2lwOiBmdW5jdGlvbiAocmVnZXgsIGkpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIGlmICghZXhlYyhyZWdleCwgYXQoc291cmNlLCBpKSkpIGJyZWFrO1xuICAgIHJldHVybiBpO1xuICB9LFxuICB1bnRpbDogZnVuY3Rpb24gKGFycmF5LCBpKSB7XG4gICAgaSA9IHRoaXMuc2tpcChJU19XSElURVNQQUNFLCBpKTtcbiAgICB2YXIgY2hyID0gYXQodGhpcy5zb3VyY2UsIGkpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIGlmIChhcnJheVtqXSA9PT0gY2hyKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIicgKyBjaHIgKyAnXCIgYXQ6ICcgKyBpKTtcbiAgfVxufTtcblxudmFyIE5PX1NPVVJDRV9TVVBQT1JUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdW5zYWZlSW50ID0gJzkwMDcxOTkyNTQ3NDA5OTMnO1xuICB2YXIgc291cmNlO1xuICBuYXRpdmVQYXJzZSh1bnNhZmVJbnQsIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgc291cmNlID0gY29udGV4dC5zb3VyY2U7XG4gIH0pO1xuICByZXR1cm4gc291cmNlICE9PSB1bnNhZmVJbnQ7XG59KTtcblxudmFyIFBST1BFUl9CQVNFX1BBUlNFID0gTkFUSVZFX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgOSBidWdcbiAgcmV0dXJuIDEgLyBuYXRpdmVQYXJzZSgnLTAgXFx0JykgIT09IC1JbmZpbml0eTtcbn0pO1xuXG4vLyBgSlNPTi5wYXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24ucGFyc2Vcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWpzb24tcGFyc2Utd2l0aC1zb3VyY2VcbiQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBOT19TT1VSQ0VfU1VQUE9SVCB9LCB7XG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIFBST1BFUl9CQVNFX1BBUlNFICYmICFpc0NhbGxhYmxlKHJldml2ZXIpID8gbmF0aXZlUGFyc2UodGV4dCkgOiAkcGFyc2UodGV4dCwgcmV2aXZlcik7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDY5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA3KTtcbnZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDAyKTtcblxudmFyIFNldCA9IFNldEhlbHBlcnMuU2V0O1xudmFyIFNldFByb3RvdHlwZSA9IFNldEhlbHBlcnMucHJvdG87XG52YXIgZm9yRWFjaCA9IHVuY3VycnlUaGlzKFNldFByb3RvdHlwZS5mb3JFYWNoKTtcbnZhciBrZXlzID0gdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmtleXMpO1xudmFyIG5leHQgPSBrZXlzKG5ldyBTZXQoKSkubmV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2V0LCBmbiwgaW50ZXJydXB0aWJsZSkge1xuICByZXR1cm4gaW50ZXJydXB0aWJsZSA/IGl0ZXJhdGVTaW1wbGUoeyBpdGVyYXRvcjoga2V5cyhzZXQpLCBuZXh0OiBuZXh0IH0sIGZuKSA6IGZvckVhY2goc2V0LCBmbik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDgwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MjgpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzI3KTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1Mjc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIGhhcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpLmhhcyk7XG52YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE3MCk7XG52YXIgZ2V0U2V0UmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzg5KTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5pc1N1cGVyc2V0T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmlzc3VwZXJzZXRvZlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1cGVyc2V0T2Yob3RoZXIpIHtcbiAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICBpZiAoc2l6ZShPKSA8IG90aGVyUmVjLnNpemUpIHJldHVybiBmYWxzZTtcbiAgdmFyIGl0ZXJhdG9yID0gb3RoZXJSZWMuZ2V0SXRlcmF0b3IoKTtcbiAgcmV0dXJuIGl0ZXJhdGVTaW1wbGUoaXRlcmF0b3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCFoYXMoTywgZSkpIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgZmFsc2UpO1xuICB9KSAhPT0gZmFsc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTUxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCRTdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTc0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG5cbnZhciAkRXJyb3IgPSBFcnJvcjtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG5cbnZhciBURVNUID0gKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIFN0cmluZyhuZXcgJEVycm9yKGFyZykuc3RhY2spOyB9KSgnenhjYXNkJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVkb3Mvbm8tdnVsbmVyYWJsZSwgc29uYXJqcy9zbG93LXJlZ2V4IC0tIHNhZmVcbnZhciBWOF9PUl9DSEFLUkFfU1RBQ0tfRU5UUlkgPSAvXFxuXFxzKmF0IFteOl0qOlteXFxuXSovO1xudmFyIElTX1Y4X09SX0NIQUtSQV9TVEFDSyA9IFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWS50ZXN0KFRFU1QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdGFjaywgZHJvcEVudHJpZXMpIHtcbiAgaWYgKElTX1Y4X09SX0NIQUtSQV9TVEFDSyAmJiB0eXBlb2Ygc3RhY2sgPT0gJ3N0cmluZycgJiYgISRFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSkge1xuICAgIHdoaWxlIChkcm9wRW50cmllcy0tKSBzdGFjayA9IHJlcGxhY2Uoc3RhY2ssIFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWSwgJycpO1xuICB9IHJldHVybiBzdGFjaztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg2MjI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbFRoaXMuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChTdHJpbmcoV2Vha01hcCkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjQ2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHN0cmluZ0hhbmRsaW5nKSB7XG4gIGlmICghc3RyaW5nSGFuZGxpbmcgfHwgdHlwZW9mIG9iaiAhPT0gJ3N0cmluZycpIGFuT2JqZWN0KG9iaik7XG4gIHZhciBtZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChvYmopO1xuICByZXR1cm4gZ2V0SXRlcmF0b3JEaXJlY3QoYW5PYmplY3QobWV0aG9kICE9PSB1bmRlZmluZWQgPyBjYWxsKG1ldGhvZCwgb2JqKSA6IG9iaikpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODY4Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPT0gNDI7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODcyMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwNik7XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xudmFyIGZvckVhY2ggPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZm9yRWFjaCk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnNpemVgIGdldHRlclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy91cmwvcHVsbC83MzRcbmlmIChERVNDUklQVE9SUyAmJiAhKCdzaXplJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUpKSB7XG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdzaXplJywge1xuICAgIGdldDogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBmb3JFYWNoKHRoaXMsIGZ1bmN0aW9uICgpIHsgY291bnQrKzsgfSk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODcyNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3NDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTYpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kLCBlcy9uby1yZWZsZWN0IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoYXBwbHkpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShhcHBseSwgYXJndW1lbnRzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NzUwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDgwKTtcbnZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDAyKTtcbnZhciBzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTcwKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0NjkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG5cbnZhciBTZXQgPSBTZXRIZWxwZXJzLlNldDtcbnZhciBhZGQgPSBTZXRIZWxwZXJzLmFkZDtcbnZhciBoYXMgPSBTZXRIZWxwZXJzLmhhcztcblxuLy8gYFNldC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5pbnRlcnNlY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gIHZhciBPID0gYVNldCh0aGlzKTtcbiAgdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBpZiAoc2l6ZShPKSA+IG90aGVyUmVjLnNpemUpIHtcbiAgICBpdGVyYXRlU2ltcGxlKG90aGVyUmVjLmdldEl0ZXJhdG9yKCksIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoaGFzKE8sIGUpKSBhZGQocmVzdWx0LCBlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyYXRlU2V0KE8sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAob3RoZXJSZWMuaW5jbHVkZXMoZSkpIGFkZChyZXN1bHQsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3NzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg5ODE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTApO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMzk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxNDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBhbk9iamVjdE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTcyKTtcbnZhciBhU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYzKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIGJhc2U2NE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgwNCk7XG52YXIgZ2V0QWxwaGFiZXRPcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NCk7XG52YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjkpO1xuXG52YXIgYmFzZTY0QWxwaGFiZXQgPSBiYXNlNjRNYXAuYzJpO1xudmFyIGJhc2U2NFVybEFscGhhYmV0ID0gYmFzZTY0TWFwLmMyaVVybDtcblxudmFyIFN5bnRheEVycm9yID0gZ2xvYmFsVGhpcy5TeW50YXhFcnJvcjtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcbnZhciBhdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG5cbnZhciBza2lwQXNjaWlXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHN0cmluZywgaW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIGZvciAoO2luZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgdmFyIGNociA9IGF0KHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChjaHIgIT09ICcgJyAmJiBjaHIgIT09ICdcXHQnICYmIGNociAhPT0gJ1xcbicgJiYgY2hyICE9PSAnXFxmJyAmJiBjaHIgIT09ICdcXHInKSBicmVhaztcbiAgfSByZXR1cm4gaW5kZXg7XG59O1xuXG52YXIgZGVjb2RlQmFzZTY0Q2h1bmsgPSBmdW5jdGlvbiAoY2h1bmssIGFscGhhYmV0LCB0aHJvd09uRXh0cmFCaXRzKSB7XG4gIHZhciBjaHVua0xlbmd0aCA9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoY2h1bmtMZW5ndGggPCA0KSB7XG4gICAgY2h1bmsgKz0gY2h1bmtMZW5ndGggPT09IDIgPyAnQUEnIDogJ0EnO1xuICB9XG5cbiAgdmFyIHRyaXBsZXQgPSAoYWxwaGFiZXRbYXQoY2h1bmssIDApXSA8PCAxOClcbiAgICArIChhbHBoYWJldFthdChjaHVuaywgMSldIDw8IDEyKVxuICAgICsgKGFscGhhYmV0W2F0KGNodW5rLCAyKV0gPDwgNilcbiAgICArIGFscGhhYmV0W2F0KGNodW5rLCAzKV07XG5cbiAgdmFyIGNodW5rQnl0ZXMgPSBbXG4gICAgKHRyaXBsZXQgPj4gMTYpICYgMjU1LFxuICAgICh0cmlwbGV0ID4+IDgpICYgMjU1LFxuICAgIHRyaXBsZXQgJiAyNTVcbiAgXTtcblxuICBpZiAoY2h1bmtMZW5ndGggPT09IDIpIHtcbiAgICBpZiAodGhyb3dPbkV4dHJhQml0cyAmJiBjaHVua0J5dGVzWzFdICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4dHJhIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIFtjaHVua0J5dGVzWzBdXTtcbiAgfVxuXG4gIGlmIChjaHVua0xlbmd0aCA9PT0gMykge1xuICAgIGlmICh0aHJvd09uRXh0cmFCaXRzICYmIGNodW5rQnl0ZXNbMl0gIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRXh0cmEgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gW2NodW5rQnl0ZXNbMF0sIGNodW5rQnl0ZXNbMV1dO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rQnl0ZXM7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IGZ1bmN0aW9uIChieXRlcywgZWxlbWVudHMsIHdyaXR0ZW4pIHtcbiAgdmFyIGVsZW1lbnRzTGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZWxlbWVudHNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBieXRlc1t3cml0dGVuICsgaW5kZXhdID0gZWxlbWVudHNbaW5kZXhdO1xuICB9XG4gIHJldHVybiB3cml0dGVuICsgZWxlbWVudHNMZW5ndGg7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgbWF4LWRlcHRoIC0tIFRPRE8gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucywgaW50bywgbWF4TGVuZ3RoKSB7XG4gIGFTdHJpbmcoc3RyaW5nKTtcbiAgYW5PYmplY3RPclVuZGVmaW5lZChvcHRpb25zKTtcbiAgdmFyIGFscGhhYmV0ID0gZ2V0QWxwaGFiZXRPcHRpb24ob3B0aW9ucykgPT09ICdiYXNlNjQnID8gYmFzZTY0QWxwaGFiZXQgOiBiYXNlNjRVcmxBbHBoYWJldDtcbiAgdmFyIGxhc3RDaHVua0hhbmRsaW5nID0gb3B0aW9ucyA/IG9wdGlvbnMubGFzdENodW5rSGFuZGxpbmcgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGxhc3RDaHVua0hhbmRsaW5nID09PSB1bmRlZmluZWQpIGxhc3RDaHVua0hhbmRsaW5nID0gJ2xvb3NlJztcblxuICBpZiAobGFzdENodW5rSGFuZGxpbmcgIT09ICdsb29zZScgJiYgbGFzdENodW5rSGFuZGxpbmcgIT09ICdzdHJpY3QnICYmIGxhc3RDaHVua0hhbmRsaW5nICE9PSAnc3RvcC1iZWZvcmUtcGFydGlhbCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbmNvcnJlY3QgYGxhc3RDaHVua0hhbmRsaW5nYCBvcHRpb24nKTtcbiAgfVxuXG4gIGlmIChpbnRvKSBub3REZXRhY2hlZChpbnRvLmJ1ZmZlcik7XG5cbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBieXRlcyA9IGludG8gfHwgW107XG4gIHZhciB3cml0dGVuID0gMDtcbiAgdmFyIHJlYWQgPSAwO1xuICB2YXIgY2h1bmsgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcblxuICBpZiAobWF4TGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGluZGV4ID0gc2tpcEFzY2lpV2hpdGVzcGFjZShzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggPT09IHN0cmluZ0xlbmd0aCkge1xuICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGxhc3RDaHVua0hhbmRsaW5nID09PSAnc3RvcC1iZWZvcmUtcGFydGlhbCcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09ICdsb29zZScpIHtcbiAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ01hbGZvcm1lZCBwYWRkaW5nOiBleGFjdGx5IG9uZSBhZGRpdGlvbmFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3cml0dGVuID0gd3JpdGVCeXRlcyhieXRlcywgZGVjb2RlQmFzZTY0Q2h1bmsoY2h1bmssIGFscGhhYmV0LCBmYWxzZSksIHdyaXR0ZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTWlzc2luZyBwYWRkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWQgPSBzdHJpbmdMZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGNociA9IGF0KHN0cmluZywgaW5kZXgpO1xuICAgICsraW5kZXg7XG4gICAgaWYgKGNociA9PT0gJz0nKSB7XG4gICAgICBpZiAoY2h1bmsubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1BhZGRpbmcgaXMgdG9vIGVhcmx5Jyk7XG4gICAgICB9XG4gICAgICBpbmRleCA9IHNraXBBc2NpaVdoaXRlc3BhY2Uoc3RyaW5nLCBpbmRleCk7XG4gICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gc3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGxhc3RDaHVua0hhbmRsaW5nID09PSAnc3RvcC1iZWZvcmUtcGFydGlhbCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ01hbGZvcm1lZCBwYWRkaW5nOiBvbmx5IG9uZSA9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0KHN0cmluZywgaW5kZXgpID09PSAnPScpIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGluZGV4ID0gc2tpcEFzY2lpV2hpdGVzcGFjZShzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4IDwgc3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgYWZ0ZXIgcGFkZGluZycpO1xuICAgICAgfVxuICAgICAgd3JpdHRlbiA9IHdyaXRlQnl0ZXMoYnl0ZXMsIGRlY29kZUJhc2U2NENodW5rKGNodW5rLCBhbHBoYWJldCwgbGFzdENodW5rSGFuZGxpbmcgPT09ICdzdHJpY3QnKSwgd3JpdHRlbik7XG4gICAgICByZWFkID0gc3RyaW5nTGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghaGFzT3duKGFscGhhYmV0LCBjaHIpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIHZhciByZW1haW5pbmdCeXRlcyA9IG1heExlbmd0aCAtIHdyaXR0ZW47XG4gICAgaWYgKHJlbWFpbmluZ0J5dGVzID09PSAxICYmIGNodW5rLmxlbmd0aCA9PT0gMiB8fCByZW1haW5pbmdCeXRlcyA9PT0gMiAmJiBjaHVuay5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZTogd2UgY2FuIGZpdCBleGFjdGx5IHRoZSBudW1iZXIgb2YgYnl0ZXMgY3VycmVudGx5IHJlcHJlc2VudGVkIGJ5IGNodW5rLCBzbyB3ZSB3ZXJlIGp1c3QgY2hlY2tpbmcgZm9yIGA9YFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2h1bmsgKz0gY2hyO1xuICAgIGlmIChjaHVuay5sZW5ndGggPT09IDQpIHtcbiAgICAgIHdyaXR0ZW4gPSB3cml0ZUJ5dGVzKGJ5dGVzLCBkZWNvZGVCYXNlNjRDaHVuayhjaHVuaywgYWxwaGFiZXQsIGZhbHNlKSwgd3JpdHRlbik7XG4gICAgICBjaHVuayA9ICcnO1xuICAgICAgcmVhZCA9IGluZGV4O1xuICAgICAgaWYgKHdyaXR0ZW4gPT09IG1heExlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBieXRlczogYnl0ZXMsIHJlYWQ6IHJlYWQsIHdyaXR0ZW46IHdyaXR0ZW4gfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0NjkpO1xuXG52YXIgU2V0ID0gU2V0SGVscGVycy5TZXQ7XG52YXIgYWRkID0gU2V0SGVscGVycy5hZGQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNldCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuICBpdGVyYXRlKHNldCwgZnVuY3Rpb24gKGl0KSB7XG4gICAgYWRkKHJlc3VsdCwgaXQpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyOTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODk4MSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjMpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzE0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgbm90QU5hTiA9IF9fd2VicGFja19yZXF1aXJlX18oNDE0OSk7XG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1OTApO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NjIpO1xudmFyIGl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NCk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBEUk9QX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKCdkcm9wJywgMCk7XG52YXIgZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgIURST1BfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SXG4gICYmIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ2Ryb3AnLCBSYW5nZUVycm9yKTtcblxudmFyIEZPUkNFRCA9IElTX1BVUkUgfHwgRFJPUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgfHwgZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yO1xuXG52YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgdmFyIHJlc3VsdCwgZG9uZTtcbiAgd2hpbGUgKHRoaXMucmVtYWluaW5nKSB7XG4gICAgdGhpcy5yZW1haW5pbmctLTtcbiAgICByZXN1bHQgPSBhbk9iamVjdChjYWxsKG5leHQsIGl0ZXJhdG9yKSk7XG4gICAgZG9uZSA9IHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmU7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgfVxuICByZXN1bHQgPSBhbk9iamVjdChjYWxsKG5leHQsIGl0ZXJhdG9yKSk7XG4gIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICBpZiAoIWRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG59KTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5kcm9wYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmRyb3BcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGRyb3A6IGZ1bmN0aW9uIGRyb3AobGltaXQpIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcmVtYWluaW5nO1xuICAgIHRyeSB7XG4gICAgICByZW1haW5pbmcgPSB0b1Bvc2l0aXZlSW50ZWdlcihub3RBTmFOKCtsaW1pdCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHJlbWFpbmluZyk7XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yUHJveHkoZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyksIHtcbiAgICAgIHJlbWFpbmluZzogcmVtYWluaW5nXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDI5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBJU19OT0RFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTkzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoSVNfTk9ERSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUobmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gc2FmZVxuICAgICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gcmVxdWlyZShcIicgKyBuYW1lICsgJ1wiKScpKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDMyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbl9fd2VicGFja19yZXF1aXJlX18oNTIxMyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0MzM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsVGhpc1trZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTQ2Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzYwKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2OTkpO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mjc5KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExODEpO1xudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk2Nik7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3NjU3KS5JdGVyYXRvclByb3RvdHlwZSk7XG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUyOSk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JDbG9zZUFsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTM4NSk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIElURVJBVE9SX0hFTFBFUiA9ICdJdGVyYXRvckhlbHBlcic7XG52YXIgV1JBUF9GT1JfVkFMSURfSVRFUkFUT1IgPSAnV3JhcEZvclZhbGlkSXRlcmF0b3InO1xudmFyIE5PUk1BTCA9ICdub3JtYWwnO1xudmFyIFRIUk9XID0gJ3Rocm93JztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG5cbnZhciBjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlID0gZnVuY3Rpb24gKElTX0lURVJBVE9SKSB7XG4gIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoSVNfSVRFUkFUT1IgPyBXUkFQX0ZPUl9WQUxJRF9JVEVSQVRPUiA6IElURVJBVE9SX0hFTFBFUik7XG5cbiAgcmV0dXJuIGRlZmluZUJ1aWx0SW5zKGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSksIHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgIC8vIGZvciBzaW1wbGlmaWNhdGlvbjpcbiAgICAgIC8vICAgZm9yIGAlV3JhcEZvclZhbGlkSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG9yIHdpdGggYHN0YXRlLnJldHVybkhhbmRsZXJSZXN1bHRgIG91ciBgbmV4dEhhbmRsZXJgIHJldHVybnMgYEl0ZXJSZXN1bHRPYmplY3RgXG4gICAgICAvLyAgIGZvciBgJUl0ZXJhdG9ySGVscGVyUHJvdG90eXBlJS5uZXh0YCAtIGp1c3QgYSB2YWx1ZVxuICAgICAgaWYgKElTX0lURVJBVE9SKSByZXR1cm4gc3RhdGUubmV4dEhhbmRsZXIoKTtcbiAgICAgIGlmIChzdGF0ZS5kb25lKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0YXRlLm5leHRIYW5kbGVyKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5yZXR1cm5IYW5kbGVyUmVzdWx0ID8gcmVzdWx0IDogY3JlYXRlSXRlclJlc3VsdE9iamVjdChyZXN1bHQsIHN0YXRlLmRvbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBzdGF0ZS5pdGVyYXRvcjtcbiAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICAgICAgcmV0dXJuIHJldHVybk1ldGhvZCA/IGNhbGwocmV0dXJuTWV0aG9kLCBpdGVyYXRvcikgOiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaW5uZXIpIHRyeSB7XG4gICAgICAgIGl0ZXJhdG9yQ2xvc2Uoc3RhdGUuaW5uZXIuaXRlcmF0b3IsIE5PUk1BTCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgVEhST1csIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5vcGVuSXRlcnMpIHRyeSB7XG4gICAgICAgIGl0ZXJhdG9yQ2xvc2VBbGwoc3RhdGUub3Blbkl0ZXJzLCBOT1JNQUwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIFRIUk9XLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIE5PUk1BTCk7XG4gICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgV3JhcEZvclZhbGlkSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlKHRydWUpO1xudmFyIEl0ZXJhdG9ySGVscGVyUHJvdG90eXBlID0gY3JlYXRlSXRlcmF0b3JQcm94eVByb3RvdHlwZShmYWxzZSk7XG5cbmNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvckhlbHBlclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgJ0l0ZXJhdG9yIEhlbHBlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuZXh0SGFuZGxlciwgSVNfSVRFUkFUT1IsIFJFVFVSTl9IQU5ETEVSX1JFU1VMVCkge1xuICB2YXIgSXRlcmF0b3JQcm94eSA9IGZ1bmN0aW9uIEl0ZXJhdG9yKHJlY29yZCwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHN0YXRlLml0ZXJhdG9yID0gcmVjb3JkLml0ZXJhdG9yO1xuICAgICAgc3RhdGUubmV4dCA9IHJlY29yZC5uZXh0O1xuICAgIH0gZWxzZSBzdGF0ZSA9IHJlY29yZDtcbiAgICBzdGF0ZS50eXBlID0gSVNfSVRFUkFUT1IgPyBXUkFQX0ZPUl9WQUxJRF9JVEVSQVRPUiA6IElURVJBVE9SX0hFTFBFUjtcbiAgICBzdGF0ZS5yZXR1cm5IYW5kbGVyUmVzdWx0ID0gISFSRVRVUk5fSEFORExFUl9SRVNVTFQ7XG4gICAgc3RhdGUubmV4dEhhbmRsZXIgPSBuZXh0SGFuZGxlcjtcbiAgICBzdGF0ZS5jb3VudGVyID0gMDtcbiAgICBzdGF0ZS5kb25lID0gZmFsc2U7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCBzdGF0ZSk7XG4gIH07XG5cbiAgSXRlcmF0b3JQcm94eS5wcm90b3R5cGUgPSBJU19JVEVSQVRPUiA/IFdyYXBGb3JWYWxpZEl0ZXJhdG9yUHJvdG90eXBlIDogSXRlcmF0b3JIZWxwZXJQcm90b3R5cGU7XG5cbiAgcmV0dXJuIEl0ZXJhdG9yUHJveHk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDg2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBhbk9iamVjdE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTcyKTtcbnZhciBhblVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNTQpO1xudmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY5KTtcbnZhciBiYXNlNjRNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MDQpO1xudmFyIGdldEFscGhhYmV0T3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDQpO1xuXG52YXIgYmFzZTY0QWxwaGFiZXQgPSBiYXNlNjRNYXAuaTJjO1xudmFyIGJhc2U2NFVybEFscGhhYmV0ID0gYmFzZTY0TWFwLmkyY1VybDtcblxudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG5cbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsVGhpcy5VaW50OEFycmF5O1xuXG52YXIgSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgPSAhVWludDhBcnJheSB8fCAhVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQgfHwgIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0YXJnZXQudG9CYXNlNjQobnVsbCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0oKTtcblxuLy8gYFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvQmFzZTY0YCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5YnVmZmVyLWJhc2U2NFxuaWYgKFVpbnQ4QXJyYXkpICQoeyB0YXJnZXQ6ICdVaW50OEFycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgfSwge1xuICB0b0Jhc2U2NDogZnVuY3Rpb24gdG9CYXNlNjQoLyogb3B0aW9ucyAqLykge1xuICAgIHZhciBhcnJheSA9IGFuVWludDhBcnJheSh0aGlzKTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPyBhbk9iamVjdE9yVW5kZWZpbmVkKGFyZ3VtZW50c1swXSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGFscGhhYmV0ID0gZ2V0QWxwaGFiZXRPcHRpb24ob3B0aW9ucykgPT09ICdiYXNlNjQnID8gYmFzZTY0QWxwaGFiZXQgOiBiYXNlNjRVcmxBbHBoYWJldDtcbiAgICB2YXIgb21pdFBhZGRpbmcgPSAhIW9wdGlvbnMgJiYgISFvcHRpb25zLm9taXRQYWRkaW5nO1xuICAgIG5vdERldGFjaGVkKHRoaXMuYnVmZmVyKTtcblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdHJpcGxldDtcblxuICAgIHZhciBhdCA9IGZ1bmN0aW9uIChzaGlmdCkge1xuICAgICAgcmV0dXJuIGNoYXJBdChhbHBoYWJldCwgKHRyaXBsZXQgPj4gKDYgKiBzaGlmdCkpICYgNjMpO1xuICAgIH07XG5cbiAgICBmb3IgKDsgaSArIDIgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgICAgdHJpcGxldCA9IChhcnJheVtpXSA8PCAxNikgKyAoYXJyYXlbaSArIDFdIDw8IDgpICsgYXJyYXlbaSArIDJdO1xuICAgICAgcmVzdWx0ICs9IGF0KDMpICsgYXQoMikgKyBhdCgxKSArIGF0KDApO1xuICAgIH1cbiAgICBpZiAoaSArIDIgPT09IGxlbmd0aCkge1xuICAgICAgdHJpcGxldCA9IChhcnJheVtpXSA8PCAxNikgKyAoYXJyYXlbaSArIDFdIDw8IDgpO1xuICAgICAgcmVzdWx0ICs9IGF0KDMpICsgYXQoMikgKyBhdCgxKSArIChvbWl0UGFkZGluZyA/ICcnIDogJz0nKTtcbiAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgIHRyaXBsZXQgPSBhcnJheVtpXSA8PCAxNjtcbiAgICAgIHJlc3VsdCArPSBhdCgzKSArIGF0KDIpICsgKG9taXRQYWRkaW5nID8gJycgOiAnPT0nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTUwNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNik7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG52YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EICYmIEZ1bmN0aW9uUHJvdG90eXBlLmJpbmQuYmluZChjYWxsLCBjYWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1MTk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgzOSk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWxUaGlzLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1Mzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbChpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU2NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNik7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1Nzc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYXJyYXlXaXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTI4KTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjQ0KTtcbnZhciBpc0JpZ0ludEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA4KTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkxKTtcbnZhciB0b0JpZ0ludCA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1NCk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5nZXRUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcblxudmFyIFBST1BFUl9PUkRFUiA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbCwgZXMvbm8tdHlwZWQtYXJyYXlzLCBlcy9uby1hcnJheS1wcm90b3R5cGUtd2l0aCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG5ldyBJbnQ4QXJyYXkoMSlbJ3dpdGgnXSgyLCB7IHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHsgdGhyb3cgODsgfSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBzb21lIGVhcmx5IGltcGxlbWVudGF0aW9ucywgbGlrZSBXZWJLaXQsIGRvZXMgbm90IGZvbGxvdyB0aGUgZmluYWwgc2VtYW50aWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1jaGFuZ2UtYXJyYXktYnktY29weS9wdWxsLzg2XG4gICAgcmV0dXJuIGVycm9yID09PSA4O1xuICB9XG59KCk7XG5cbi8vIEJ1ZyBpbiBXZWJLaXQuIEl0IHNob3VsZCB0cnVuY2F0ZSBhIG5lZ2F0aXZlIGZyYWN0aW9uYWwgaW5kZXggdG8gemVybywgYnV0IGluc3RlYWQgdGhyb3dzIGFuIGVycm9yXG52YXIgVEhST1dfT05fTkVHQVRJVkVfRlJBQ1RJT05BTF9JTkRFWCA9IFBST1BFUl9PUkRFUiAmJiBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXR5cGVkLWFycmF5cywgZXMvbm8tYXJyYXktcHJvdG90eXBlLXdpdGggLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBuZXcgSW50OEFycmF5KDEpWyd3aXRoJ10oLTAuNSwgMSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0oKTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUud2l0aGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUud2l0aFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnd2l0aCcsIHsgJ3dpdGgnOiBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBPID0gYVR5cGVkQXJyYXkodGhpcyk7XG4gIHZhciByZWxhdGl2ZUluZGV4ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG4gIHZhciBhY3R1YWxWYWx1ZSA9IGlzQmlnSW50QXJyYXkoTykgPyB0b0JpZ0ludCh2YWx1ZSkgOiArdmFsdWU7XG4gIHJldHVybiBhcnJheVdpdGgoTywgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKE8pLCByZWxhdGl2ZUluZGV4LCBhY3R1YWxWYWx1ZSk7XG59IH1bJ3dpdGgnXSwgIVBST1BFUl9PUkRFUiB8fCBUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU5MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5MSk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSB0b0ludGVnZXJPckluZmluaXR5KGl0KTtcbiAgaWYgKHJlc3VsdCA8IDApIHRocm93IG5ldyAkUmFuZ2VFcnJvcihcIlRoZSBhcmd1bWVudCBjYW4ndCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTM5Nyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEwKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjE5OCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9PSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NjMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbl9fd2VicGFja19yZXF1aXJlX18oOTQ4Nik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk3OTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI2KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgzNTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gU2hvdWxkIGdldCBpdGVyYXRvciByZWNvcmQgb2YgYSBzZXQtbGlrZSBvYmplY3QgYmVmb3JlIGNsb25pbmcgdGhpc1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI4OTQzMFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc2V0IC0tIG5lZWRlZCBmb3IgdGVzdFxuICAgIHZhciBiYXNlU2V0ID0gbmV3IFNldCgpO1xuICAgIHZhciBzZXRMaWtlID0ge1xuICAgICAgc2l6ZTogMCxcbiAgICAgIGhhczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgIGtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBuZWVkZWQgZm9yIHRlc3RcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ25leHQnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBiYXNlU2V0LmNsZWFyKCk7XG4gICAgICAgICAgICBiYXNlU2V0LmFkZCg0KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZXN1bHQgPSBiYXNlU2V0W01FVEhPRF9OQU1FXShzZXRMaWtlKTtcblxuICAgIHJldHVybiByZXN1bHQuc2l6ZSA9PT0gMSAmJiByZXN1bHQudmFsdWVzKCkubmV4dCgpLnZhbHVlID09PSA0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTgpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOTEpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS53aXRoXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUud2l0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgQywgaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgdmFyIHJlbGF0aXZlSW5kZXggPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgdmFyIGFjdHVhbEluZGV4ID0gcmVsYXRpdmVJbmRleCA8IDAgPyBsZW4gKyByZWxhdGl2ZUluZGV4IDogcmVsYXRpdmVJbmRleDtcbiAgaWYgKGFjdHVhbEluZGV4ID49IGxlbiB8fCBhY3R1YWxJbmRleCA8IDApIHRocm93IG5ldyAkUmFuZ2VFcnJvcignSW5jb3JyZWN0IGluZGV4Jyk7XG4gIHZhciBBID0gbmV3IEMobGVuKTtcbiAgdmFyIGsgPSAwO1xuICBmb3IgKDsgayA8IGxlbjsgaysrKSBBW2tdID0gayA9PT0gYWN0dWFsSW5kZXggPyB2YWx1ZSA6IE9ba107XG4gIHJldHVybiBBO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyB2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcbi8qKioqKiovIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdH07XG4vKioqKioqLyBcbi8qKioqKiovIFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXG4vKioqKioqLyBcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIH1cbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzXG52YXIgZXNfYXJyYXlfcHVzaCA9IF9fd2VicGFja19yZXF1aXJlX18oNDExNCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuZGV0YWNoZWQuanNcbnZhciBlc19hcnJheV9idWZmZXJfZGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NzMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLnRyYW5zZmVyLmpzXG52YXIgZXNfYXJyYXlfYnVmZmVyX3RyYW5zZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTAwKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci50cmFuc2Zlci10by1maXhlZC1sZW5ndGguanNcbnZhciBlc19hcnJheV9idWZmZXJfdHJhbnNmZXJfdG9fZml4ZWRfbGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTM2KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzXG52YXIgZXNfaXRlcmF0b3JfY29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxMTEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IucmVkdWNlLmpzXG52YXIgZXNfaXRlcmF0b3JfcmVkdWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjM3KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UudHJ5LmpzXG52YXIgZXNfcHJvbWlzZV90cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2ODkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkud2l0aC5qc1xudmFyIGVzX3R5cGVkX2FycmF5X3dpdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NzcpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lm1hdGguc3VtLXByZWNpc2UuanNcbnZhciBlc25leHRfbWF0aF9zdW1fcHJlY2lzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzNSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQudWludDgtYXJyYXkuZnJvbS1iYXNlNjQuanNcbnZhciBlc25leHRfdWludDhfYXJyYXlfZnJvbV9iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MzIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnVpbnQ4LWFycmF5LnNldC1mcm9tLWJhc2U2NC5qc1xudmFyIGVzbmV4dF91aW50OF9hcnJheV9zZXRfZnJvbV9iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NDkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnVpbnQ4LWFycmF5LnNldC1mcm9tLWhleC5qc1xudmFyIGVzbmV4dF91aW50OF9hcnJheV9zZXRfZnJvbV9oZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3OTcpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnVpbnQ4LWFycmF5LnRvLWJhc2U2NC5qc1xudmFyIGVzbmV4dF91aW50OF9hcnJheV90b19iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2MzEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnVpbnQ4LWFycmF5LnRvLWhleC5qc1xudmFyIGVzbmV4dF91aW50OF9hcnJheV90b19oZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MjMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1leGNlcHRpb24uc3RhY2suanNcbnZhciB3ZWJfZG9tX2V4Y2VwdGlvbl9zdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oNDk3OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLnBhcnNlLmpzXG52YXIgd2ViX3VybF9wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4MSk7XG47Ly8gLi9zcmMvc2hhcmVkL3V0aWwuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBJU19FRElUSU5HOiAweDgwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIFNJR05BVFVSRTogMTAxLFxuICBDT01NRU5UOiAxMDJcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzLFxuICBISUdITElHSFRfQ09MT1I6IDMxLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMixcbiAgSElHSExJR0hUX0ZSRUU6IDMzLFxuICBISUdITElHSFRfU0hPV19BTEw6IDM0LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5MyxcbiAgcmF3RmlsbFBhdGg6IDk0XG59O1xuY29uc3QgRHJhd09QUyA9IHtcbiAgbW92ZVRvOiAwLFxuICBsaW5lVG86IDEsXG4gIGN1cnZlVG86IDIsXG4gIGNsb3NlUGF0aDogM1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5pbmZvKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbCh1cmwpIHtcbiAgc3dpdGNoICh1cmw/LnByb3RvY29sKSB7XG4gICAgY2FzZSBcImh0dHA6XCI6XG4gICAgY2FzZSBcImh0dHBzOlwiOlxuICAgIGNhc2UgXCJmdHA6XCI6XG4gICAgY2FzZSBcIm1haWx0bzpcIjpcbiAgICBjYXNlIFwidGVsOlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5hZGREZWZhdWx0UHJvdG9jb2wgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgICBjb25zdCBkb3RzID0gdXJsLm1hdGNoKC9cXC4vZyk7XG4gICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cnlDb252ZXJ0RW5jb2RpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICBjb25zdCBhYnNvbHV0ZVVybCA9IGJhc2VVcmwgPyBVUkwucGFyc2UodXJsLCBiYXNlVXJsKSA6IFVSTC5wYXJzZSh1cmwpO1xuICByZXR1cm4gX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkgPyBhYnNvbHV0ZVVybCA6IG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVVcmxIYXNoKHVybCwgaGFzaCwgYWxsb3dSZWwgPSBmYWxzZSkge1xuICBjb25zdCByZXMgPSBVUkwucGFyc2UodXJsKTtcbiAgaWYgKHJlcykge1xuICAgIHJlcy5oYXNoID0gaGFzaDtcbiAgICByZXR1cm4gcmVzLmhyZWY7XG4gIH1cbiAgaWYgKGFsbG93UmVsICYmIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBcImh0dHA6Ly9leGFtcGxlLmNvbVwiKSkge1xuICAgIHJldHVybiB1cmwuc3BsaXQoXCIjXCIsIDEpWzBdICsgYCR7aGFzaCA/IGAjJHtoYXNofWAgOiBcIlwifWA7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzLCBtaXNzaW5nKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlc3BvbnNlRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMubWlzc2luZyA9IG1pc3Npbmc7XG4gIH1cbn1cbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzdHJpbmczMih2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSA+PiAyNCAmIDB4ZmYsIHZhbHVlID4+IDE2ICYgMHhmZiwgdmFsdWUgPj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XG59XG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgdXRpbF9GZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkXCIsIHR5cGVvZiBJbWFnZURlY29kZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGxhdGZvcm0sXG4gICAgICB1c2VyQWdlbnRcbiAgICB9ID0gbmF2aWdhdG9yO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc0FuZHJvaWQ6IHVzZXJBZ2VudC5pbmNsdWRlcyhcIkFuZHJvaWRcIiksXG4gICAgICBpc0xpbnV4OiBwbGF0Zm9ybS5pbmNsdWRlcyhcIkxpbnV4XCIpLFxuICAgICAgaXNNYWM6IHBsYXRmb3JtLmluY2x1ZGVzKFwiTWFjXCIpLFxuICAgICAgaXNXaW5kb3dzOiBwbGF0Zm9ybS5pbmNsdWRlcyhcIldpblwiKSxcbiAgICAgIGlzRmlyZWZveDogdXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmNvbnN0IGhleE51bWJlcnMgPSBBcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLCBuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgZG9tTWF0cml4VG9UcmFuc2Zvcm0oZG0pIHtcbiAgICByZXR1cm4gW2RtLmEsIGRtLmIsIGRtLmMsIGRtLmQsIGRtLmUsIGRtLmZdO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNV07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIG11bHRpcGx5QnlET01NYXRyaXgobSwgbWQpIHtcbiAgICByZXR1cm4gW21bMF0gKiBtZC5hICsgbVsyXSAqIG1kLmIsIG1bMV0gKiBtZC5hICsgbVszXSAqIG1kLmIsIG1bMF0gKiBtZC5jICsgbVsyXSAqIG1kLmQsIG1bMV0gKiBtZC5jICsgbVszXSAqIG1kLmQsIG1bMF0gKiBtZC5lICsgbVsyXSAqIG1kLmYgKyBtWzRdLCBtWzFdICogbWQuZSArIG1bM10gKiBtZC5mICsgbVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0sIHBvcyA9IDApIHtcbiAgICBjb25zdCBwMCA9IHBbcG9zXTtcbiAgICBjb25zdCBwMSA9IHBbcG9zICsgMV07XG4gICAgcFtwb3NdID0gcDAgKiBtWzBdICsgcDEgKiBtWzJdICsgbVs0XTtcbiAgICBwW3BvcyArIDFdID0gcDAgKiBtWzFdICsgcDEgKiBtWzNdICsgbVs1XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm1Ub0JlemllcihwLCB0cmFuc2Zvcm0sIHBvcyA9IDApIHtcbiAgICBjb25zdCBtMCA9IHRyYW5zZm9ybVswXTtcbiAgICBjb25zdCBtMSA9IHRyYW5zZm9ybVsxXTtcbiAgICBjb25zdCBtMiA9IHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBtMyA9IHRyYW5zZm9ybVszXTtcbiAgICBjb25zdCBtNCA9IHRyYW5zZm9ybVs0XTtcbiAgICBjb25zdCBtNSA9IHRyYW5zZm9ybVs1XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgICAgY29uc3QgcEkgPSBwW3BvcyArIGldO1xuICAgICAgY29uc3QgcEkxID0gcFtwb3MgKyBpICsgMV07XG4gICAgICBwW3BvcyArIGldID0gcEkgKiBtMCArIHBJMSAqIG0yICsgbTQ7XG4gICAgICBwW3BvcyArIGkgKyAxXSA9IHBJICogbTEgKyBwSTEgKiBtMyArIG01O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBwMCA9IHBbMF07XG4gICAgY29uc3QgcDEgPSBwWzFdO1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHBbMF0gPSAocDAgKiBtWzNdIC0gcDEgKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIHBbMV0gPSAoLXAwICogbVsxXSArIHAxICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgfVxuICBzdGF0aWMgYXhpYWxBbGlnbmVkQm91bmRpbmdCb3gocmVjdCwgdHJhbnNmb3JtLCBvdXRwdXQpIHtcbiAgICBjb25zdCBtMCA9IHRyYW5zZm9ybVswXTtcbiAgICBjb25zdCBtMSA9IHRyYW5zZm9ybVsxXTtcbiAgICBjb25zdCBtMiA9IHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBtMyA9IHRyYW5zZm9ybVszXTtcbiAgICBjb25zdCBtNCA9IHRyYW5zZm9ybVs0XTtcbiAgICBjb25zdCBtNSA9IHRyYW5zZm9ybVs1XTtcbiAgICBjb25zdCByMCA9IHJlY3RbMF07XG4gICAgY29uc3QgcjEgPSByZWN0WzFdO1xuICAgIGNvbnN0IHIyID0gcmVjdFsyXTtcbiAgICBjb25zdCByMyA9IHJlY3RbM107XG4gICAgbGV0IGEwID0gbTAgKiByMCArIG00O1xuICAgIGxldCBhMiA9IGEwO1xuICAgIGxldCBhMSA9IG0wICogcjIgKyBtNDtcbiAgICBsZXQgYTMgPSBhMTtcbiAgICBsZXQgYjAgPSBtMyAqIHIxICsgbTU7XG4gICAgbGV0IGIyID0gYjA7XG4gICAgbGV0IGIxID0gbTMgKiByMyArIG01O1xuICAgIGxldCBiMyA9IGIxO1xuICAgIGlmIChtMSAhPT0gMCB8fCBtMiAhPT0gMCkge1xuICAgICAgY29uc3QgbTFyMCA9IG0xICogcjA7XG4gICAgICBjb25zdCBtMXIyID0gbTEgKiByMjtcbiAgICAgIGNvbnN0IG0ycjEgPSBtMiAqIHIxO1xuICAgICAgY29uc3QgbTJyMyA9IG0yICogcjM7XG4gICAgICBhMCArPSBtMnIxO1xuICAgICAgYTMgKz0gbTJyMTtcbiAgICAgIGExICs9IG0ycjM7XG4gICAgICBhMiArPSBtMnIzO1xuICAgICAgYjAgKz0gbTFyMDtcbiAgICAgIGIzICs9IG0xcjA7XG4gICAgICBiMSArPSBtMXIyO1xuICAgICAgYjIgKz0gbTFyMjtcbiAgICB9XG4gICAgb3V0cHV0WzBdID0gTWF0aC5taW4ob3V0cHV0WzBdLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgb3V0cHV0WzFdID0gTWF0aC5taW4ob3V0cHV0WzFdLCBiMCwgYjEsIGIyLCBiMyk7XG4gICAgb3V0cHV0WzJdID0gTWF0aC5tYXgob3V0cHV0WzJdLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgb3V0cHV0WzNdID0gTWF0aC5tYXgob3V0cHV0WzNdLCBiMCwgYjEsIGIyLCBiMyk7XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG1hdHJpeCwgb3V0cHV0KSB7XG4gICAgY29uc3QgbTAgPSBtYXRyaXhbMF07XG4gICAgY29uc3QgbTEgPSBtYXRyaXhbMV07XG4gICAgY29uc3QgbTIgPSBtYXRyaXhbMl07XG4gICAgY29uc3QgbTMgPSBtYXRyaXhbM107XG4gICAgY29uc3QgYSA9IG0wICoqIDIgKyBtMSAqKiAyO1xuICAgIGNvbnN0IGIgPSBtMCAqIG0yICsgbTEgKiBtMztcbiAgICBjb25zdCBjID0gbTIgKiogMiArIG0zICoqIDI7XG4gICAgY29uc3QgZmlyc3QgPSAoYSArIGMpIC8gMjtcbiAgICBjb25zdCBzZWNvbmQgPSBNYXRoLnNxcnQoZmlyc3QgKiogMiAtIChhICogYyAtIGIgKiogMikpO1xuICAgIG91dHB1dFswXSA9IE1hdGguc3FydChmaXJzdCArIHNlY29uZCB8fCAxKTtcbiAgICBvdXRwdXRbMV0gPSBNYXRoLnNxcnQoZmlyc3QgLSBzZWNvbmQgfHwgMSk7XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyBwb2ludEJvdW5kaW5nQm94KHgsIHksIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeCk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5KTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeSk7XG4gIH1cbiAgc3RhdGljIHJlY3RCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4MCwgeDEpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeTAsIHkxKTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4MSk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5MCwgeTEpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgdCwgbWluTWF4KSB7XG4gICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbXQgPSAxIC0gdDtcbiAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgIGNvbnN0IHR0dCA9IHR0ICogdDtcbiAgICBjb25zdCB4ID0gbXQgKiAobXQgKiAobXQgKiB4MCArIDMgKiB0ICogeDEpICsgMyAqIHR0ICogeDIpICsgdHR0ICogeDM7XG4gICAgY29uc3QgeSA9IG10ICogKG10ICogKG10ICogeTAgKyAzICogdCAqIHkxKSArIDMgKiB0dCAqIHkyKSArIHR0dCAqIHkzO1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeCk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5KTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeSk7XG4gIH1cbiAgc3RhdGljICNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIGEsIGIsIGMsIG1pbk1heCkge1xuICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYikgPj0gMWUtMTIpIHtcbiAgICAgICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgLWMgLyBiLCBtaW5NYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IGIgKiogMiAtIDQgKiBjICogYTtcbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XG4gICAgY29uc3QgYTIgPSAyICogYTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAoLWIgKyBzcXJ0RGVsdGEpIC8gYTIsIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iIC0gc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgzKTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5Myk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4MCwgeDMpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkzKTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXgwICsgMyAqICh4MSAtIHgyKSArIHgzKSwgNiAqICh4MCAtIDIgKiB4MSArIHgyKSwgMyAqICh4MSAtIHgwKSwgbWluTWF4KTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXkwICsgMyAqICh5MSAtIHkyKSArIHkzKSwgNiAqICh5MCAtIDIgKiB5MSArIHkyKSwgMyAqICh5MSAtIHkwKSwgbWluTWF4KTtcbiAgfVxufVxuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdKSk7XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIsIGtlZXBFc2NhcGVTZXF1ZW5jZSA9IGZhbHNlKSB7XG4gIGlmIChzdHJbMF0gPj0gXCJcXHhFRlwiKSB7XG4gICAgbGV0IGVuY29kaW5nO1xuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmJlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhGRlwiICYmIHN0clsxXSA9PT0gXCJcXHhGRVwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2bGVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEVGXCIgJiYgc3RyWzFdID09PSBcIlxceEJCXCIgJiYgc3RyWzJdID09PSBcIlxceEJGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtOFwiO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyhzdHIpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgaWYgKGtlZXBFc2NhcGVTZXF1ZW5jZSB8fCAhZGVjb2RlZC5pbmNsdWRlcyhcIlxceDFiXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZUFsbCgvXFx4MWJbXlxceDFiXSooPzpcXHgxYnwkKS9nLCBcIlwiKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHdhcm4oYHN0cmluZ1RvUERGU3RyaW5nOiBcIiR7ZXh9XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKCFrZWVwRXNjYXBlU2VxdWVuY2UgJiYgY2hhckNvZGUgPT09IDB4MWIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBpaSAmJiBzdHIuY2hhckNvZGVBdChpKSAhPT0gMHgxYikge31cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbY2hhckNvZGVdO1xuICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XG4gIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxubGV0IE5vcm1hbGl6ZVJlZ2V4ID0gbnVsbDtcbmxldCBOb3JtYWxpemF0aW9uTWFwID0gbnVsbDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaWNvZGUoc3RyKSB7XG4gIGlmICghTm9ybWFsaXplUmVnZXgpIHtcbiAgICBOb3JtYWxpemVSZWdleCA9IC8oW1xcdTAwYTBcXHUwMGI1XFx1MDM3ZVxcdTBlYjNcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjEyNlxcdWZiMDAtXFx1ZmIwNFxcdWZiMDZcXHVmYjIwLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYmExXFx1ZmJhNC1cXHVmYmE5XFx1ZmJhZS1cXHVmYmIxXFx1ZmJkMy1cXHVmYmRjXFx1ZmJkZS1cXHVmYmU3XFx1ZmJlYS1cXHVmYmY4XFx1ZmJmYy1cXHVmYmZkXFx1ZmMwMC1cXHVmYzVkXFx1ZmM2NC1cXHVmY2YxXFx1ZmNmNS1cXHVmZDNkXFx1ZmQ4OFxcdWZkZjRcXHVmZGZhLVxcdWZkZmJcXHVmZTcxXFx1ZmU3N1xcdWZlNzlcXHVmZTdiXFx1ZmU3ZF0rKXwoXFx1ZmIwNSspL2d1O1xuICAgIE5vcm1hbGl6YXRpb25NYXAgPSBuZXcgTWFwKFtbXCLvrIVcIiwgXCLFv3RcIl1dKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2VBbGwoTm9ybWFsaXplUmVnZXgsIChfLCBwMSwgcDIpID0+IHAxID8gcDEubm9ybWFsaXplKFwiTkZLQ1wiKSA6IE5vcm1hbGl6YXRpb25NYXAuZ2V0KHAyKSk7XG59XG5mdW5jdGlvbiBnZXRVdWlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21VVUlEID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTtcbiAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcoYnVmKTtcbn1cbmNvbnN0IEFubm90YXRpb25QcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2lkX1wiO1xuZnVuY3Rpb24gX2lzVmFsaWRFeHBsaWNpdERlc3QodmFsaWRSZWYsIHZhbGlkTmFtZSwgZGVzdCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZGVzdCkgfHwgZGVzdC5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFtwYWdlLCB6b29tLCAuLi5hcmdzXSA9IGRlc3Q7XG4gIGlmICghdmFsaWRSZWYocGFnZSkgJiYgIU51bWJlci5pc0ludGVnZXIocGFnZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCF2YWxpZE5hbWUoem9vbSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICBsZXQgYWxsb3dOdWxsID0gdHJ1ZTtcbiAgc3dpdGNoICh6b29tLm5hbWUpIHtcbiAgICBjYXNlIFwiWFlaXCI6XG4gICAgICBpZiAoYXJnc0xlbiA8IDIgfHwgYXJnc0xlbiA+IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZpdFwiOlxuICAgIGNhc2UgXCJGaXRCXCI6XG4gICAgICByZXR1cm4gYXJnc0xlbiA9PT0gMDtcbiAgICBjYXNlIFwiRml0SFwiOlxuICAgIGNhc2UgXCJGaXRCSFwiOlxuICAgIGNhc2UgXCJGaXRWXCI6XG4gICAgY2FzZSBcIkZpdEJWXCI6XG4gICAgICBpZiAoYXJnc0xlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZpdFJcIjpcbiAgICAgIGlmIChhcmdzTGVuICE9PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFsbG93TnVsbCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIgfHwgYWxsb3dOdWxsICYmIGFyZyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIE1hdGhDbGFtcCh2LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcbn1cbmZ1bmN0aW9uIHRvSGV4VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvSGV4KSB7XG4gICAgcmV0dXJuIGFyci50b0hleCgpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGFyciwgbnVtID0+IGhleE51bWJlcnNbbnVtXSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvQmFzZTY0KSB7XG4gICAgcmV0dXJuIGFyci50b0Jhc2U2NCgpO1xuICB9XG4gIHJldHVybiBidG9hKGJ5dGVzVG9TdHJpbmcoYXJyKSk7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTY0VXRpbChzdHIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCkge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhhdG9iKHN0cikpO1xufVxuaWYgKHR5cGVvZiBNYXRoLnN1bVByZWNpc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICBNYXRoLnN1bVByZWNpc2UgPSBmdW5jdGlvbiAobnVtYmVycykge1xuICAgIHJldHVybiBudW1iZXJzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICB9O1xufVxuaWYgKHR5cGVvZiBBYm9ydFNpZ25hbC5hbnkgIT09IFwiZnVuY3Rpb25cIikge1xuICBBYm9ydFNpZ25hbC5hbnkgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gYWM7XG4gICAgZm9yIChjb25zdCBzIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBpZiAocy5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHMucmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBzLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGFjLmFib3J0KHMucmVhc29uKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfTtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IubWFwLmpzXG52YXIgZXNfaXRlcmF0b3JfbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzAxKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5kZWxldGUuanNcbnZhciB3ZWJfdXJsX3NlYXJjaF9wYXJhbXNfZGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjAzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5oYXMuanNcbnZhciB3ZWJfdXJsX3NlYXJjaF9wYXJhbXNfaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTY2KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5zaXplLmpzXG52YXIgd2ViX3VybF9zZWFyY2hfcGFyYW1zX3NpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3MjEpO1xuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX3RleHQuanNcblxuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX2xheWVyLmpzXG5cblxuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHR5cGUgPSBcInRleHRcIikge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMudXNlclVuaXQgPSB1c2VyVW5pdDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBzY2FsZSAqPSB1c2VyVW5pdDtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiArPSAzNjA7XG4gICAgfVxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldCByYXdEaW1zKCkge1xuICAgIGNvbnN0IGRpbXMgPSB0aGlzLnZpZXdCb3g7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInJhd0RpbXNcIiwge1xuICAgICAgcGFnZVdpZHRoOiBkaW1zWzJdIC0gZGltc1swXSxcbiAgICAgIHBhZ2VIZWlnaHQ6IGRpbXNbM10gLSBkaW1zWzFdLFxuICAgICAgcGFnZVg6IGRpbXNbMF0sXG4gICAgICBwYWdlWTogZGltc1sxXVxuICAgIH0pO1xuICB9XG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBbcmVjdFswXSwgcmVjdFsxXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybSh0b3BMZWZ0LCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShib3R0b21SaWdodCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgY29uc3QgcCA9IFt4LCB5XTtcbiAgICBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5mdW5jdGlvbiBpc0RhdGFTY2hlbWUodXJsKSB7XG4gIGNvbnN0IGlpID0gdXJsLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlpICYmIHVybFtpXS50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cbmZ1bmN0aW9uIGlzUGRmRmlsZShmaWxlbmFtZSkge1xuICByZXR1cm4gdHlwZW9mIGZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsKSB7XG4gIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgIHdhcm4oJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBnZXRVUkwgPSB1cmxTdHJpbmcgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybFN0cmluZykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudCh1cmxTdHJpbmcpLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbmV3VVJMID0gZ2V0VVJMKHVybCk7XG4gIGlmICghbmV3VVJMKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBkZWNvZGUgPSBuYW1lID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICBpZiAoZGVjb2RlZC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbiAgICAgICAgaWYgKGRlY29kZWQudGVzdCgvXlxcLnBkZiQvaSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwZGZSZWdleCA9IC9cXC5wZGYkL2k7XG4gIGNvbnN0IGZpbGVuYW1lID0gbmV3VVJMLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5hdCgtMSk7XG4gIGlmIChwZGZSZWdleC50ZXN0KGZpbGVuYW1lKSkge1xuICAgIHJldHVybiBkZWNvZGUoZmlsZW5hbWUpO1xuICB9XG4gIGlmIChuZXdVUkwuc2VhcmNoUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbShuZXdVUkwuc2VhcmNoUGFyYW1zLnZhbHVlcygpKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChwZGZSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obmV3VVJMLnNlYXJjaFBhcmFtcy5rZXlzKCkpLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAocGRmUmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld1VSTC5oYXNoKSB7XG4gICAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICAgIGNvbnN0IGhhc2hGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhuZXdVUkwuaGFzaCk7XG4gICAgaWYgKGhhc2hGaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGRlY29kZShoYXNoRmlsZW5hbWVbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgY29uc3QgcmVzID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiByZXM/LnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcmVzPy5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy4jcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdDogMSxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICB3YXJuKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgc3Bhbi5zdHlsZS5jb2xvclNjaGVtZSA9IFwib25seSBsaWdodFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IHV0aWxfRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHt3fSwgdmFyKC0tc2NhbGUtcm91bmQteCkpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7aH0sIHZhcigtLXNjYWxlLXJvdW5kLXkpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvXG4gICAgfSA9IE91dHB1dFNjYWxlO1xuICAgIHRoaXMuc3ggPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc3kgPSBwaXhlbFJhdGlvO1xuICB9XG4gIGdldCBzY2FsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggIT09IDEgfHwgdGhpcy5zeSAhPT0gMTtcbiAgfVxuICBnZXQgc3ltbWV0cmljKCkge1xuICAgIHJldHVybiB0aGlzLnN4ID09PSB0aGlzLnN5O1xuICB9XG4gIGxpbWl0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIG1heFBpeGVscywgbWF4RGltLCBjYXBBcmVhRmFjdG9yID0gLTEpIHtcbiAgICBsZXQgbWF4QXJlYVNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhXaWR0aFNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IEluZmluaXR5O1xuICAgIG1heFBpeGVscyA9IE91dHB1dFNjYWxlLmNhcFBpeGVscyhtYXhQaXhlbHMsIGNhcEFyZWFGYWN0b3IpO1xuICAgIGlmIChtYXhQaXhlbHMgPiAwKSB7XG4gICAgICBtYXhBcmVhU2NhbGUgPSBNYXRoLnNxcnQobWF4UGl4ZWxzIC8gKHdpZHRoICogaGVpZ2h0KSk7XG4gICAgfVxuICAgIGlmIChtYXhEaW0gIT09IC0xKSB7XG4gICAgICBtYXhXaWR0aFNjYWxlID0gbWF4RGltIC8gd2lkdGg7XG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IG1heERpbSAvIGhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbWF4U2NhbGUgPSBNYXRoLm1pbihtYXhBcmVhU2NhbGUsIG1heFdpZHRoU2NhbGUsIG1heEhlaWdodFNjYWxlKTtcbiAgICBpZiAodGhpcy5zeCA+IG1heFNjYWxlIHx8IHRoaXMuc3kgPiBtYXhTY2FsZSkge1xuICAgICAgdGhpcy5zeCA9IG1heFNjYWxlO1xuICAgICAgdGhpcy5zeSA9IG1heFNjYWxlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB9XG4gIHN0YXRpYyBjYXBQaXhlbHMobWF4UGl4ZWxzLCBjYXBBcmVhRmFjdG9yKSB7XG4gICAgaWYgKGNhcEFyZWFGYWN0b3IgPj0gMCkge1xuICAgICAgY29uc3Qgd2luUGl4ZWxzID0gTWF0aC5jZWlsKHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCAqIHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKiogMiAqICgxICsgY2FwQXJlYUZhY3RvciAvIDEwMCkpO1xuICAgICAgcmV0dXJuIG1heFBpeGVscyA+IDAgPyBNYXRoLm1pbihtYXhQaXhlbHMsIHdpblBpeGVscykgOiB3aW5QaXhlbHM7XG4gICAgfVxuICAgIHJldHVybiBtYXhQaXhlbHM7XG4gIH1cbn1cbmNvbnN0IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzID0gW1wiaW1hZ2UvYXBuZ1wiLCBcImltYWdlL2F2aWZcIiwgXCJpbWFnZS9ibXBcIiwgXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2Uvc3ZnK3htbFwiLCBcImltYWdlL3dlYnBcIiwgXCJpbWFnZS94LWljb25cIl07XG5jbGFzcyBDb2xvclNjaGVtZSB7XG4gIHN0YXRpYyBnZXQgaXNEYXJrTW9kZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNEYXJrTW9kZVwiLCAhIXdpbmRvdz8ubWF0Y2hNZWRpYT8uKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKTtcbiAgfVxufVxuY2xhc3MgQ1NTQ29uc3RhbnRzIHtcbiAgc3RhdGljIGdldCBjb21tZW50Rm9yZWdyb3VuZENvbG9yKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21tZW50XCIsIFwic2lkZWJhclwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBlbGVtZW50O1xuICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHN0eWxlLmNvbG9yID0gXCJ2YXIoLS1jb21tZW50LWZnLWNvbG9yKVwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGVsZW1lbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yXG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImNvbW1lbnRGb3JlZ3JvdW5kQ29sb3JcIiwgZ2V0UkdCKGNvbG9yKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3BhY2l0eShyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChvcGFjaXR5ID8/IDEsIDApLCAxKTtcbiAgY29uc3Qgd2hpdGUgPSAyNTUgKiAoMSAtIG9wYWNpdHkpO1xuICByID0gTWF0aC5yb3VuZChyICogb3BhY2l0eSArIHdoaXRlKTtcbiAgZyA9IE1hdGgucm91bmQoZyAqIG9wYWNpdHkgKyB3aGl0ZSk7XG4gIGIgPSBNYXRoLnJvdW5kKGIgKiBvcGFjaXR5ICsgd2hpdGUpO1xuICByZXR1cm4gW3IsIGcsIGJdO1xufVxuZnVuY3Rpb24gUkdCVG9IU0wocmdiLCBvdXRwdXQpIHtcbiAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICBvdXRwdXRbMF0gPSBvdXRwdXRbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XG4gICAgb3V0cHV0WzFdID0gbCA8IDAuNSA/IGQgLyAobWF4ICsgbWluKSA6IGQgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjpcbiAgICAgICAgb3V0cHV0WzBdID0gKChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApKSAqIDYwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgb3V0cHV0WzBdID0gKChiIC0gcikgLyBkICsgMikgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGI6XG4gICAgICAgIG91dHB1dFswXSA9ICgociAtIGcpIC8gZCArIDQpICogNjA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvdXRwdXRbMl0gPSBsO1xufVxuZnVuY3Rpb24gSFNMVG9SR0IoaHNsLCBvdXRwdXQpIHtcbiAgY29uc3QgaCA9IGhzbFswXTtcbiAgY29uc3QgcyA9IGhzbFsxXTtcbiAgY29uc3QgbCA9IGhzbFsyXTtcbiAgY29uc3QgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoaCAvIDYwICUgMiAtIDEpKTtcbiAgY29uc3QgbSA9IGwgLSBjIC8gMjtcbiAgc3dpdGNoIChNYXRoLmZsb29yKGggLyA2MCkpIHtcbiAgICBjYXNlIDA6XG4gICAgICBvdXRwdXRbMF0gPSBjICsgbTtcbiAgICAgIG91dHB1dFsxXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzJdID0gbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIG91dHB1dFswXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzFdID0gYyArIG07XG4gICAgICBvdXRwdXRbMl0gPSBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgb3V0cHV0WzBdID0gbTtcbiAgICAgIG91dHB1dFsxXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzJdID0geCArIG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBvdXRwdXRbMF0gPSBtO1xuICAgICAgb3V0cHV0WzFdID0geCArIG07XG4gICAgICBvdXRwdXRbMl0gPSBjICsgbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIG91dHB1dFswXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzFdID0gbTtcbiAgICAgIG91dHB1dFsyXSA9IGMgKyBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgIGNhc2UgNjpcbiAgICAgIG91dHB1dFswXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzFdID0gbTtcbiAgICAgIG91dHB1dFsyXSA9IHggKyBtO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVMdW1pbmFuY2UoeCkge1xuICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbn1cbmZ1bmN0aW9uIGNvbnRyYXN0UmF0aW8oaHNsMSwgaHNsMiwgb3V0cHV0KSB7XG4gIEhTTFRvUkdCKGhzbDEsIG91dHB1dCk7XG4gIG91dHB1dC5tYXAoY29tcHV0ZUx1bWluYW5jZSk7XG4gIGNvbnN0IGx1bTEgPSAwLjIxMjYgKiBvdXRwdXRbMF0gKyAwLjcxNTIgKiBvdXRwdXRbMV0gKyAwLjA3MjIgKiBvdXRwdXRbMl07XG4gIEhTTFRvUkdCKGhzbDIsIG91dHB1dCk7XG4gIG91dHB1dC5tYXAoY29tcHV0ZUx1bWluYW5jZSk7XG4gIGNvbnN0IGx1bTIgPSAwLjIxMjYgKiBvdXRwdXRbMF0gKyAwLjcxNTIgKiBvdXRwdXRbMV0gKyAwLjA3MjIgKiBvdXRwdXRbMl07XG4gIHJldHVybiBsdW0xID4gbHVtMiA/IChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpIDogKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG59XG5jb25zdCBjb250cmFzdENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZmluZENvbnRyYXN0Q29sb3IoYmFzZUNvbG9yLCBmaXhlZENvbG9yKSB7XG4gIGNvbnN0IGtleSA9IGJhc2VDb2xvclswXSArIGJhc2VDb2xvclsxXSAqIDB4MTAwICsgYmFzZUNvbG9yWzJdICogMHgxMDAwMCArIGZpeGVkQ29sb3JbMF0gKiAweDEwMDAwMDAgKyBmaXhlZENvbG9yWzFdICogMHgxMDAwMDAwMDAgKyBmaXhlZENvbG9yWzJdICogMHgxMDAwMDAwMDAwMDtcbiAgbGV0IGNhY2hlZFZhbHVlID0gY29udHJhc3RDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgY29uc3Qgb3V0cHV0ID0gYXJyYXkuc3ViYXJyYXkoMCwgMyk7XG4gIGNvbnN0IGJhc2VIU0wgPSBhcnJheS5zdWJhcnJheSgzLCA2KTtcbiAgUkdCVG9IU0woYmFzZUNvbG9yLCBiYXNlSFNMKTtcbiAgY29uc3QgZml4ZWRIU0wgPSBhcnJheS5zdWJhcnJheSg2LCA5KTtcbiAgUkdCVG9IU0woZml4ZWRDb2xvciwgZml4ZWRIU0wpO1xuICBjb25zdCBpc0ZpeGVkQ29sb3JEYXJrID0gZml4ZWRIU0xbMl0gPCAwLjU7XG4gIGNvbnN0IG1pbkNvbnRyYXN0ID0gaXNGaXhlZENvbG9yRGFyayA/IDEyIDogNC41O1xuICBiYXNlSFNMWzJdID0gaXNGaXhlZENvbG9yRGFyayA/IE1hdGguc3FydChiYXNlSFNMWzJdKSA6IDEgLSBNYXRoLnNxcnQoMSAtIGJhc2VIU0xbMl0pO1xuICBpZiAoY29udHJhc3RSYXRpbyhiYXNlSFNMLCBmaXhlZEhTTCwgb3V0cHV0KSA8IG1pbkNvbnRyYXN0KSB7XG4gICAgbGV0IHN0YXJ0LCBlbmQ7XG4gICAgaWYgKGlzRml4ZWRDb2xvckRhcmspIHtcbiAgICAgIHN0YXJ0ID0gYmFzZUhTTFsyXTtcbiAgICAgIGVuZCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IGJhc2VIU0xbMl07XG4gICAgfVxuICAgIGNvbnN0IFBSRUNJU0lPTiA9IDAuMDA1O1xuICAgIHdoaWxlIChlbmQgLSBzdGFydCA+IFBSRUNJU0lPTikge1xuICAgICAgY29uc3QgbWlkID0gYmFzZUhTTFsyXSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgaWYgKGlzRml4ZWRDb2xvckRhcmsgPT09IGNvbnRyYXN0UmF0aW8oYmFzZUhTTCwgZml4ZWRIU0wsIG91dHB1dCkgPCBtaW5Db250cmFzdCkge1xuICAgICAgICBzdGFydCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZUhTTFsyXSA9IGlzRml4ZWRDb2xvckRhcmsgPyBlbmQgOiBzdGFydDtcbiAgfVxuICBIU0xUb1JHQihiYXNlSFNMLCBvdXRwdXQpO1xuICBjYWNoZWRWYWx1ZSA9IFV0aWwubWFrZUhleENvbG9yKE1hdGgucm91bmQob3V0cHV0WzBdICogMjU1KSwgTWF0aC5yb3VuZChvdXRwdXRbMV0gKiAyNTUpLCBNYXRoLnJvdW5kKG91dHB1dFsyXSAqIDI1NSkpO1xuICBjb250cmFzdENhY2hlLnNldChrZXksIGNhY2hlZFZhbHVlKTtcbiAgcmV0dXJuIGNhY2hlZFZhbHVlO1xufVxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoe1xuICBodG1sLFxuICBkaXIsXG4gIGNsYXNzTmFtZVxufSwgY29udGFpbmVyKSB7XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBpZiAodHlwZW9mIGh0bWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5kaXIgPSBkaXIgfHwgXCJhdXRvXCI7XG4gICAgY29uc3QgbGluZXMgPSBodG1sLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcmFnbWVudC5hcHBlbmQocCk7XG4gIH0gZWxzZSB7XG4gICAgWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgIHhmYUh0bWw6IGh0bWwsXG4gICAgICBkaXY6IGZyYWdtZW50LFxuICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCJcbiAgICB9KTtcbiAgfVxuICBmcmFnbWVudC5maXJzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJyaWNoVGV4dFwiLCBjbGFzc05hbWUpO1xuICBjb250YWluZXIuYXBwZW5kKGZyYWdtZW50KTtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IudGFrZS5qc1xudmFyIGVzX2l0ZXJhdG9yX3Rha2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NzIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS53aXRoLXJlc29sdmVycy5qc1xudmFyIGVzX3Byb21pc2Vfd2l0aF9yZXNvbHZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2MjgpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmRpZmZlcmVuY2UudjIuanNcbnZhciBlc19zZXRfZGlmZmVyZW5jZV92MiA9IF9fd2VicGFja19yZXF1aXJlX18oNzY0Mik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuaW50ZXJzZWN0aW9uLnYyLmpzXG52YXIgZXNfc2V0X2ludGVyc2VjdGlvbl92MiA9IF9fd2VicGFja19yZXF1aXJlX18oODAwNCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuaXMtZGlzam9pbnQtZnJvbS52Mi5qc1xudmFyIGVzX3NldF9pc19kaXNqb2ludF9mcm9tX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODUzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5pcy1zdWJzZXQtb2YudjIuanNcbnZhciBlc19zZXRfaXNfc3Vic2V0X29mX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODc2KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5pcy1zdXBlcnNldC1vZi52Mi5qc1xudmFyIGVzX3NldF9pc19zdXBlcnNldF9vZl92MiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3NSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuc3ltbWV0cmljLWRpZmZlcmVuY2UudjIuanNcbnZhciBlc19zZXRfc3ltbWV0cmljX2RpZmZlcmVuY2VfdjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMjQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LnVuaW9uLnYyLmpzXG52YXIgZXNfc2V0X3VuaW9uX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjk4KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmRyb3AuanNcbnZhciBlc19pdGVyYXRvcl9kcm9wID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzE0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmV2ZXJ5LmpzXG52YXIgZXNfaXRlcmF0b3JfZXZlcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNDgpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3Iuc29tZS5qc1xudmFyIGVzX2l0ZXJhdG9yX3NvbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NzkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lmpzb24ucGFyc2UuanNcbnZhciBlc25leHRfanNvbl9wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oODMzNSk7XG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbGJhci5qc1xuXG5jbGFzcyBFZGl0b3JUb29sYmFyIHtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZWRpdG9yO1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2NvbW1lbnQgPSBudWxsO1xuICAjY29tbWVudEJ1dHRvbkRpdmlkZXIgPSBudWxsO1xuICAjc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24gPSBudWxsO1xuICBzdGF0aWMgI2wxMG5SZW1vdmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgRWRpdG9yVG9vbGJhci4jbDEwblJlbW92ZSB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBmcmVldGV4dDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWZyZWV0ZXh0LWJ1dHRvblwiLFxuICAgICAgaGlnaGxpZ2h0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtaGlnaGxpZ2h0LWJ1dHRvblwiLFxuICAgICAgaW5rOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtaW5rLWJ1dHRvblwiLFxuICAgICAgc3RhbXA6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1zdGFtcC1idXR0b25cIixcbiAgICAgIHNpZ25hdHVyZTogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXNpZ25hdHVyZS1idXR0b25cIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTGlzdC5hZGQoXCJlZGl0VG9vbGJhclwiLCBcImhpZGRlblwiKTtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgRWRpdG9yVG9vbGJhci4jcG9pbnRlckRvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLnRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBlZGl0VG9vbGJhcjtcbiAgICAgIGNvbnN0IHggPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXTtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgZ2V0IGRpdigpIHtcbiAgICByZXR1cm4gdGhpcy4jdG9vbGJhcjtcbiAgfVxuICBzdGF0aWMgI3BvaW50ZXJEb3duKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNmb2N1c0luKGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjZm9jdXNPdXQoZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICBzdG9wRXZlbnQoZSk7XG4gIH1cbiAgI2FkZExpc3RlbmVyc1RvRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoIShzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkgfHwgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNmb2N1c0luLmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNmb2N1c091dC5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmhpZGVEcm9wZG93bigpO1xuICB9XG4gIHNob3coKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnNob3duKCk7XG4gICAgdGhpcy4jY29tbWVudD8uc2hvd24oKTtcbiAgfVxuICBhZGREZWxldGVCdXR0b24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yVHlwZSxcbiAgICAgIF91aU1hbmFnZXJcbiAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBcImRlbGV0ZUJ1dHRvblwiKTtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgRWRpdG9yVG9vbGJhci4jbDEwblJlbW92ZVtlZGl0b3JUeXBlXSk7XG4gICAgaWYgKHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pKSB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgICBfdWlNYW5hZ2VyLmRlbGV0ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IF91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbiAgZ2V0ICNkaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gXCJkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGRpdmlkZXI7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gYXdhaXQgYWx0VGV4dC5yZW5kZXIoKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCwgYmVmb3JlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b24gPSBjb21tZW50LnJlbmRlckZvclRvb2xiYXIoKTtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICBjb25zdCBkaXZpZGVyID0gdGhpcy4jY29tbWVudEJ1dHRvbkRpdmlkZXIgPSB0aGlzLiNkaXZpZGVyO1xuICAgIGlmICghYmVmb3JlRWxlbWVudCkge1xuICAgICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCBkaXZpZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYnV0dG9ucy5pbnNlcnRCZWZvcmUoYnV0dG9uLCBiZWZvcmVFbGVtZW50KTtcbiAgICAgIHRoaXMuI2J1dHRvbnMuaW5zZXJ0QmVmb3JlKGRpdmlkZXIsIGJlZm9yZUVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50ID0gY29tbWVudDtcbiAgICBjb21tZW50LnRvb2xiYXIgPSB0aGlzO1xuICB9XG4gIGFkZENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgaWYgKHRoaXMuI2NvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gICAgY29uc3QgYnV0dG9uID0gY29sb3JQaWNrZXIucmVuZGVyQnV0dG9uKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0U2lnbmF0dXJlQnV0dG9uKHNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IGF3YWl0IHNpZ25hdHVyZU1hbmFnZXIucmVuZGVyRWRpdEJ1dHRvbih0aGlzLiNlZGl0b3IpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgcmVtb3ZlQnV0dG9uKG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHRoaXMuI2NvbW1lbnQ/LnJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uKCk7XG4gICAgICAgIHRoaXMuI2NvbW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNjb21tZW50QnV0dG9uRGl2aWRlcj8ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRCdXR0b25EaXZpZGVyID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZEJ1dHRvbihuYW1lLCB0b29sKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiY29sb3JQaWNrZXJcIjpcbiAgICAgICAgdGhpcy5hZGRDb2xvclBpY2tlcih0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWx0VGV4dFwiOlxuICAgICAgICBhd2FpdCB0aGlzLmFkZEFsdFRleHQodG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVkaXRTaWduYXR1cmVcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5hZGRFZGl0U2lnbmF0dXJlQnV0dG9uKHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgdGhpcy5hZGREZWxldGVCdXR0b24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGRCdXR0b25CZWZvcmUobmFtZSwgdG9vbCwgYmVmb3JlU2VsZWN0b3IpIHtcbiAgICBjb25zdCBiZWZvcmVFbGVtZW50ID0gdGhpcy4jYnV0dG9ucy5xdWVyeVNlbGVjdG9yKGJlZm9yZVNlbGVjdG9yKTtcbiAgICBpZiAoIWJlZm9yZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCwgYmVmb3JlRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24pIHtcbiAgICAgIHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uLnRpdGxlID0gZGVzY3JpcHRpb247XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBGbG9hdGluZ1Rvb2xiYXIge1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgY29uc3RydWN0b3IodWlNYW5hZ2VyKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICB9XG4gICNyZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc05hbWUgPSBcImVkaXRUb29sYmFyXCI7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgdGhpcy4jbWFrZUJ1dHRvbihcImNvbW1lbnRCdXR0b25cIiwgYHBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uYCwgXCJwZGZqcy1jb21tZW50LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21tZW50U2VsZWN0aW9uKFwiZmxvYXRpbmdfYnV0dG9uXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCdXR0b24oXCJoaWdobGlnaHRCdXR0b25cIiwgYHBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24xYCwgXCJwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gICNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKSB7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgbGFzdFggPSAwO1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgaWYgKHkgPCBsYXN0WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBib3gueCArIChpc0xUUiA/IGJveC53aWR0aCA6IDApO1xuICAgICAgaWYgKHkgPiBsYXN0WSkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgaWYgKHggPiBsYXN0WCkge1xuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4IDwgbGFzdFgpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2lzTFRSID8gMSAtIGxhc3RYIDogbGFzdFgsIGxhc3RZXTtcbiAgfVxuICBzaG93KHBhcmVudCwgYm94ZXMsIGlzTFRSKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jdG9vbGJhciB8fD0gdGhpcy4jcmVuZGVyKCk7XG4gICAgcGFyZW50LmFwcGVuZCh0aGlzLiN0b29sYmFyKTtcbiAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiB5fSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gIH1cbiAgI21ha2VCdXR0b24oYnV0dG9uQ2xhc3MsIGwxMG5JZCwgbGFiZWxMMTBuSWQsIGNsaWNrSGFuZGxlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBidXR0b25DbGFzcyk7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGwxMG5JZCk7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3Bhbik7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSBcInZpc3VhbGx5SGlkZGVuXCI7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbGFiZWxMMTBuSWQpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja0hhbmRsZXIsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbHMuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gZ2V0VXVpZCgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBpbWFnZSA9IGF3YWl0IGZldGNoRGF0YShyYXdEYXRhLCBcImJsb2JcIik7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaW1hZ2UgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUJsb2IoaWQsIGJsb2JQcm9taXNlKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoaWQsIGJsb2IpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ibG9iUHJvbWlzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9iUHJvbWlzZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBkZWxldGUgZGF0YS5ibG9iUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21CbG9iKGRhdGEuaWQsIGJsb2JQcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0RnJvbUNhbnZhcyhpZCwgY2FudmFzKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgIGRhdGEgPSB7XG4gICAgICBiaXRtYXA6IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgcmVmQ291bnRlcjogMSxcbiAgICAgIGlzU3ZnOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy4jY2FjaGUuc2V0KGlkLCBkYXRhKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U3ZnVXJsKGlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhPy5pc1N2Zykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnN2Z1VybDtcbiAgfVxuICBkZWxldGVJZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucmVmQ291bnRlciAtPSAxO1xuICAgIGlmIChkYXRhLnJlZkNvdW50ZXIgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFkYXRhLnVybCAmJiAhZGF0YS5maWxlKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcImJpdG1hcHJlbmRlcmVyXCIpO1xuICAgICAgY3R4LnRyYW5zZmVyRnJvbUltYWdlQml0bWFwKGJpdG1hcCk7XG4gICAgICBkYXRhLmJsb2JQcm9taXNlID0gY2FudmFzLmNvbnZlcnRUb0Jsb2IoKTtcbiAgICB9XG4gICAgYml0bWFwLmNsb3NlPy4oKTtcbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIHBvc3QsXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHBvc3QsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0XG4gICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICB1bmRvKCk7XG4gICAgcG9zdD8uKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbWQsXG4gICAgICAgIHBvc3RcbiAgICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgICBjbWQoKTtcbiAgICAgIHBvc3Q/LigpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGNsZWFuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy4jcG9zaXRpb247IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHNbaV0udHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoaSArIDEsIHRoaXMuI3Bvc2l0aW9uIC0gaSk7XG4gICAgICAgIHRoaXMuI3Bvc2l0aW9uID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gLTE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgZm9yIChjb25zdCBba2V5cywgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fV0gb2YgY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGlzTWFjS2V5ID0ga2V5LnN0YXJ0c1dpdGgoXCJtYWMrXCIpO1xuICAgICAgICBpZiAoaXNNYWMgJiYgaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LnNsaWNlKDQpLCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNNYWMgJiYgIWlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZShldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJhbHRcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiY3RybFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJtZXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJzaGlmdFwiKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXIucHVzaChldmVudC5rZXkpO1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuYnVmZmVyLmpvaW4oXCIrXCIpO1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBleGVjKHNlbGYsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmFsbEtleXMuaGFzKGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuY2FsbGJhY2tzLmdldCh0aGlzLiNzZXJpYWxpemUoZXZlbnQpKTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICBjaGVja2VyID0gbnVsbFxuICAgICAgfVxuICAgIH0gPSBpbmZvO1xuICAgIGlmIChjaGVja2VyICYmICFjaGVja2VyKHNlbGYsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjay5iaW5kKHNlbGYsIC4uLmFyZ3MsIGV2ZW50KSgpO1xuICAgIGlmICghYnViYmxlcykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcbiAgZ2V0IF9jb2xvcnMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSBnZXRSR0IoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjb21tZW50TWFuYWdlciA9IG51bGw7XG4gICNjb3B5UGFzdGVBQyA9IG51bGw7XG4gICNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBudWxsO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gIF9lZGl0b3JVbmRvQmFyID0gbnVsbDtcbiAgI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZmFsc2U7XG4gICNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBmYWxzZTtcbiAgI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBmYWxzZTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgI2hpZ2hsaWdodENvbG9ycyA9IG51bGw7XG4gICNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAjZmxvYXRpbmdUb29sYmFyID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNXYWl0aW5nID0gZmFsc2U7XG4gICNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gICNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBudWxsO1xuICAjbWlzc2luZ0NhbnZhc2VzID0gbnVsbDtcbiAgI21sTWFuYWdlciA9IG51bGw7XG4gICNtb2RlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAjc2lnbmF0dXJlTWFuYWdlciA9IG51bGw7XG4gICNwYWdlQ29sb3JzID0gbnVsbDtcbiAgI3Nob3dBbGxTdGF0ZXMgPSBudWxsO1xuICAjcGRmRG9jdW1lbnQgPSBudWxsO1xuICAjcHJldmlvdXNTdGF0ZXMgPSB7XG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcbiAgICBpc0VtcHR5OiB0cnVlLFxuICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogZmFsc2UsXG4gICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICB9O1xuICAjdHJhbnNsYXRpb24gPSBbMCwgMF07XG4gICN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjdmlld2VyID0gbnVsbDtcbiAgI3ZpZXdlckFsZXJ0ID0gbnVsbDtcbiAgI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgc3RhdGljIFRSQU5TTEFURV9TTUFMTCA9IDE7XG4gIHN0YXRpYyBUUkFOU0xBVEVfQklHID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSAhPT0gXCJCVVRUT05cIiAmJiBzZWxmLmhhc1NvbWV0aGluZ1RvQ29udHJvbCgpO1xuICAgIGNvbnN0IHRleHRJbnB1dENoZWNrZXIgPSAoX3NlbGYsIHtcbiAgICAgIHRhcmdldDogZWxcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBlbDtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09IFwidGV4dFwiICYmIHR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHNtYWxsID0gdGhpcy5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdGhpcy5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK2FcIiwgXCJtYWMrbWV0YSthXCJdLCBwcm90by5zZWxlY3RBbGwsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIHByb3RvLnVuZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwreVwiLCBcImN0cmwrc2hpZnQrelwiLCBcIm1hYyttZXRhK3NoaWZ0K3pcIiwgXCJjdHJsK3NoaWZ0K1pcIiwgXCJtYWMrbWV0YStzaGlmdCtaXCJdLCBwcm90by5yZWRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiLCBcIm1hYytEZWxldGVcIl0sIHByb3RvLmRlbGV0ZSwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiRW50ZXJcIiwgXCJtYWMrRW50ZXJcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZWwpICYmICFzZWxmLmlzRW50ZXJIYW5kbGVkXG4gICAgfV0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLnVuc2VsZWN0QWxsXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCB2aWV3ZXIsIHZpZXdlckFsZXJ0LCBhbHRUZXh0TWFuYWdlciwgY29tbWVudE1hbmFnZXIsIHNpZ25hdHVyZU1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycywgaGlnaGxpZ2h0Q29sb3JzLCBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiwgZW5hYmxlVXBkYXRlZEFkZEltYWdlLCBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlLCBtbE1hbmFnZXIsIGVkaXRvclVuZG9CYXIsIHN1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWwgPSB0aGlzLiNhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jdmlld2VyQWxlcnQgPSB2aWV3ZXJBbGVydDtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXI7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlciA9IHNpZ25hdHVyZU1hbmFnZXI7XG4gICAgdGhpcy4jcGRmRG9jdW1lbnQgPSBwZGZEb2N1bWVudDtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIGV2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNldHByZWZlcmVuY2VcIiwgdGhpcy5vblNldFByZWZlcmVuY2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCBldnQgPT4gdGhpcy51cGRhdGVQYXJhbXMoZXZ0LnR5cGUsIGV2dC52YWx1ZSksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jaXNQb2ludGVyRG93biA9IHRydWU7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2lzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYWRkU2VsZWN0aW9uTGlzdGVuZXIoKTtcbiAgICB0aGlzLiNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpO1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID0gaGlnaGxpZ2h0Q29sb3JzIHx8IG51bGw7XG4gICAgdGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbjtcbiAgICB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gICAgdGhpcy4jbWxNYW5hZ2VyID0gbWxNYW5hZ2VyIHx8IG51bGw7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyID0gZWRpdG9yVW5kb0JhciB8fCBudWxsO1xuICAgIHRoaXMuX3N1cHBvcnRzUGluY2hUb1pvb20gPSBzdXBwb3J0c1BpbmNoVG9ab29tICE9PSBmYWxzZTtcbiAgICBjb21tZW50TWFuYWdlcj8uc2V0U2lkZWJhclVpTWFuYWdlcih0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5Py5yZXNvbHZlKCk7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuX3NpZ25hbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNtaXNzaW5nQ2FudmFzZXM/LmNsZWFyKCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICAgdGhpcy4jYWxsRWRpdGFibGVBbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNwZGZEb2N1bWVudCA9IG51bGw7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KFt0aGlzLl9zaWduYWwsIGFjLnNpZ25hbF0pO1xuICB9XG4gIGdldCBtbE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21sTWFuYWdlcjtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dEZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJkaXJlY3Rpb25cIiwgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNjb250YWluZXIpLmRpcmVjdGlvbik7XG4gIH1cbiAgZ2V0IF9oaWdobGlnaHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9oaWdobGlnaHRDb2xvcnNcIiwgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcCh0aGlzLiNoaWdobGlnaHRDb2xvcnMuc3BsaXQoXCIsXCIpLm1hcChwYWlyID0+IHtcbiAgICAgIHBhaXIgPSBwYWlyLnNwbGl0KFwiPVwiKS5tYXAoeCA9PiB4LnRyaW0oKSk7XG4gICAgICBwYWlyWzFdID0gcGFpclsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9ycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBfaGlnaGxpZ2h0Q29sb3JzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaGFzSENNID0gISF0aGlzLiNwYWdlQ29sb3JzO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiBfaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBpc05hbWVGb3JIQ00gPSBuYW1lLmVuZHNXaXRoKFwiX0hDTVwiKTtcbiAgICAgIGlmIChoYXNIQ00gJiYgaXNOYW1lRm9ySENNKSB7XG4gICAgICAgIG1hcC5zZXQobmFtZS5yZXBsYWNlKFwiX0hDTVwiLCBcIlwiKSwgY29sb3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSENNICYmICFpc05hbWVGb3JIQ00pIHtcbiAgICAgICAgbWFwLnNldChuYW1lLCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvcnNcIiwgbWFwKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JOYW1lcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JOYW1lc1wiLCB0aGlzLmhpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLmhpZ2hsaWdodENvbG9ycywgZSA9PiBlLnJldmVyc2UoKSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIXRoaXMuX2hpZ2hsaWdodENvbG9ycykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBjb25zdCBjb2xvck5hbWUgPSB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKTtcbiAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0Q29sb3JzLmdldChjb2xvck5hbWUpIHx8IGNvbG9yO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yTmFtZShjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKSB8fCBjb2xvcjtcbiAgfVxuICBzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBsYXllcjtcbiAgfVxuICBzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IsIGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvciwgZmlyc3RUaW1lKTtcbiAgfVxuICBoYXNDb21tZW50TWFuYWdlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLiNjb21tZW50TWFuYWdlcjtcbiAgfVxuICBlZGl0Q29tbWVudChlZGl0b3IsIHBvc1gsIHBvc1ksIG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uc2hvd0RpYWxvZyh0aGlzLCBlZGl0b3IsIHBvc1gsIHBvc1ksIG9wdGlvbnMpO1xuICB9XG4gIHNlbGVjdENvbW1lbnQocGFnZUluZGV4LCB1aWQpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgICBjb25zdCBlZGl0b3IgPSBsYXllcj8uZ2V0RWRpdG9yQnlVSUQodWlkKTtcbiAgICBlZGl0b3I/LnRvZ2dsZUNvbW1lbnQodHJ1ZSwgdHJ1ZSk7XG4gIH1cbiAgdXBkYXRlQ29tbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8udXBkYXRlQ29tbWVudChlZGl0b3IuZ2V0RGF0YSgpKTtcbiAgfVxuICB1cGRhdGVQb3B1cENvbG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy51cGRhdGVQb3B1cENvbG9yKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlQ29tbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8ucmVtb3ZlQ29tbWVudHMoW2VkaXRvci51aWRdKTtcbiAgfVxuICB0b2dnbGVDb21tZW50KGVkaXRvciwgaXNTZWxlY3RlZCwgdmlzaWJpbGl0eSA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy50b2dnbGVDb21tZW50UG9wdXAoZWRpdG9yLCBpc1NlbGVjdGVkLCB2aXNpYmlsaXR5KTtcbiAgfVxuICBtYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5tYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KSB8fCBudWxsO1xuICB9XG4gIGdldENvbW1lbnREaWFsb2dFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50TWFuYWdlcj8uZGlhbG9nRWxlbWVudCB8fCBudWxsO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JFZGl0b3JzUmVuZGVyZWQocGFnZU51bWJlcikge1xuICAgIGlmICh0aGlzLiNhbGxMYXllcnMuaGFzKHBhZ2VOdW1iZXIgLSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcHJvbWlzZVxuICAgIH0gPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBvbkVkaXRvcnNSZW5kZXJlZCA9IGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LnBhZ2VOdW1iZXIgPT09IHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRCdXMuX29mZihcImVkaXRvcnNyZW5kZXJlZFwiLCBvbkVkaXRvcnNSZW5kZXJlZCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50QnVzLm9uKFwiZWRpdG9yc3JlbmRlcmVkXCIsIG9uRWRpdG9yc1JlbmRlcmVkKTtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9XG4gIGdldFNpZ25hdHVyZShlZGl0b3IpIHtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyPy5nZXRTaWduYXR1cmUoe1xuICAgICAgdWlNYW5hZ2VyOiB0aGlzLFxuICAgICAgZWRpdG9yXG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNpZ25hdHVyZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI7XG4gIH1cbiAgc3dpdGNoVG9Nb2RlKG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJhbm5vdGF0aW9uZWRpdG9ybW9kZWNoYW5nZWRcIiwgY2FsbGJhY2ssIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2hvd2Fubm90YXRpb25lZGl0b3J1aVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJlZmVyZW5jZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2V0cHJlZmVyZW5jZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBvblNldFByZWZlcmVuY2Uoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2VcIjpcbiAgICAgICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25QYWdlQ2hhbmdpbmcoe1xuICAgIHBhZ2VOdW1iZXJcbiAgfSkge1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KHZhbHVlID0gZmFsc2UpIHtcbiAgICB0aGlzLiN2aWV3ZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm5vVXNlclNlbGVjdFwiLCB2YWx1ZSk7XG4gIH1cbiAgYWRkU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmFkZChlZGl0b3IpO1xuICB9XG4gIHJlbW92ZVNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5kZWxldGUoZWRpdG9yKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoe1xuICAgIHNjYWxlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGUgPSBzY2FsZSAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8ub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25Sb3RhdGlvbkNoYW5naW5nKHtcbiAgICBwYWdlc1JvdGF0aW9uXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiA9IHBhZ2VzUm90YXRpb247XG4gIH1cbiAgI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oe1xuICAgIGFuY2hvck5vZGVcbiAgfSkge1xuICAgIHJldHVybiBhbmNob3JOb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGFuY2hvck5vZGUucGFyZW50RWxlbWVudCA6IGFuY2hvck5vZGU7XG4gIH1cbiAgI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRMYXllclxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50TGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgIHJldHVybiBjdXJyZW50TGF5ZXI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobGF5ZXIuaGFzVGV4dExheWVyKHRleHRMYXllcikpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIsIGNvbW1lbnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXRcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZW1wdHkoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcik7XG4gICAgY29uc3QgaXNOb25lTW9kZSA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlZGl0b3IgPSBsYXllcj8uY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbixcbiAgICAgICAgYm94ZXMsXG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXNOb2RlLFxuICAgICAgICBmb2N1c09mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgZWRpdG9yPy5lZGl0Q29tbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzTm9uZU1vZGUpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9Nb2RlKEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG4gIGNvbW1lbnRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uLCB0cnVlKTtcbiAgfVxuICAjZGlzcGxheUZsb2F0aW5nVG9vbGJhcigpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpO1xuICAgIGlmICghYm94ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyIHx8PSBuZXcgRmxvYXRpbmdUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhci5zaG93KHRleHRMYXllciwgYm94ZXMsIHRoaXMuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgfVxuICBnZXRBbmRSZW1vdmVEYXRhRnJvbUFubm90YXRpb25TdG9yYWdlKGFubm90YXRpb25JZCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7YW5ub3RhdGlvbklkfWA7XG4gICAgY29uc3Qgc3RvcmVkVmFsdWUgPSB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5nZXRSYXdWYWx1ZShrZXkpO1xuICAgIGlmIChzdG9yZWRWYWx1ZSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZWRWYWx1ZTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYTExeUFsZXJ0KG1lc3NhZ2VJZCwgYXJncyA9IG51bGwpIHtcbiAgICBjb25zdCB2aWV3ZXJBbGVydCA9IHRoaXMuI3ZpZXdlckFsZXJ0O1xuICAgIGlmICghdmlld2VyQWxlcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIG1lc3NhZ2VJZCk7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHZpZXdlckFsZXJ0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld2VyQWxlcnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIik7XG4gICAgfVxuICB9XG4gICNzZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICBpZiAodGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBhbmNob3JOb2RlO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkVGV4dDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IHRoaXMuaXNTaGlmdEtleURvd247XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duKSB7XG4gICAgICBjb25zdCBhY3RpdmVMYXllciA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA/IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcikgOiBudWxsO1xuICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIGlmICh0aGlzLiNpc1BvaW50ZXJEb3duKSB7XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICAgICAgY29uc3QgcG9pbnRlcnVwID0gZSA9PiB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIiAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlcnVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjb25TZWxlY3RFbmQobWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uKSB7XG4gICAgICB0aGlzLiNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCk7XG4gICAgfVxuICB9XG4gICNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMuI3NlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICB9XG4gICNhZGRGb2N1c01hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jZm9jdXNNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5mb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVGb2N1c01hbmFnZXIoKSB7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IFtlZGl0b3IsIGFjdGl2ZUVsZW1lbnRdO1xuICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbGFzdEVkaXRvciwgbGFzdEFjdGl2ZUVsZW1lbnRdID0gdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgIGxhc3RFZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5rZXl1cC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNjb3B5UGFzdGVBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NvcHlQYXN0ZUFDKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLmNvcHkuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLmN1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgfVxuICAjYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fc2lnbmFsO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLmRyYWdPdmVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuZHJvcC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBhZGRFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIHJlbW92ZUVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgZHJhZ092ZXIoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9IG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyh0eXBlKSkge1xuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJvcChldmVudCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBhc3luYyBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRWRpdG9yID0gYXdhaXQgbGF5ZXIuZGVzZXJpYWxpemUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRpdG9ycy5wdXNoKGRlc2VyaWFsaXplZEVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc2VsZWN0RWRpdG9ycyhuZXdFZGl0b3JzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZCxcbiAgICAgICAgdW5kbyxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhdGhpcy5pc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAga2V5dXAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVkaXRpbmdBY3Rpb24oe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInVuZG9cIjpcbiAgICAgIGNhc2UgXCJyZWRvXCI6XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBjYXNlIFwic2VsZWN0QWxsXCI6XG4gICAgICAgIHRoaXNbbmFtZV0oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21tZW50U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuY29tbWVudFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIGRldGFpbHMuaGFzU2VsZWN0ZWRFZGl0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdHJ1ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmlkO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsLCBpc0Zyb21LZXlib2FyZCA9IGZhbHNlLCBtdXN0RW50ZXJJbkVkaXRNb2RlID0gZmFsc2UsIGVkaXRDb21tZW50ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICBpZiAoIXRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uaGlkZVNpZGViYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LmRlc3Ryb3lQb3B1cCgpO1xuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5oaWRlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICAgIHRoaXMudG9nZ2xlQ29tbWVudChudWxsKTtcbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmxvYWRTaWduYXR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIGF3YWl0IHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zIHx8PSBhd2FpdCB0aGlzLiNwZGZEb2N1bWVudC5nZXRBbm5vdGF0aW9uc0J5VHlwZShuZXcgU2V0KHRoaXMuI2VkaXRvclR5cGVzLm1hcChlZGl0b3JDbGFzcyA9PiBlZGl0b3JDbGFzcy5fZWRpdG9yVHlwZSkpKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBhbGxDb21tZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgICAgICBoYXNDb21tZW50LFxuICAgICAgICAgIGRlbGV0ZWRcbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgICBlbGVtZW50SWRzLmFkZChhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29tbWVudCAmJiAhZGVsZXRlZCkge1xuICAgICAgICAgIGFsbENvbW1lbnRzLnB1c2goZWRpdG9yLmdldERhdGEoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICBjb250ZW50c09ialxuICAgICAgICB9ID0gYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHBvcHVwUmVmICYmIGNvbnRlbnRzT2JqPy5zdHIgJiYgIWVsZW1lbnRJZHMuaGFzKGlkKSAmJiAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgYWxsQ29tbWVudHMucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnNob3dTaWRlYmFyKGFsbENvbW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIGlmIChpc0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnVpZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgaWYgKGVkaXRDb21tZW50KSB7XG4gICAgICAgICAgZWRpdG9yLmVkaXRDb21tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobXVzdEVudGVySW5FZGl0TW9kZSkge1xuICAgICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudExheWVyLmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkpIHtcbiAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sYmFyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURTpcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEw6XG4gICAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2dnbGVfdmlzaWJpbGl0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuI3Nob3dBbGxTdGF0ZXMgfHw9IG5ldyBNYXAoKSkuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgICBlZGl0b3IudXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3dBbGxFZGl0b3JzKHR5cGUsIHZpc2libGUsIHVwZGF0ZUJ1dHRvbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5lZGl0b3JUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVkaXRvci5zaG93KHZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3Nob3dBbGxTdGF0ZXM/LmdldChBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwpID8/IHRydWU7XG4gICAgaWYgKHN0YXRlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMLCB2aXNpYmxlXV0pO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChsYXllci5lbmFibGUoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqZ2V0RWRpdG9ycyhwYWdlSW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIHlpZWxkIGVkaXRvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RWRpdG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbEVkaXRvcnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG4gIHJlbW92ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzTWFpbkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiNtaXNzaW5nQ2FudmFzZXM/LmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0ICNsYXN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgbGV0IGVkID0gbnVsbDtcbiAgICBmb3IgKGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge31cbiAgICByZXR1cm4gZWQ7XG4gIH1cbiAgdXBkYXRlVUkoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2xhc3RTZWxlY3RlZEVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzKGVkaXRvclR5cGUpIHtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKSkge1xuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMudXBkYXRlVG9vbGJhcih7XG4gICAgICBtb2RlOiBlZGl0b3IubW9kZSxcbiAgICAgIGVkaXRJZDogZWRpdG9yLmlkXG4gICAgfSk7XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcik7XG4gIH1cbiAgZ2V0IGZpcnN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplICE9PSAwO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLmlzRW50ZXJIYW5kbGVkO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIudW5kbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRydWUsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5yZWRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmFkZChwYXJhbXMpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBjbGVhblVuZG9TdGFjayh0eXBlKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuY2xlYW5UeXBlKHR5cGUpO1xuICB9XG4gICNpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBjb25zdCBkcmF3aW5nRWRpdG9yID0gdGhpcy5jdXJyZW50TGF5ZXI/LmVuZERyYXdpbmdTZXNzaW9uKHRydWUpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24gJiYgIWRyYXdpbmdFZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IGRyYXdpbmdFZGl0b3IgPyBbZHJhd2luZ0VkaXRvcl0gOiBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5zaG93KHVuZG8sIGVkaXRvcnMubGVuZ3RoID09PSAxID8gZWRpdG9yc1swXS5lZGl0b3JUeXBlIDogZWRpdG9ycy5sZW5ndGgpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb0NvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciB8fCB0aGlzLmhhc1NlbGVjdGlvbjtcbiAgfVxuICAjc2VsZWN0RWRpdG9ycyhlZGl0b3JzKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIHNlbGVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci5jb21taXQoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0RWRpdG9ycyh0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKTtcbiAgfVxuICB1bnNlbGVjdEFsbCgpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yKSB7XG4gICAgICB0aGlzLiNhY3RpdmVFZGl0b3IuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGlvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKC10b3RhbFgsIC10b3RhbFkpO1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh4LCB5KTtcbiAgICAgIGVkaXRvci50cmFuc2xhdGlvbkRvbmUoKTtcbiAgICB9XG4gIH1cbiAgc2V0VXBEcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLnNldChlZGl0b3IsIHtcbiAgICAgICAgc2F2ZWRYOiBlZGl0b3IueCxcbiAgICAgICAgc2F2ZWRZOiBlZGl0b3IueSxcbiAgICAgICAgc2F2ZWRQYWdlSW5kZXg6IGVkaXRvci5wYWdlSW5kZXgsXG4gICAgICAgIG5ld1g6IDAsXG4gICAgICAgIG5ld1k6IDAsXG4gICAgICAgIG5ld1BhZ2VJbmRleDogLTFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlbmREcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLiNkcmFnZ2luZ0VkaXRvcnM7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgICBsZXQgbXVzdEJlQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW3tcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSwgdmFsdWVdIG9mIG1hcCkge1xuICAgICAgdmFsdWUubmV3WCA9IHg7XG4gICAgICB2YWx1ZS5uZXdZID0geTtcbiAgICAgIHZhbHVlLm5ld1BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgIG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgfHw9IHggIT09IHZhbHVlLnNhdmVkWCB8fCB5ICE9PSB2YWx1ZS5zYXZlZFkgfHwgcGFnZUluZGV4ICE9PSB2YWx1ZS5zYXZlZFBhZ2VJbmRleDtcbiAgICB9XG4gICAgaWYgKCFtdXN0QmVBZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vdmUgPSAoZWRpdG9yLCB4LCB5LCBwYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGVkaXRvci5fc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgIGVkaXRvci54ID0geDtcbiAgICAgICAgICBlZGl0b3IueSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIG5ld1gsXG4gICAgICAgICAgbmV3WSxcbiAgICAgICAgICBuZXdQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIG5ld1gsIG5ld1ksIG5ld1BhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIHNhdmVkWCxcbiAgICAgICAgICBzYXZlZFksXG4gICAgICAgICAgc2F2ZWRQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFBhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLmtleXMoKSkge1xuICAgICAgZWRpdG9yLmRyYWcodHgsIHR5KTtcbiAgICB9XG4gIH1cbiAgcmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXllcihlZGl0b3IucGFnZUluZGV4KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgICAgICBwYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmUoKT8uc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB8fCB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3Iuc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKTtcbiAgfVxuICBpc0FjdGl2ZShlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3I7XG4gIH1cbiAgZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3I7XG4gIH1cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbW9kZTtcbiAgfVxuICBpc0VkaXRpbmdNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcikge1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoIXRleHRMYXllci5jb250YWlucyhzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcm90YXRvcjtcbiAgICBzd2l0Y2ggKHRleHRMYXllci5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIikpIHtcbiAgICAgIGNhc2UgXCI5MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjE4MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMjcwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gb2YgcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSkge1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBib3hlcztcbiAgfVxuICBhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgIGlkXG4gIH0pIHtcbiAgICAodGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbiAgc2V0TWlzc2luZ0NhbnZhcyhhbm5vdGF0aW9uSWQsIGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcy5kZWxldGUoYW5ub3RhdGlvbklkKTtcbiAgfVxuICBhZGRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgZWRpdG9yKSB7XG4gICAgKHRoaXMuI21pc3NpbmdDYW52YXNlcyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbklkLCBlZGl0b3IpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbHRfdGV4dC5qc1xuXG5jbGFzcyBBbHRUZXh0IHtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICNiYWRnZSA9IG51bGw7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZ3Vlc3NlZFRleHQgPSBudWxsO1xuICAjdGV4dFdpdGhEaXNjbGFpbWVyID0gbnVsbDtcbiAgI3VzZU5ld0FsdFRleHRGbG93ID0gZmFsc2U7XG4gIHN0YXRpYyAjbDEwbk5ld0J1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyA9IGVkaXRvci5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93O1xuICAgIEFsdFRleHQuI2wxMG5OZXdCdXR0b24gfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYWRkZWQ6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b25cIixcbiAgICAgIFwiYWRkZWQtbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgbWlzc2luZzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uXCIsXG4gICAgICBcIm1pc3NpbmctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uLWxhYmVsXCIsXG4gICAgICByZXZpZXc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uXCIsXG4gICAgICBcInJldmlldy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvbi1sYWJlbFwiXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIEFsdFRleHQuX2wxMG4gPz89IGwxMG47XG4gIH1cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGFsdFRleHQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGFsdFRleHQuYXBwZW5kKGxhYmVsKTtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGFsdFRleHQuY2xhc3NMaXN0LmFkZChcIm5ld1wiKTtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b24ubWlzc2luZyk7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltcIm1pc3NpbmctbGFiZWxcIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b25cIik7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uLWxhYmVsXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMuI2VkaXRvcik7XG4gICAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfY2xpY2tlZFwiLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBhbHRUZXh0ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSB0cnVlO1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLiNzZXRTdGF0ZSgpO1xuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gIGdldCAjbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgJiYgXCJhZGRlZFwiIHx8IHRoaXMuI2FsdFRleHQgPT09IG51bGwgJiYgdGhpcy5ndWVzc2VkVGV4dCAmJiBcInJldmlld1wiIHx8IFwibWlzc2luZ1wiO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlO1xuICB9XG4gIGhhc0RhdGEoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAhPT0gbnVsbCB8fCAhIXRoaXMuI2d1ZXNzZWRUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkVGV4dChndWVzc2VkVGV4dCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gYXdhaXQgQWx0VGV4dC5fbDEwbi5nZXQoXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWdlbmVyYXRlZC1hbHQtdGV4dC13aXRoLWRpc2NsYWltZXJcIiwge1xuICAgICAgZ2VuZXJhdGVkQWx0VGV4dDogZ3Vlc3NlZFRleHRcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZUFsdFRleHRCYWRnZSh2aXNpYmlsaXR5ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI3VzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNiYWRnZSkge1xuICAgICAgY29uc3QgYmFkZ2UgPSB0aGlzLiNiYWRnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBiYWRnZS5jbGFzc05hbWUgPSBcIm5vQWx0VGV4dEJhZGdlXCI7XG4gICAgICB0aGlzLiNlZGl0b3IuZGl2LmFwcGVuZChiYWRnZSk7XG4gICAgfVxuICAgIHRoaXMuI2JhZGdlLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2liaWxpdHkpO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpIHtcbiAgICBsZXQgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCFpc0ZvckNvcHlpbmcgJiYgdGhpcy4jZ3Vlc3NlZFRleHQgPT09IGFsdFRleHQpIHtcbiAgICAgIGFsdFRleHQgPSB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmUsXG4gICAgICBndWVzc2VkVGV4dDogdGhpcy4jZ3Vlc3NlZFRleHQsXG4gICAgICB0ZXh0V2l0aERpc2NsYWltZXI6IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lclxuICAgIH07XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQ6IHRoaXMuI2FsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZVxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZSxcbiAgICBndWVzc2VkVGV4dCxcbiAgICB0ZXh0V2l0aERpc2NsYWltZXIsXG4gICAgY2FuY2VsID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChndWVzc2VkVGV4dCkge1xuICAgICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IHRleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICAgICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZShlbmFibGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkICYmIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmRpc2FibGVkID0gIWVuYWJsZWQ7XG4gIH1cbiAgc2hvd24oKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9kaXNwbGF5ZWRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICB9XG4gIGFzeW5jICNzZXRTdGF0ZSgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNhbHRUZXh0QnV0dG9uO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJkb25lXCIsICEhdGhpcy4jYWx0VGV4dCk7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bdGhpcy4jbGFiZWxdKTtcbiAgICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbD8uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bYCR7dGhpcy4jbGFiZWx9LWxhYmVsYF0pO1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZG9uZVwiKTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImRvbmVcIik7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWVkaXQtYnV0dG9uXCIpO1xuICAgIH1cbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIHRvb2x0aXAuaWQgPSBgYWx0LXRleHQtdG9vbHRpcC0ke3RoaXMuI2VkaXRvci5pZH1gO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xuICAgICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgREVMQVlfVE9fU0hPV19UT09MVElQKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1kZWNvcmF0aXZlLXRvb2x0aXBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIpO1xuICAgICAgdG9vbHRpcC50ZXh0Q29udGVudCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgfVxuICAgIGlmICghdG9vbHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICBidXR0b24uYXBwZW5kKHRvb2x0aXApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWRpdG9yLmdldEVsZW1lbnRGb3JBbHRUZXh0KCk7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0b29sdGlwLmlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvY29tbWVudC5qc1xuXG5jbGFzcyBDb21tZW50IHtcbiAgI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgI2NvbW1lbnRUb29sYmFyQnV0dG9uID0gbnVsbDtcbiAgI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNpbml0aWFsVGV4dCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0ZXh0ID0gbnVsbDtcbiAgI2RhdGUgPSBudWxsO1xuICAjZGVsZXRlZCA9IGZhbHNlO1xuICAjcG9wdXBQb3NpdGlvbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgfVxuICByZW5kZXJGb3JUb29sYmFyKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjb21tZW50XCI7XG4gICAgcmV0dXJuIHRoaXMuI3JlbmRlcihidXR0b24sIGZhbHNlKTtcbiAgfVxuICByZW5kZXJGb3JTdGFuZGFsb25lKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29tbWVudEJ1dHRvblwiO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLmNvbW1lbnRCdXR0b25Qb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBidXR0b247XG4gICAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGBjYWxjKCR7MTAwICogKHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdKX0lIC0gdmFyKC0tY29tbWVudC1idXR0b24tZGltKSlgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lIC0gdmFyKC0tY29tbWVudC1idXR0b24tZGltKSlgO1xuICAgICAgY29uc3QgY29sb3IgPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvbkNvbG9yO1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcmVuZGVyKGJ1dHRvbiwgdHJ1ZSk7XG4gIH1cbiAgZm9jdXNCdXR0b24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAodGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPz8gdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24pPy5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIG9uVXBkYXRlZENvbG9yKCkge1xuICAgIGlmICghdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvbkNvbG9yO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLnVwZGF0ZVBvcHVwQ29sb3IodGhpcy4jZWRpdG9yKTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbldpZHRoKCkge1xuICAgIHJldHVybiAodGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID8/IDApIC8gdGhpcy4jZWRpdG9yLnBhcmVudC5ib3VuZGluZ0NsaWVudFJlY3Qud2lkdGg7XG4gIH1cbiAgZ2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXBQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuI3BvcHVwUG9zaXRpb247XG4gICAgfVxuICAgIGlmICghdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRoaXMuI2VkaXRvci5wYXJlbnQuYm91bmRpbmdDbGllbnRSZWN0O1xuICAgIHJldHVybiBbKHggLSBwYXJlbnRYKSAvIHBhcmVudFdpZHRoLCAoeSArIGhlaWdodCAtIHBhcmVudFkpIC8gcGFyZW50SGVpZ2h0XTtcbiAgfVxuICBzZXQgY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyKHBvcykge1xuICAgIHRoaXMuI3BvcHVwUG9zaXRpb24gPSBwb3M7XG4gIH1cbiAgaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcHVwUG9zaXRpb24gPT09IG51bGw7XG4gIH1cbiAgcmVtb3ZlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgfVxuICByZW1vdmVUb29sYmFyQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24gPSBudWxsO1xuICB9XG4gIHNldENvbW1lbnRCdXR0b25TdGF0ZXMoe1xuICAgIHNlbGVjdGVkLFxuICAgIGhhc1BvcHVwXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCBzZWxlY3RlZCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uYXJpYUV4cGFuZGVkID0gaGFzUG9wdXA7XG4gIH1cbiAgI3JlbmRlcihjb21tZW50LCBpc1N0YW5kYWxvbmUpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmhhc0NvbW1lbnRNYW5hZ2VyKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb21tZW50LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29tbWVudC5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgIGlmIChpc1N0YW5kYWxvbmUpIHtcbiAgICAgIGNvbW1lbnQuYXJpYUNvbnRyb2xzID0gXCJjb21tZW50UG9wdXBcIjtcbiAgICAgIGNvbW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtc2hvdy1jb21tZW50LWJ1dHRvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWVudC5hcmlhQ29udHJvbHNFbGVtZW50cyA9IFt0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5nZXRDb21tZW50RGlhbG9nRWxlbWVudCgpXTtcbiAgICAgIGNvbW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWVkaXQtY29tbWVudC1idXR0b25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHx8IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGlzU3RhbmRhbG9uZSkge1xuICAgICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBlID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoY29tbWVudCA9PT0gdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24pIHtcbiAgICAgICAgdGhpcy5lZGl0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNlZGl0b3IudG9nZ2xlQ29tbWVudCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGNvbW1lbnQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNlZGl0b3IudG9nZ2xlQ29tbWVudChmYWxzZSwgdHJ1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2VkaXRvci50b2dnbGVDb21tZW50KGZhbHNlLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cbiAgZWRpdChvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcjtcbiAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIFtwb3NYLCBwb3NZXSA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBbcG9zWCwgcG9zWV0gPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgICAgcG9zWCA9IHggKyBwb3NYICogd2lkdGg7XG4gICAgICBwb3NZID0geSArIHBvc1kgKiBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdENvbW1lbnQodGhpcy4jZWRpdG9yLCBwYXJlbnRYICsgcG9zWCAqIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcG9zWSAqIHBhcmVudEhlaWdodCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHBhcmVudERpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNEZWxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkIHx8IHRoaXMuI3RleHQgPT09IFwiXCI7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dCA9PT0gbnVsbDtcbiAgfVxuICBoYXNCZWVuRWRpdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGVsZXRlZCgpIHx8IHRoaXMuI3RleHQgIT09IHRoaXMuI2luaXRpYWxUZXh0O1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLiN0ZXh0LFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0LFxuICAgICAgZGF0ZTogdGhpcy4jZGF0ZSxcbiAgICAgIGRlbGV0ZWQ6IHRoaXMuaXNEZWxldGVkKClcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHRleHQpIHtcbiAgICBpZiAodGV4dCAhPT0gdGhpcy4jdGV4dCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLiNkZWxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdGV4dCA9IHRleHQ7XG4gICAgdGhpcy4jZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIHNldEluaXRpYWxUZXh0KHRleHQsIHJpY2hUZXh0ID0gbnVsbCkge1xuICAgIHRoaXMuI2luaXRpYWxUZXh0ID0gdGV4dDtcbiAgICB0aGlzLmRhdGEgPSB0ZXh0O1xuICAgIHRoaXMuI2RhdGUgPSBudWxsO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gIH1cbiAgc2hvd24oKSB7fVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiN0ZXh0ID0gXCJcIjtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IG51bGw7XG4gICAgdGhpcy4jZGF0ZSA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RvdWNoX21hbmFnZXIuanNcblxuY2xhc3MgVG91Y2hNYW5hZ2VyIHtcbiAgI2NvbnRhaW5lcjtcbiAgI2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgI2lzUGluY2hpbmdTdG9wcGVkID0gbnVsbDtcbiAgI2lzUGluY2hpbmdEaXNhYmxlZDtcbiAgI29uUGluY2hTdGFydDtcbiAgI29uUGluY2hpbmc7XG4gICNvblBpbmNoRW5kO1xuICAjcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICNzaWduYWw7XG4gICN0b3VjaEluZm8gPSBudWxsO1xuICAjdG91Y2hNYW5hZ2VyQUM7XG4gICN0b3VjaE1vdmVBQyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgaXNQaW5jaGluZ0Rpc2FibGVkID0gbnVsbCxcbiAgICBpc1BpbmNoaW5nU3RvcHBlZCA9IG51bGwsXG4gICAgb25QaW5jaFN0YXJ0ID0gbnVsbCxcbiAgICBvblBpbmNoaW5nID0gbnVsbCxcbiAgICBvblBpbmNoRW5kID0gbnVsbCxcbiAgICBzaWduYWxcbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiNpc1BpbmNoaW5nU3RvcHBlZCA9IGlzUGluY2hpbmdTdG9wcGVkO1xuICAgIHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZCA9IGlzUGluY2hpbmdEaXNhYmxlZDtcbiAgICB0aGlzLiNvblBpbmNoU3RhcnQgPSBvblBpbmNoU3RhcnQ7XG4gICAgdGhpcy4jb25QaW5jaGluZyA9IG9uUGluY2hpbmc7XG4gICAgdGhpcy4jb25QaW5jaEVuZCA9IG9uUGluY2hFbmQ7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy4jc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtzaWduYWwsIHRoaXMuI3RvdWNoTWFuYWdlckFDLnNpZ25hbF0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLiNvblRvdWNoU3RhcnQuYmluZCh0aGlzKSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWw6IHRoaXMuI3NpZ25hbFxuICAgIH0pO1xuICB9XG4gIGdldCBNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0goKSB7XG4gICAgcmV0dXJuIDM1IC8gT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgfVxuICAjb25Ub3VjaFN0YXJ0KGV2dCkge1xuICAgIGlmICh0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQ/LigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLiNwb2ludGVyRG93bkFDKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ZXJEb3duQUMgPSB0aGlzLiNwb2ludGVyRG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHBvaW50ZXJEb3duQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29uc3QgY2FuY2VsUG9pbnRlckRvd24gPSBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIGNhbmNlbFBvaW50ZXJEb3duKGUpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBjYW5jZWxQb2ludGVyRG93biwgb3B0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHRoaXMuI3RvdWNoTW92ZUFDLnNpZ25hbF0pO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuI29uVG91Y2hNb3ZlLmJpbmQodGhpcyksIG9wdCk7XG4gICAgICBjb25zdCBvblRvdWNoRW5kID0gdGhpcy4jb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgb3B0LmNhcHR1cmUgPSB0cnVlO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICB0aGlzLiNvblBpbmNoU3RhcnQ/LigpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZ0KTtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuI2lzUGluY2hpbmdTdG9wcGVkPy4oKSkge1xuICAgICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIHRoaXMuI3RvdWNoSW5mbyA9IHtcbiAgICAgIHRvdWNoMFg6IHRvdWNoMC5zY3JlZW5YLFxuICAgICAgdG91Y2gwWTogdG91Y2gwLnNjcmVlblksXG4gICAgICB0b3VjaDFYOiB0b3VjaDEuc2NyZWVuWCxcbiAgICAgIHRvdWNoMVk6IHRvdWNoMS5zY3JlZW5ZXG4gICAgfTtcbiAgfVxuICAjb25Ub3VjaE1vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8gfHwgZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGxldCBbdG91Y2gwLCB0b3VjaDFdID0gZXZ0LnRvdWNoZXM7XG4gICAgaWYgKHRvdWNoMC5pZGVudGlmaWVyID4gdG91Y2gxLmlkZW50aWZpZXIpIHtcbiAgICAgIFt0b3VjaDAsIHRvdWNoMV0gPSBbdG91Y2gxLCB0b3VjaDBdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4wWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjBZXG4gICAgfSA9IHRvdWNoMDtcbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4xWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjFZXG4gICAgfSA9IHRvdWNoMTtcbiAgICBjb25zdCB0b3VjaEluZm8gPSB0aGlzLiN0b3VjaEluZm87XG4gICAgY29uc3Qge1xuICAgICAgdG91Y2gwWDogcFRvdWNoMFgsXG4gICAgICB0b3VjaDBZOiBwVG91Y2gwWSxcbiAgICAgIHRvdWNoMVg6IHBUb3VjaDFYLFxuICAgICAgdG91Y2gxWTogcFRvdWNoMVlcbiAgICB9ID0gdG91Y2hJbmZvO1xuICAgIGNvbnN0IHByZXZHYXBYID0gcFRvdWNoMVggLSBwVG91Y2gwWDtcbiAgICBjb25zdCBwcmV2R2FwWSA9IHBUb3VjaDFZIC0gcFRvdWNoMFk7XG4gICAgY29uc3QgY3VyckdhcFggPSBzY3JlZW4xWCAtIHNjcmVlbjBYO1xuICAgIGNvbnN0IGN1cnJHYXBZID0gc2NyZWVuMVkgLSBzY3JlZW4wWTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoY3VyckdhcFgsIGN1cnJHYXBZKSB8fCAxO1xuICAgIGNvbnN0IHBEaXN0YW5jZSA9IE1hdGguaHlwb3QocHJldkdhcFgsIHByZXZHYXBZKSB8fCAxO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZyAmJiBNYXRoLmFicyhwRGlzdGFuY2UgLSBkaXN0YW5jZSkgPD0gVG91Y2hNYW5hZ2VyLk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0b3VjaEluZm8udG91Y2gwWCA9IHNjcmVlbjBYO1xuICAgIHRvdWNoSW5mby50b3VjaDBZID0gc2NyZWVuMFk7XG4gICAgdG91Y2hJbmZvLnRvdWNoMVggPSBzY3JlZW4xWDtcbiAgICB0b3VjaEluZm8udG91Y2gxWSA9IHNjcmVlbjFZO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZykge1xuICAgICAgdGhpcy4jaXNQaW5jaGluZyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbiA9IFsoc2NyZWVuMFggKyBzY3JlZW4xWCkgLyAyLCAoc2NyZWVuMFkgKyBzY3JlZW4xWSkgLyAyXTtcbiAgICB0aGlzLiNvblBpbmNoaW5nPy4ob3JpZ2luLCBwRGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgfVxuICAjb25Ub3VjaEVuZChldnQpIHtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RvdWNoTW92ZUFDKSB7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBudWxsO1xuICAgICAgdGhpcy4jb25QaW5jaEVuZD8uKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIHRoaXMuI3RvdWNoSW5mbyA9IG51bGw7XG4gICAgdGhpcy4jaXNQaW5jaGluZyA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBudWxsO1xuICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2VkaXRvci5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjY29tbWVudCA9IG51bGw7XG4gICNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IG51bGw7XG4gICNkaXNhYmxlZCA9IGZhbHNlO1xuICAjZHJhZ1BvaW50ZXJJZCA9IG51bGw7XG4gICNkcmFnUG9pbnRlclR5cGUgPSBcIlwiO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjbGFzdFBvaW50ZXJDb29yZHMgPSBudWxsO1xuICAjc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgI2ZvY3VzQUMgPSBudWxsO1xuICAjZm9jdXNlZFJlc2l6ZXJOYW1lID0gXCJcIjtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpbml0aWFsUmVjdCA9IG51bGw7XG4gICNpc0VkaXRpbmcgPSBmYWxzZTtcbiAgI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAjaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgI3ByZXZEcmFnWCA9IDA7XG4gICNwcmV2RHJhZ1kgPSAwO1xuICAjdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAjdG91Y2hNYW5hZ2VyID0gbnVsbDtcbiAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICBfaXNDb3B5ID0gZmFsc2U7XG4gIF9lZGl0VG9vbGJhciA9IG51bGw7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF9pbml0aWFsRGF0YSA9IG51bGw7XG4gIF9pc1Zpc2libGUgPSB0cnVlO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwblJlc2l6ZXIgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBDb2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgX3RlbGVtZXRyeVRpbWVvdXQgPSAxMDAwO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25FbGVtZW50SWQgfHwgbnVsbDtcbiAgICB0aGlzLmNyZWF0aW9uRGF0ZSA9IHBhcmFtZXRlcnMuY3JlYXRpb25EYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5tb2RpZmljYXRpb25EYXRlID0gcGFyYW1ldGVycy5tb2RpZmljYXRpb25EYXRlIHx8IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fZWRpdG9yVHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBfdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwbiA/Pz0gbDEwbjtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB0b3BMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1sZWZ0XCIsXG4gICAgICB0b3BNaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLW1pZGRsZVwiLFxuICAgICAgdG9wUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLXJpZ2h0XCIsXG4gICAgICBtaWRkbGVSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtcmlnaHRcIixcbiAgICAgIGJvdHRvbVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1yaWdodFwiLFxuICAgICAgYm90dG9tTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1taWRkbGVcIixcbiAgICAgIGJvdHRvbUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLWxlZnRcIixcbiAgICAgIG1pZGRsZUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLWxlZnRcIlxuICAgIH0pO1xuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCB1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCB0aGlzLmlkO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHRoaXMueCwgdGhpcy55KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRpb25Eb25lKCkge1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcoeCwgeSk7XG4gICAgZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKHgsIHkpIHt9XG4gIF9vblRyYW5zbGF0ZWQoeCwgeSkge31cbiAgZ2V0IF9oYXNCZWVuTW92ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzBdICE9PSB0aGlzLnggfHwgdGhpcy4jaW5pdGlhbFJlY3RbMV0gIT09IHRoaXMueSk7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuUmVzaXplZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMl0gIT09IHRoaXMud2lkdGggfHwgdGhpcy4jaW5pdGlhbFJlY3RbM10gIT09IHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24ocm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2OiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9tdXN0Rml4UG9zaXRpb24pIHtcbiAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgMCwgcGFnZVdpZHRoIC0gd2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgMCwgcGFnZUhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSBoZWlnaHQpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgd2lkdGgsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIHdpZHRoLCBwYWdlV2lkdGgpO1xuICAgICAgICAgIHkgPSBNYXRoQ2xhbXAoeSwgaGVpZ2h0LCBwYWdlSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCBoZWlnaHQsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gd2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCAtcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIC1wYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbcGFnZVdpZHRoICogcGFyZW50U2NhbGUsIHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZV07XG4gIH1cbiAgc2V0RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXY6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID8gW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21MZWZ0XCJdIDogW1widG9wTGVmdFwiLCBcInRvcE1pZGRsZVwiLCBcInRvcFJpZ2h0XCIsIFwibWlkZGxlUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcImJvdHRvbUxlZnRcIiwgXCJtaWRkbGVMZWZ0XCJdO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmRpdi5wcmVwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJkb3duKG5hbWUsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3JkcyA9IFtldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZXTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRQYXJlbnRDdXJzb3I7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZEN1cnNvcjtcbiAgICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVzaXplKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICBfb25SZXNpemVkKCkge31cbiAgI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCkge1xuICAgIGlmICghdGhpcy4jc2F2ZWREaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNhdmVkWCxcbiAgICAgIHNhdmVkWSxcbiAgICAgIHNhdmVkV2lkdGgsXG4gICAgICBzYXZlZEhlaWdodFxuICAgIH0gPSB0aGlzLiNzYXZlZERpbWVuc2lvbnM7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgICBjb25zdCBuZXdYID0gdGhpcy54O1xuICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHRoaXMuI3Jlc2l6ZS5iaW5kKHRoaXMsIG5ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHQpLFxuICAgICAgdW5kbzogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9yb3VuZCh4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDEwMDAwKSAvIDEwMDAwO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcm1vdmUobmFtZSwgZXZlbnQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBkZWx0YVgsIGRlbHRhWTtcbiAgICBpZiAoIWV2ZW50LmZyb21LZXlib2FyZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBbbGFzdFNjcmVlblgsIGxhc3RTY3JlZW5ZXSA9IHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzO1xuICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oc2NyZWVuWCAtIGxhc3RTY3JlZW5YLCBzY3JlZW5ZIC0gbGFzdFNjcmVlblkpO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMF0gPSBzY3JlZW5YO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMV0gPSBzY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWVxuICAgICAgfSA9IGV2ZW50KTtcbiAgICB9XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpLCBtaW5XaWR0aCwgMSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoQ2xhbXAoTWF0aC5hYnMob3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSwgbWluSGVpZ2h0LCAxKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gIF9vblJlc2l6aW5nKCkge31cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py5maW5pc2goKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2VkaXRUb29sYmFyIHx8IHRoaXMuI2lzSW5FZGl0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG5ldyBFZGl0b3JUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLl9lZGl0VG9vbGJhci5yZW5kZXIoKSk7XG4gICAgY29uc3Qge1xuICAgICAgdG9vbGJhckJ1dHRvbnNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodG9vbGJhckJ1dHRvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIHRvb2xiYXJCdXR0b25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VkaXRUb29sYmFyLmFkZEJ1dHRvbihuYW1lLCB0b29sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmFkZEJ1dHRvbihcImNvbW1lbnRcIiwgdGhpcy5hZGRDb21tZW50QnV0dG9uKCkpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhci5hZGRCdXR0b24oXCJkZWxldGVcIik7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICB9XG4gIGFkZENvbW1lbnRCdXR0b25JblRvb2xiYXIoKSB7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LmFkZEJ1dHRvbkJlZm9yZShcImNvbW1lbnRcIiwgdGhpcy5hZGRDb21tZW50QnV0dG9uKCksIFwiLmRlbGV0ZUJ1dHRvblwiKTtcbiAgfVxuICByZW1vdmVDb21tZW50QnV0dG9uRnJvbVRvb2xiYXIoKSB7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LnJlbW92ZUJ1dHRvbihcImNvbW1lbnRcIik7XG4gIH1cbiAgcmVtb3ZlRWRpdFRvb2xiYXIoKSB7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LnJlbW92ZSgpO1xuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0Py5kZXN0cm95KCk7XG4gIH1cbiAgYWRkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyRGl2ID0gdGhpcy5fZWRpdFRvb2xiYXI/LmRpdjtcbiAgICBpZiAoZWRpdFRvb2xiYXJEaXYpIHtcbiAgICAgIGVkaXRUb29sYmFyRGl2LmJlZm9yZShjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2xpZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgY3JlYXRlQWx0VGV4dCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgIEFsdFRleHQuaW5pdGlhbGl6ZShBbm5vdGF0aW9uRWRpdG9yLl9sMTBuKTtcbiAgICAgIHRoaXMuI2FsdFRleHQgPSBuZXcgQWx0VGV4dCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dDtcbiAgfVxuICBnZXQgYWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LmRhdGE7XG4gIH1cbiAgc2V0IGFsdFRleHREYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dC5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZ3Vlc3NlZEFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmd1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRBbHRUZXh0KHRleHQpIHtcbiAgICBhd2FpdCB0aGlzLiNhbHRUZXh0Py5zZXRHdWVzc2VkVGV4dCh0ZXh0KTtcbiAgfVxuICBzZXJpYWxpemVBbHRUZXh0KGlzRm9yQ29weWluZykge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKTtcbiAgfVxuICBoYXNBbHRUZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHQuaXNFbXB0eSgpO1xuICB9XG4gIGhhc0FsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5oYXNEYXRhKCkgPz8gZmFsc2U7XG4gIH1cbiAgZm9jdXNDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnQ/LmZvY3VzQnV0dG9uKCk7XG4gIH1cbiAgYWRkQ29tbWVudEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gIH1cbiAgYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKSB7XG4gICAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmlzRWRpdGluZ01vZGUoKSkge1xuICAgICAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IHRoaXMuI2NvbW1lbnQucmVuZGVyRm9yU3RhbmRhbG9uZSgpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbik7XG4gIH1cbiAgcmVtb3ZlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudC5yZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgfVxuICBoaWRlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgZGVsZXRlZFxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNjb21tZW50O1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0LFxuICAgICAgcmljaFRleHQsXG4gICAgICBkYXRlLFxuICAgICAgZGVsZXRlZCxcbiAgICAgIGNvbG9yOiB0aGlzLmdldE5vbkhDTUNvbG9yKCksXG4gICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHkgPz8gMVxuICAgIH07XG4gIH1cbiAgc2V0IGNvbW1lbnQodGV4dCkge1xuICAgIHRoaXMuI2NvbW1lbnQgfHw9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIHRoaXMuI2NvbW1lbnQuZGF0YSA9IHRleHQ7XG4gICAgaWYgKHRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgdGhpcy5yZW1vdmVDb21tZW50QnV0dG9uRnJvbVRvb2xiYXIoKTtcbiAgICAgIHRoaXMuYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci51cGRhdGVDb21tZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENvbW1lbnRCdXR0b25JblRvb2xiYXIoKTtcbiAgICAgIHRoaXMucmVtb3ZlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVDb21tZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRDb21tZW50RGF0YSh7XG4gICAgY29tbWVudCxcbiAgICBwb3B1cFJlZixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgaWYgKCFwb3B1cFJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50IHx8PSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgICB0aGlzLiNjb21tZW50LnNldEluaXRpYWxUZXh0KGNvbW1lbnQsIHJpY2hUZXh0KTtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZWREYXRhID0gdGhpcy5fdWlNYW5hZ2VyLmdldEFuZFJlbW92ZURhdGFGcm9tQW5ub3RhdGlvblN0b3JhZ2UodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICBpZiAoc3RvcmVkRGF0YSkge1xuICAgICAgdGhpcy51cGRhdGVGcm9tQW5ub3RhdGlvbkxheWVyKHN0b3JlZERhdGEpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzRWRpdGVkQ29tbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudD8uaGFzQmVlbkVkaXRlZCgpO1xuICB9XG4gIGdldCBoYXNEZWxldGVkQ29tbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudD8uaXNEZWxldGVkKCk7XG4gIH1cbiAgZ2V0IGhhc0NvbW1lbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jY29tbWVudCAmJiAhdGhpcy4jY29tbWVudC5pc0VtcHR5KCkgJiYgIXRoaXMuI2NvbW1lbnQuaXNEZWxldGVkKCk7XG4gIH1cbiAgYXN5bmMgZWRpdENvbW1lbnQob3B0aW9ucykge1xuICAgIHRoaXMuI2NvbW1lbnQgfHw9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIHRoaXMuI2NvbW1lbnQuZWRpdChvcHRpb25zKTtcbiAgfVxuICB0b2dnbGVDb21tZW50KGlzU2VsZWN0ZWQsIHZpc2liaWxpdHkgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5oYXNDb21tZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIudG9nZ2xlQ29tbWVudCh0aGlzLCBpc1NlbGVjdGVkLCB2aXNpYmlsaXR5KTtcbiAgICB9XG4gIH1cbiAgc2V0U2VsZWN0ZWRDb21tZW50QnV0dG9uKHNlbGVjdGVkKSB7XG4gICAgdGhpcy4jY29tbWVudC5zZXRTZWxlY3RlZEJ1dHRvbihzZWxlY3RlZCk7XG4gIH1cbiAgYWRkQ29tbWVudChzZXJpYWxpemVkKSB7XG4gICAgaWYgKHRoaXMuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgY29uc3QgREVGQVVMVF9QT1BVUF9XSURUSCA9IDE4MDtcbiAgICAgIGNvbnN0IERFRkFVTFRfUE9QVVBfSEVJR0hUID0gMTAwO1xuICAgICAgY29uc3QgWywsLCB0clldID0gc2VyaWFsaXplZC5yZWN0O1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3QgW3BhZ2VYXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgY29uc3QgYmxYID0gcGFnZVggKyBwYWdlV2lkdGggKyAxO1xuICAgICAgY29uc3QgYmxZID0gdHJZIC0gREVGQVVMVF9QT1BVUF9IRUlHSFQ7XG4gICAgICBjb25zdCB0clggPSBibFggKyBERUZBVUxUX1BPUFVQX1dJRFRIO1xuICAgICAgc2VyaWFsaXplZC5wb3B1cCA9IHtcbiAgICAgICAgY29udGVudHM6IHRoaXMuY29tbWVudC50ZXh0LFxuICAgICAgICBkZWxldGVkOiB0aGlzLmNvbW1lbnQuZGVsZXRlZCxcbiAgICAgICAgcmVjdDogW2JsWCwgYmxZLCB0clgsIHRyWV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIoe1xuICAgIHBvcHVwOiB7XG4gICAgICBjb250ZW50cyxcbiAgICAgIGRlbGV0ZWRcbiAgICB9XG4gIH0pIHtcbiAgICB0aGlzLiNjb21tZW50LmRhdGEgPSBkZWxldGVkID8gbnVsbCA6IGNvbnRlbnRzO1xuICB9XG4gIGdldCBwYXJlbnRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRvci1yb3RhdGlvblwiLCAoMzYwIC0gdGhpcy5yb3RhdGlvbikgJSAzNjApO1xuICAgIGRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuaWQpO1xuICAgIGRpdi50YWJJbmRleCA9IHRoaXMuI2Rpc2FibGVkID8gLTEgOiAwO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYXBwbGljYXRpb25cIik7XG4gICAgaWYgKHRoaXMuZGVmYXVsdEwxMG5JZCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCB0aGlzLmRlZmF1bHRMMTBuSWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jYWRkRm9jdXNMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIGRpdi5zdHlsZS5tYXhXaWR0aCA9IGAkeygxMDAgKiBwYXJlbnRIZWlnaHQgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIGRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGJpbmRFdmVudHModGhpcywgZGl2LCBbXCJrZXlkb3duXCIsIFwicG9pbnRlcmRvd25cIiwgXCJkYmxjbGlja1wiXSk7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUgJiYgdGhpcy5fdWlNYW5hZ2VyLl9zdXBwb3J0c1BpbmNoVG9ab29tKSB7XG4gICAgICB0aGlzLiN0b3VjaE1hbmFnZXIgfHw9IG5ldyBUb3VjaE1hbmFnZXIoe1xuICAgICAgICBjb250YWluZXI6IGRpdixcbiAgICAgICAgaXNQaW5jaGluZ0Rpc2FibGVkOiAoKSA9PiAhdGhpcy5pc1NlbGVjdGVkLFxuICAgICAgICBvblBpbmNoU3RhcnQ6IHRoaXMuI3RvdWNoUGluY2hTdGFydENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hpbmc6IHRoaXMuI3RvdWNoUGluY2hDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBvblBpbmNoRW5kOiB0aGlzLiN0b3VjaFBpbmNoRW5kQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICN0b3VjaFBpbmNoU3RhcnRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgfVxuICAjdG91Y2hQaW5jaENhbGxiYWNrKF9vcmlnaW4sIHByZXZEaXN0YW5jZSwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBzbG93RG93bkZhY3RvciA9IDAuNztcbiAgICBsZXQgZmFjdG9yID0gc2xvd0Rvd25GYWN0b3IgKiAoZGlzdGFuY2UgLyBwcmV2RGlzdGFuY2UpICsgMSAtIHNsb3dEb3duRmFjdG9yO1xuICAgIGlmIChmYWN0b3IgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgZmFjdG9yID0gTWF0aC5tYXgoTWF0aC5taW4oZmFjdG9yLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFdpZHRoICogZmFjdG9yKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZEhlaWdodCAqIGZhY3Rvcik7XG4gICAgaWYgKG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFtzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHRdO1xuICAgIGNvbnN0IHRyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKHNhdmVkV2lkdGggLyAyLCBzYXZlZEhlaWdodCAvIDIpO1xuICAgIGNvbnN0IGNlbnRlclggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFggKyB0cmFuc2ZDZW50ZXJQb2ludFswXSk7XG4gICAgY29uc3QgY2VudGVyWSA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWSArIHRyYW5zZkNlbnRlclBvaW50WzFdKTtcbiAgICBjb25zdCBuZXdUcmFuc2ZDZW50ZXJQb2ludCA9IHRyYW5zZihuZXdXaWR0aCAvIDIsIG5ld0hlaWdodCAvIDIpO1xuICAgIHRoaXMueCA9IGNlbnRlclggLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFswXTtcbiAgICB0aGlzLnkgPSBjZW50ZXJZIC0gbmV3VHJhbnNmQ2VudGVyUG9pbnRbMV07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgI3RvdWNoUGluY2hFbmRDYWxsYmFjaygpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUodHJ1ZSk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbERyYWcgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGUpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICB0aGlzLl9vblN0b3BEcmFnZ2luZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1kgPSBldmVudC5jbGllbnRZO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgaWYgKCFoYXNEcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICBoYXNEcmFnZ2luZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci50b2dnbGVDb21tZW50KHRoaXMsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9vblN0YXJ0RHJhZ2dpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xpZW50WDogeCxcbiAgICAgICAgICBjbGllbnRZOiB5LFxuICAgICAgICAgIHBvaW50ZXJJZFxuICAgICAgICB9ID0gZTtcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdGhpcy4jZHJhZ1BvaW50ZXJJZCkge1xuICAgICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHggLSB0aGlzLiNwcmV2RHJhZ1gsIHkgLSB0aGlzLiNwcmV2RHJhZ1kpO1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1ggPSB4O1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1kgPSB5O1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIG9wdHMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IHRoaXMuI2RyYWdQb2ludGVyVHlwZSkge1xuICAgICAgICAgIGlmICh0aGlzLiN0b3VjaE1hbmFnZXIgfHwgZS5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNkcmFnUG9pbnRlcklkIHx8IHRoaXMuI2RyYWdQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3BFdmVudChlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIF9vblN0YXJ0RHJhZ2dpbmcoKSB7fVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7fVxuICBtb3ZlSW5ET00oKSB7XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLnBhcmVudD8ubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICAgIH0sIDApO1xuICB9XG4gIF9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpIHtcbiAgICBwYXJlbnQuY2hhbmdlUGFyZW50KHRoaXMpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHksIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBzaGlmdFggPSB0eCAvIHNjYWxlO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHR5IC8gc2NhbGU7XG4gICAgY29uc3QgeCA9IHRoaXMueCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVksIHggKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSArIHBhZ2VZXTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHBhZ2VZLCB4ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBwYWdlWSwgeCAtIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VZLCB4IC0gc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYICsgcGFnZVldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVjdEluQ3VycmVudENvb3JkcyhyZWN0LCBwYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJlY3Q7XG4gICAgY29uc3Qgd2lkdGggPSB4MiAtIHgxO1xuICAgIGNvbnN0IGhlaWdodCA9IHkyIC0geTE7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5Miwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkyLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFBERlJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgfVxuICBnZXROb25IQ01Db2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvciAmJiBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3IodGhpcy5jb2xvcikpO1xuICB9XG4gIG9uVXBkYXRlZENvbG9yKCkge1xuICAgIHRoaXMuI2NvbW1lbnQ/Lm9uVXBkYXRlZENvbG9yKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIHRleHQ6IHN0cixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGRhdGUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIHJpY2hUZXh0XG4gICAgICB9LFxuICAgICAgdWlkOiBpZCxcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBwYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHJpY2hUZXh0LFxuICAgICAgY29udGVudHNPYmo6IHtcbiAgICAgICAgc3RyXG4gICAgICB9LFxuICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogZGF0ZSB8fCBtb2RpZmljYXRpb25EYXRlLFxuICAgICAgcG9wdXBSZWY6ICFkZWxldGVkLFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5XG4gICAgfTtcbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkO1xuICB9XG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuICBnZXQgaXNPblNjcmVlbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgYm90dG9tLFxuICAgICAgcmlnaHRcbiAgICB9ID0gdGhpcy5nZXRDbGllbnREaW1lbnNpb25zKCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICBpbm5lcldpZHRoXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbGVmdCA8IGlubmVyV2lkdGggJiYgcmlnaHQgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0ICYmIGJvdHRvbSA+IDA7XG4gIH1cbiAgI2FkZEZvY3VzTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c0FDIHx8ICF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLmZvY3VzaW4uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICB9XG4gIHJvdGF0ZShfYW5nbGUpIHt9XG4gIHJlc2l6ZSgpIHt9XG4gIHNlcmlhbGl6ZURlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBkZWxldGVkOiB0cnVlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHBvcHVwUmVmOiB0aGlzLl9pbml0aWFsRGF0YT8ucG9wdXBSZWYgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogdGhpcy5tb2RlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCxcbiAgICAgIHBvcHVwUmVmOiB0aGlzLl9pbml0aWFsRGF0YT8ucG9wdXBSZWYgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXIsXG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBkYXRhLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBjcmVhdGlvbkRhdGU6IGRhdGEuY3JlYXRpb25EYXRlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogZGF0YS5tb2RpZmljYXRpb25EYXRlXG4gICAgfSk7XG4gICAgZWRpdG9yLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICBlZGl0b3IuI2FjY2Vzc2liaWxpdHlEYXRhID0gZGF0YS5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICBlZGl0b3IuX2lzQ29weSA9IGRhdGEuaXNDb3B5IHx8IGZhbHNlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgaGFzQmVlbk1vZGlmaWVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAodGhpcy5kZWxldGVkIHx8IHRoaXMuc2VyaWFsaXplKCkgIT09IG51bGwpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNmb2N1c0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzQUMgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMucmVtb3ZlRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMpIHtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dCBvZiB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXIgPSBudWxsO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFsxLCAwXSA6IFswLCAwXTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRCdXR0b25Qb3NpdGlvbjogW3Bvc1gsIHBvc1ldXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSB0aGlzLmdldFBERlJlY3QoKTtcbiAgICByZXR1cm4gW0Fubm90YXRpb25FZGl0b3IuX3JvdW5kKGJsWCArICh0clggLSBibFgpICogcG9zWCksIEFubm90YXRpb25FZGl0b3IuX3JvdW5kKGJsWSArICh0clkgLSBibFkpICogKDEgLSBwb3NZKSldO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5tYWtlQ29tbWVudENvbG9yKHRoaXMuZ2V0Tm9uSENNQ29sb3IoKSwgdGhpcy5vcGFjaXR5KTtcbiAgfVxuICBnZXQgY29tbWVudFBvcHVwUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQuY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyO1xuICB9XG4gIHNldCBjb21tZW50UG9wdXBQb3NpdGlvbihwb3MpIHtcbiAgICB0aGlzLiNjb21tZW50LmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllciA9IHBvcztcbiAgfVxuICBoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudC5oYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQuY29tbWVudEJ1dHRvbldpZHRoO1xuICB9XG4gIGdldCBlbGVtZW50QmVmb3JlUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldENvbW1lbnRCdXR0b25TdGF0ZXMob3B0aW9ucykge1xuICAgIHRoaXMuI2NvbW1lbnQuc2V0Q29tbWVudEJ1dHRvblN0YXRlcyhvcHRpb25zKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzUmVzaXphYmxlIHx8IGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYgfHwgZXZlbnQua2V5ICE9PSBcIkVudGVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuI3Jlc2l6ZXJzRGl2LmNoaWxkcmVuO1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHRoaXMuI2FsbFJlc2l6ZXJEaXZzID0gQXJyYXkuZnJvbShjaGlsZHJlbik7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJLZXlkb3duID0gdGhpcy4jcmVzaXplcktleWRvd24uYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplckJsdXIgPSB0aGlzLiNyZXNpemVyQmx1ci5iaW5kKHRoaXMpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNwaW5idXR0b25cIik7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBib3VuZFJlc2l6ZXJLZXlkb3duLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYm91bmRSZXNpemVyQmx1ciwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNyZXNpemVyRm9jdXMuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbMF07XG4gICAgbGV0IGZpcnN0UG9zaXRpb24gPSAwO1xuICAgIGZvciAoY29uc3QgZGl2IG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoZGl2ID09PSBmaXJzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZpcnN0UG9zaXRpb24rKztcbiAgICB9XG4gICAgY29uc3QgbmV4dEZpcnN0UG9zaXRpb24gPSAoMzYwIC0gdGhpcy5yb3RhdGlvbiArIHRoaXMucGFyZW50Um90YXRpb24pICUgMzYwIC8gOTAgKiAodGhpcy4jYWxsUmVzaXplckRpdnMubGVuZ3RoIC8gNCk7XG4gICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uICE9PSBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gPCBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RQb3NpdGlvbiAtIG5leHRGaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQodGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dEZpcnN0UG9zaXRpb24gPiBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEZpcnN0UG9zaXRpb24gLSBmaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmJlZm9yZSh0aGlzLiNyZXNpemVyc0Rpdi5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzW2krK107XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgwKTtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSB0cnVlO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjcmVzaXplcktleWRvd24oZXZlbnQpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNyZXNpemVyQmx1cihldmVudCkge1xuICAgIGlmICh0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgJiYgZXZlbnQucmVsYXRlZFRhcmdldD8ucGFyZW50Tm9kZSAhPT0gdGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgfVxuICAjcmVzaXplckZvY3VzKG5hbWUpIHtcbiAgICB0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUgPSB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPyBuYW1lIDogXCJcIjtcbiAgfVxuICAjc2V0UmVzaXplclRhYkluZGV4KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgZGl2LnRhYkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIF9yZXNpemVXaXRoS2V5Ym9hcmQoeCwgeSkge1xuICAgIGlmICghdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZSh0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUsIHtcbiAgICAgIGRlbHRhWDogeCxcbiAgICAgIGRlbHRhWTogeSxcbiAgICAgIGZyb21LZXlib2FyZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNzdG9wUmVzaXppbmcoKSB7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KC0xKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5fZWRpdFRvb2xiYXIuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKGZhbHNlKTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAodGhpcy5kaXYgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGl2Py5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pLCAwKTtcbiAgICB9XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy4jcmVzaXplcnNEaXY/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAodGhpcy5kaXY/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyLmRpdi5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZSh0cnVlKTtcbiAgICBpZiAodGhpcy5oYXNDb21tZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIudG9nZ2xlQ29tbWVudCh0aGlzLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG4gIGRpc2FibGVFZGl0aW5nKCkge31cbiAgZW5hYmxlRWRpdGluZygpIHt9XG4gIGdldCBjYW5DaGFuZ2VDb250ZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkNoYW5nZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkJVVFRPTlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcih7XG4gICAgICBtb2RlOiB0aGlzLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlLFxuICAgICAgZWRpdElkOiB0aGlzLmlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0RWxlbWVudEZvckFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgaXNFZGl0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0VkaXRpbmc7XG4gIH1cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IE1JTl9TSVpFKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIlxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfcmVwb3J0VGVsZW1ldHJ5KGRhdGEsIG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzIHx8PSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBsZXQgdGltZW91dCA9IHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmdldChhY3Rpb24pO1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoZGF0YSk7XG4gICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgQW5ub3RhdGlvbkVkaXRvci5fdGVsZW1ldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zZXQoYWN0aW9uLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS50eXBlIHx8PSB0aGlzLmVkaXRvclR5cGU7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICBkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJsZSk7XG4gICAgdGhpcy5faXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gZmFsc2U7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gdHJ1ZTtcbiAgfVxuICB1cGRhdGVGYWtlQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgaWYgKCF0aGlzLiNmYWtlQW5ub3RhdGlvbiAmJiAhdGhpcy5kZWxldGVkKSB7XG4gICAgICB0aGlzLiNmYWtlQW5ub3RhdGlvbiA9IGFubm90YXRpb25MYXllci5hZGRGYWtlQW5ub3RhdGlvbih0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNmYWtlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkKSB7XG4gICAgICB0aGlzLiNmYWtlQW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgICAgcG9wdXA6IHRoaXMuY29tbWVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICBhbm5vdGF0aW9uLmhpZGUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGFubm90YXRpb24uY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuYW5ub3RhdGlvbkNvbnRlbnRcIik7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBhbm5vdGF0aW9uLmNvbnRhaW5lci5wcmVwZW5kKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgY29uc3QgY2FudmFzID0gY29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGNhbnZhcy5iZWZvcmUoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9ID0gYW5ub3RhdGlvbi5jb250YWluZXI7XG4gICAgaWYgKGZpcnN0Q2hpbGQ/Lm5vZGVOYW1lID09PSBcIkRJVlwiICYmIGZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBGYWtlRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1zLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgdGhpcy5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbXVybXVyaGFzaDMuanNcblxuXG5cblxuXG5cblxuXG5jb25zdCBTRUVEID0gMHhjM2QyZTFmMDtcbmNvbnN0IE1BU0tfSElHSCA9IDB4ZmZmZjAwMDA7XG5jb25zdCBNQVNLX0xPVyA9IDB4ZmZmZjtcbmNsYXNzIE11cm11ckhhc2gzXzY0IHtcbiAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgIHRoaXMuaDEgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICAgIHRoaXMuaDIgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICB9XG4gIHVwZGF0ZShpbnB1dCkge1xuICAgIGxldCBkYXRhLCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDIpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDw9IDB4ZmYpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgpO1xuICAgICAgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgZm9ybWF0LCBtdXN0IGJlIGEgc3RyaW5nIG9yIFR5cGVkQXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fc3RvcmFnZS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHVuZGVmaW5lZFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjZWRpdG9yc01hcCA9IG51bGw7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0b3JlZFZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgdGhpcy4jZWRpdG9yc01hcC5kZWxldGUoc3RvcmVkVmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgKHRoaXMuI2VkaXRvcnNNYXAgfHw9IG5ldyBNYXAoKSkuc2V0KHZhbHVlLmFubm90YXRpb25FbGVtZW50SWQsIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlciA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxuICBnZXQgZWRpdG9yU3RhdHMoKSB7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBjb25zdCB0eXBlVG9FZGl0b3IgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPSAwO1xuICAgIGxldCBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5wb3B1cCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5wb3B1cC5kZWxldGVkKSB7XG4gICAgICAgICAgICBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmlzQ29tbWVudERlbGV0ZWQpIHtcbiAgICAgICAgbnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JTdGF0cyA9IHZhbHVlLnRlbGVtZXRyeUZpbmFsRGF0YTtcbiAgICAgIGlmICghZWRpdG9yU3RhdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlZGl0b3JTdGF0cztcbiAgICAgIGlmICghdHlwZVRvRWRpdG9yLmhhcyh0eXBlKSkge1xuICAgICAgICB0eXBlVG9FZGl0b3Iuc2V0KHR5cGUsIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgc3RhdHMgfHw9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb25zdCBtYXAgPSBzdGF0c1t0eXBlXSB8fD0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGVkaXRvclN0YXRzKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudGVycyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjb3VudGVycykge1xuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudGVycy5nZXQodmFsKSA/PyAwO1xuICAgICAgICBjb3VudGVycy5zZXQodmFsLCBjb3VudCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgPiAwIHx8IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPiAwKSB7XG4gICAgICBzdGF0cyB8fD0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHN0YXRzLmNvbW1lbnRzID0ge1xuICAgICAgICBkZWxldGVkOiBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyxcbiAgICAgICAgZWRpdGVkOiBudW1iZXJPZkVkaXRlZENvbW1lbnRzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXN0YXRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZWRpdG9yXSBvZiB0eXBlVG9FZGl0b3IpIHtcbiAgICAgIHN0YXRzW3R5cGVdID0gZWRpdG9yLmNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoc3RhdHNbdHlwZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgcmVzZXRNb2RpZmllZElkcygpIHtcbiAgICB0aGlzLiNtb2RpZmllZElkcyA9IG51bGw7XG4gIH1cbiAgdXBkYXRlRWRpdG9yKGFubm90YXRpb25JZCwgZGF0YSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZWRpdG9yc01hcD8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZS51cGRhdGVGcm9tQW5ub3RhdGlvbkxheWVyKGRhdGEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRFZGl0b3IoYW5ub3RhdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnNNYXA/LmdldChhbm5vdGF0aW9uSWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZElkcykge1xuICAgICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBpZiAodGhpcy4jZWRpdG9yc01hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNlZGl0b3JzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghdmFsdWUuc2VyaWFsaXplKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZHMucHVzaCh2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzID0ge1xuICAgICAgaWRzOiBuZXcgU2V0KGlkcyksXG4gICAgICBoYXNoOiBpZHMuam9pbihcIixcIilcbiAgICB9O1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmVudHJpZXMoKTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwibW9kaWZpZWRJZHNcIiwge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZm9udF9sb2FkZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmxvYWRUZXN0Rm9udElkID0gMDtcbiAgfVxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICByZW1vdmVOYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHRoaXMuc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBuYXRpdmVGb250RmFjZSBvZiB0aGlzLm5hdGl2ZUZvbnRGYWNlcykge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNzeXN0ZW1Gb250cy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRTeXN0ZW1Gb250KHtcbiAgICBzeXN0ZW1Gb250SW5mbzogaW5mbyxcbiAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgX2luc3BlY3RGb250XG4gIH0pIHtcbiAgICBpZiAoIWluZm8gfHwgdGhpcy4jc3lzdGVtRm9udHMuaGFzKGluZm8ubG9hZGVkTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0KCFkaXNhYmxlRm9udEZhY2UsIFwibG9hZFN5c3RlbUZvbnQgc2hvdWxkbid0IGJlIGNhbGxlZCB3aGVuIGBkaXNhYmxlRm9udEZhY2VgIGlzIHNldC5cIik7XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsb2FkZWROYW1lLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGxvYWRlZE5hbWUsIHNyYywgc3R5bGUpO1xuICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIHRoaXMuI3N5c3RlbUZvbnRzLmFkZChsb2FkZWROYW1lKTtcbiAgICAgICAgX2luc3BlY3RGb250Py4oaW5mbyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgd2FybihgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWQ6IGxvYWRTeXN0ZW1Gb250IHdpdGhvdXQgdGhlIEZvbnQgTG9hZGluZyBBUEkuXCIpO1xuICB9XG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUgJiYgIWZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG4gICAgaWYgKGZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZFN5c3RlbUZvbnQoZm9udCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5hdGl2ZUZvbnRGYWNlLmxvYWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9hZCBmb250ICcke25hdGl2ZUZvbnRGYWNlLmZhbWlseX0nOiAnJHtleH0nLmApO1xuICAgICAgICAgIGZvbnQuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZm9udC5jcmVhdGVGb250RmFjZVJ1bGUoKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgaWYgKHRoaXMuaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQoKSB7XG4gICAgY29uc3QgaGFzRm9udHMgPSAhIXRoaXMuX2RvY3VtZW50Py5mb250cztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBpc05vZGVKUyB8fCB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCk7XG4gIH1cbiAgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgYXNzZXJ0KCFyZXF1ZXN0LmRvbmUsIFwiY29tcGxldGVSZXF1ZXN0KCkgY2Fubm90IGJlIGNhbGxlZCB0d2ljZS5cIik7XG4gICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGxvYWRpbmdSZXF1ZXN0cy5sZW5ndGggPiAwICYmIGxvYWRpbmdSZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgIGNvbnN0IG90aGVyUmVxdWVzdCA9IGxvYWRpbmdSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBzZXRUaW1lb3V0KG90aGVyUmVxdWVzdC5jYWxsYmFjaywgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdSZXF1ZXN0c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICBjYWxsYmFja1xuICAgIH07XG4gICAgbG9hZGluZ1JlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgY29uc3QgdGVzdEZvbnQgPSBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgd2FybihcIkxvYWQgdGVzdCBmb250IG5ldmVyIGxvYWRlZC5cIik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgIGlmIChpbWFnZURhdGEuZGF0YVszXSA+IDApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgbGV0IGRhdGEgPSB0aGlzLl9sb2FkVGVzdEZvbnQ7XG4gICAgY29uc3QgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgY29uc3QgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgIGNvbnN0IFhYWFhfVkFMVUUgPSAweDU4NTg1ODU4O1xuICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICB9XG4gICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgfVxuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCwgNCwgc3RyaW5nMzIoY2hlY2tzdW0pKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBjb25zdCBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHtsb2FkVGVzdEZvbnRJZH1cIjtzcmM6JHt1cmx9fWA7XG4gICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSBcIjEwcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2ZvbnQubG9hZGVkTmFtZSwgbG9hZFRlc3RGb250SWRdKSB7XG4gICAgICBjb25zdCBzcGFuID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJIaVwiO1xuICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgIGRpdi5hcHBlbmQoc3Bhbik7XG4gICAgfVxuICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgaXNGb250UmVhZHkobG9hZFRlc3RGb250SWQsICgpID0+IHtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9udEZhY2VPYmplY3Qge1xuICAjZm9udERhdGE7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCBpbnNwZWN0Rm9udCA9IG51bGwsIGV4dHJhLCBjaGFyUHJvY09wZXJhdG9yTGlzdCkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuI2ZvbnREYXRhID0gdHJhbnNsYXRlZERhdGE7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgICBpZiAoZXh0cmEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXh0cmEpO1xuICAgIH1cbiAgICBpZiAoY2hhclByb2NPcGVyYXRvckxpc3QpIHtcbiAgICAgIHRoaXMuY2hhclByb2NPcGVyYXRvckxpc3QgPSBjaGFyUHJvY09wZXJhdG9yTGlzdDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7dG9CYXNlNjRVdGlsKHRoaXMuZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBjb25zdCBvYmpJZCA9IHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXI7XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldChvYmpJZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoY21kcyB8fCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuZm9udEV4dHJhUHJvcGVydGllcykge1xuICAgICAgb2Jqcy5kZWxldGUob2JqSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gcGF0aDtcbiAgfVxuICBnZXQgYmxhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJsYWNrO1xuICB9XG4gIGdldCBib2xkKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5ib2xkO1xuICB9XG4gIGdldCBkaXNhYmxlRm9udEZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRpc2FibGVGb250RmFjZSA/PyBmYWxzZTtcbiAgfVxuICBnZXQgZm9udEV4dHJhUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZm9udEV4dHJhUHJvcGVydGllcyA/PyBmYWxzZTtcbiAgfVxuICBnZXQgaXNJbnZhbGlkUERGanNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pc0ludmFsaWRQREZqc0ZvbnQ7XG4gIH1cbiAgZ2V0IGlzVHlwZTNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pc1R5cGUzRm9udDtcbiAgfVxuICBnZXQgaXRhbGljKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5pdGFsaWM7XG4gIH1cbiAgZ2V0IG1pc3NpbmdGaWxlKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5taXNzaW5nRmlsZTtcbiAgfVxuICBnZXQgcmVtZWFzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5yZW1lYXN1cmU7XG4gIH1cbiAgZ2V0IHZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS52ZXJ0aWNhbDtcbiAgfVxuICBnZXQgYXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5hc2NlbnQ7XG4gIH1cbiAgZ2V0IGRlZmF1bHRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZGVmYXVsdFdpZHRoO1xuICB9XG4gIGdldCBkZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZXNjZW50O1xuICB9XG4gIGdldCBiYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5iYm94O1xuICB9XG4gIGdldCBmb250TWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5mb250TWF0cml4O1xuICB9XG4gIGdldCBmYWxsYmFja05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmZhbGxiYWNrTmFtZTtcbiAgfVxuICBnZXQgbG9hZGVkTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEubG9hZGVkTmFtZTtcbiAgfVxuICBnZXQgbWltZXR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm1pbWV0eXBlO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5uYW1lO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kYXRhO1xuICB9XG4gIGNsZWFyRGF0YSgpIHtcbiAgICB0aGlzLiNmb250RGF0YS5jbGVhckRhdGEoKTtcbiAgfVxuICBnZXQgY3NzRm9udEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmNzc0ZvbnRJbmZvO1xuICB9XG4gIGdldCBzeXN0ZW1Gb250SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuc3lzdGVtRm9udEluZm87XG4gIH1cbiAgZ2V0IGRlZmF1bHRWTWV0cmljcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZGVmYXVsdFZNZXRyaWNzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaV91dGlscy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldFVybFByb3AodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4gdmFsLmhyZWY7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IFVSTC5wYXJzZSh2YWwsIHdpbmRvdy5sb2NhdGlvbik7XG4gICAgaWYgKHVybCkge1xuICAgICAgcmV0dXJuIHVybC5ocmVmO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpIHx8IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgXCIgKyBcInN0cmluZywgb3IgYXJyYXktbGlrZSBvYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIGRhdGEgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RmFjdG9yeVVybFByb3AodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHZhbC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmYWN0b3J5IHVybDogXCIke3ZhbH1cIiBtdXN0IGluY2x1ZGUgdHJhaWxpbmcgc2xhc2guYCk7XG59XG5jb25zdCBpc1JlZlByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/Lm51bSkgJiYgdi5udW0gPj0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/LmdlbikgJiYgdi5nZW4gPj0gMDtcbmNvbnN0IGlzTmFtZVByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdj8ubmFtZSA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzVmFsaWRFeHBsaWNpdERlc3QgPSBfaXNWYWxpZEV4cGxpY2l0RGVzdC5iaW5kKG51bGwsIGlzUmVmUHJveHksIGlzTmFtZVByb3h5KTtcbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL21lc3NhZ2VfaGFuZGxlci5qc1xuXG5cblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gb25GbigpIHt9XG5mdW5jdGlvbiB3cmFwUmVhc29uKGV4KSB7XG4gIGlmIChleCBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgSW52YWxpZFBERkV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFBhc3N3b3JkRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUmVzcG9uc2VFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBVbmtub3duRXJyb3JFeGNlcHRpb24pIHtcbiAgICByZXR1cm4gZXg7XG4gIH1cbiAgaWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXggPT09IFwib2JqZWN0XCIgJiYgZXggIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgQWJvcnRFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgY2FzZSBcIlJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cywgZXgubWlzc2luZyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXgudG9TdHJpbmcoKSk7XG59XG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gICNtZXNzYWdlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuI29uTWVzc2FnZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWw6IHRoaXMuI21lc3NhZ2VBQy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICAjb25NZXNzYWdlKHtcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSB0aGlzLnNvdXJjZU5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICB0aGlzLiNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XG4gICAgICBjb25zdCBjYXBhYmlsaXR5ID0gdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGNhbGxiYWNrICR7Y2FsbGJhY2tJZH1gKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuRVJST1IpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke2RhdGEuYWN0aW9ufWApO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIFByb21pc2UudHJ5KGFjdGlvbiwgZGF0YS5kYXRhKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuRVJST1IsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICB0aGlzLiNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgfVxuICBvbihhY3Rpb25OYW1lLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG4gIHNlbmQoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YVxuICAgIH0sIHRyYW5zZmVycyk7XG4gIH1cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiY2FuY2VsIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG4gICNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG4gICAgICAgIGlmIChsYXN0RGVzaXJlZFNpemUgPiAwICYmIHRoaXMuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FTlFVRVVFLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIFByb21pc2UudHJ5KGFjdGlvbiwgZGF0YS5kYXRhLCBzdHJlYW1TaW5rKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAjcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLFxuICAgICAgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25QdWxsIHx8IG9uRm4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVOUVVFVUU6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoZGF0YS5jaHVuayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNMT1NFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFSZWFzb24gPSB3cmFwUmVhc29uKGRhdGEucmVhc29uKTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vbkNhbmNlbCB8fCBvbkZuLCBkYXRhUmVhc29uKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3QoZGF0YVJlYXNvbik7XG4gICAgICAgIHN0cmVhbVNpbmsuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW3N0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGw/LnByb21pc2VdKTtcbiAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNtZXNzYWdlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jbWVzc2FnZUFDID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXNfZmFjdG9yeS5qc1xuXG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gICNlbmFibGVIV0EgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLiNlbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy4jZW5hYmxlSFdBXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jbWFwX3JlYWRlcl9mYWN0b3J5LmpzXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSB0cnVlXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuaXNDb21wcmVzc2VkID0gaXNDb21wcmVzc2VkO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgdGhlIGBjTWFwVXJsYCBhbmQgYGNNYXBQYWNrZWRgIEFQSSBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ01hcCBuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5iYXNlVXJsICsgbmFtZSArICh0aGlzLmlzQ29tcHJlc3NlZCA/IFwiLmJjbWFwXCIgOiBcIlwiKTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS50aGVuKGNNYXBEYXRhID0+ICh7XG4gICAgICBjTWFwRGF0YSxcbiAgICAgIGlzQ29tcHJlc3NlZDogdGhpcy5pc0NvbXByZXNzZWRcbiAgICB9KSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgJHt0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIn1DTWFwIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkID8gXCJhcnJheWJ1ZmZlclwiIDogXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShkYXRhKSA6IHN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZmlsdGVyLmpzXG52YXIgZXNfaXRlcmF0b3JfZmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDg5KTtcbjsvLyAuL3NyYy9kaXNwbGF5L2ZpbHRlcl9mYWN0b3J5LmpzXG5cblxuXG5cbmNsYXNzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuY2xhc3MgRE9NRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI2Jhc2VVcmw7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNfaGNtQ2FjaGU7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2hjbUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfaGNtQ2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICAjY3JlYXRlVGFibGVzKG1hcHMpIHtcbiAgICBpZiAobWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1hcFIgPSBtYXBzWzBdO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZSA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBbdGFibGUsIHRhYmxlLCB0YWJsZV07XG4gICAgfVxuICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlclIuam9pbihcIixcIiksIGJ1ZmZlckcuam9pbihcIixcIiksIGJ1ZmZlckIuam9pbihcIixcIildO1xuICB9XG4gICNjcmVhdGVVcmwoaWQpIHtcbiAgICBpZiAodGhpcy4jYmFzZVVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLiNiYXNlVXJsID0gXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2RvY3VtZW50LlVSTDtcbiAgICAgIGlmICh1cmwgIT09IHRoaXMuI2RvY3VtZW50LmJhc2VVUkkpIHtcbiAgICAgICAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgICAgICAgd2FybignI2NyZWF0ZVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jYmFzZVVybCA9IHVwZGF0ZVVybEhhc2godXJsLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYHVybCgke3RoaXMuI2Jhc2VVcmx9IyR7aWR9KWA7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVSLCB0YWJsZUcsIHRhYmxlQl0gPSB0aGlzLiNjcmVhdGVUYWJsZXMobWFwcyk7XG4gICAgY29uc3Qga2V5ID0gbWFwcy5sZW5ndGggPT09IDEgPyB0YWJsZVIgOiBgJHt0YWJsZVJ9JHt0YWJsZUd9JHt0YWJsZUJ9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGNvbnN0IGZpbHRlck5hbWUgPSBcImJhc2VcIjtcbiAgICBsZXQgaW5mbyA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbz8ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uZmlsdGVyPy5yZW1vdmUoKTtcbiAgICAgIGluZm8ua2V5ID0ga2V5O1xuICAgICAgaW5mby51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8uZmlsdGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbyk7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBmZ1JHQiA9IHRoaXMuI2dldFJHQihmZ0NvbG9yKTtcbiAgICBmZ0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZmdSR0IpO1xuICAgIGNvbnN0IGJnUkdCID0gdGhpcy4jZ2V0UkdCKGJnQ29sb3IpO1xuICAgIGJnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5iZ1JHQik7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgaWYgKGZnQ29sb3IgPT09IFwiIzAwMDAwMFwiICYmIGJnQ29sb3IgPT09IFwiI2ZmZmZmZlwiIHx8IGZnQ29sb3IgPT09IGJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlLCB0YWJsZSwgdGFibGUsIGZpbHRlcik7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChjLCBuKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IGZnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgZW5kID0gYmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHN0YXJ0ICsgaSAvIG4gKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcygwLCA1KSwgZ2V0U3RlcHMoMSwgNSksIGdldFN0ZXBzKDIsIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICBjb25zdCBrZXkgPSBgYWxwaGFfJHt0YWJsZUF9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2FscGhhX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCB8fCBcImx1bWlub3NpdHlcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZUEsIGtleTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgICBrZXkgPSBgbHVtaW5vc2l0eV8ke3RhYmxlQX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcImx1bWlub3NpdHlcIjtcbiAgICB9XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9sdW1pbm9zaXR5X21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtXyR7ZmlsdGVyTmFtZX1fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvLnVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgcmV0dXJuIGluZm8udXJsO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7XG4gICAgaWYgKGtlZXBIQ00gJiYgdGhpcy4jX2hjbUNhY2hlPy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI19kZWZzPy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgdGhpcy4jX2RlZnMgPSBudWxsO1xuICAgIHRoaXMuI19jYWNoZT8uY2xlYXIoKTtcbiAgICB0aGlzLiNfY2FjaGUgPSBudWxsO1xuICAgIHRoaXMuI19oY21DYWNoZT8uY2xlYXIoKTtcbiAgICB0aGlzLiNfaGNtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuI2lkID0gMDtcbiAgfVxuICAjYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwLjMgMC41OSAwLjExIDAgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAgMCAwIDEgMFwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29sb3JNYXRyaXgpO1xuICB9XG4gICNjcmVhdGVGaWx0ZXIoaWQpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZpbHRlclwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwic1JHQlwiKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIHRoaXMuI2RlZnMuYXBwZW5kKGZpbHRlcik7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICAjYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIGZ1bmMsIHRhYmxlKSB7XG4gICAgY29uc3QgZmVGdW5jID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgZnVuYyk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkaXNjcmV0ZVwiKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidGFibGVWYWx1ZXNcIiwgdGFibGUpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kKGZlRnVuYyk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihyVGFibGUsIGdUYWJsZSwgYlRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jUlwiLCByVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0dcIiwgZ1RhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNCXCIsIGJUYWJsZSk7XG4gIH1cbiAgI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKGFUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0FcIiwgYVRhYmxlKTtcbiAgfVxuICAjZ2V0UkdCKGNvbG9yKSB7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgIHJldHVybiBnZXRSR0IoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNkZWZzKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIikpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N0YW5kYXJkX2ZvbnRkYXRhX2ZhY3RvcnkuanNcblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgc3RhbmRhcmRGb250RGF0YVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIGZvbnQgZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS93YXNtX2ZhY3RvcnkuanNcblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQmFzZVdhc21GYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgd2FzbVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldhc20gZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIHdhc20gZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVdhc21GYWN0b3J5IGV4dGVuZHMgQmFzZVdhc21GYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuaWYgKGlzTm9kZUpTKSB7XG4gIGxldCBjYW52YXM7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVxdWlyZSA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcIm1vZHVsZVwiKS5jcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4gICAgdHJ5IHtcbiAgICAgIGNhbnZhcyA9IHJlcXVpcmUoXCJAbmFwaS1ycy9jYW52YXNcIik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYENhbm5vdCBsb2FkIFwiQG5hcGktcnMvY2FudmFzXCIgcGFja2FnZTogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICB3YXJuKGBDYW5ub3QgYWNjZXNzIHRoZSBcXGByZXF1aXJlXFxgIGZ1bmN0aW9uOiBcIiR7ZXh9XCIuYCk7XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLkRPTU1hdHJpeCkge1xuICAgIGlmIChjYW52YXM/LkRPTU1hdHJpeCkge1xuICAgICAgZ2xvYmFsVGhpcy5ET01NYXRyaXggPSBjYW52YXMuRE9NTWF0cml4O1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHBvbHlmaWxsIGBET01NYXRyaXhgLCByZW5kZXJpbmcgbWF5IGJlIGJyb2tlbi5cIik7XG4gICAgfVxuICB9XG4gIGlmICghZ2xvYmFsVGhpcy5JbWFnZURhdGEpIHtcbiAgICBpZiAoY2FudmFzPy5JbWFnZURhdGEpIHtcbiAgICAgIGdsb2JhbFRoaXMuSW1hZ2VEYXRhID0gY2FudmFzLkltYWdlRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcIkNhbm5vdCBwb2x5ZmlsbCBgSW1hZ2VEYXRhYCwgcmVuZGVyaW5nIG1heSBiZSBicm9rZW4uXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuUGF0aDJEKSB7XG4gICAgaWYgKGNhbnZhcz8uUGF0aDJEKSB7XG4gICAgICBnbG9iYWxUaGlzLlBhdGgyRCA9IGNhbnZhcy5QYXRoMkQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXCJDYW5ub3QgcG9seWZpbGwgYFBhdGgyRGAsIHJlbmRlcmluZyBtYXkgYmUgYnJva2VuLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLm5hdmlnYXRvcj8ubGFuZ3VhZ2UpIHtcbiAgICBnbG9iYWxUaGlzLm5hdmlnYXRvciA9IHtcbiAgICAgIGxhbmd1YWdlOiBcImVuLVVTXCIsXG4gICAgICBwbGF0Zm9ybTogXCJcIixcbiAgICAgIHVzZXJBZ2VudDogXCJcIlxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCkge1xuICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodXJsKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlcXVpcmUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJtb2R1bGVcIikuY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHJlcXVpcmUoXCJAbmFwaS1ycy9jYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZm9yLWVhY2guanNcbnZhciBlc19pdGVyYXRvcl9mb3JfZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU4OCk7XG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXNfZGVwZW5kZW5jeV90cmFja2VyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMID0gXCJfX2ZvcmNlZERlcGVuZGVuY3lcIjtcbmNvbnN0IHtcbiAgZmxvb3IsXG4gIGNlaWxcbn0gPSBNYXRoO1xuZnVuY3Rpb24gZXhwYW5kQkJveChhcnJheSwgaW5kZXgsIG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgYXJyYXlbaW5kZXggKiA0ICsgMF0gPSBNYXRoLm1pbihhcnJheVtpbmRleCAqIDQgKyAwXSwgbWluWCk7XG4gIGFycmF5W2luZGV4ICogNCArIDFdID0gTWF0aC5taW4oYXJyYXlbaW5kZXggKiA0ICsgMV0sIG1pblkpO1xuICBhcnJheVtpbmRleCAqIDQgKyAyXSA9IE1hdGgubWF4KGFycmF5W2luZGV4ICogNCArIDJdLCBtYXhYKTtcbiAgYXJyYXlbaW5kZXggKiA0ICsgM10gPSBNYXRoLm1heChhcnJheVtpbmRleCAqIDQgKyAzXSwgbWF4WSk7XG59XG5jb25zdCBFTVBUWV9CQk9YID0gbmV3IFVpbnQzMkFycmF5KG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMCwgMF0pLmJ1ZmZlcilbMF07XG5jbGFzcyBCQm94UmVhZGVyIHtcbiAgI2Jib3hlcztcbiAgI2Nvb3JkcztcbiAgY29uc3RydWN0b3IoYmJveGVzLCBjb29yZHMpIHtcbiAgICB0aGlzLiNiYm94ZXMgPSBiYm94ZXM7XG4gICAgdGhpcy4jY29vcmRzID0gY29vcmRzO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3hlcy5sZW5ndGg7XG4gIH1cbiAgaXNFbXB0eShpKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3hlc1tpXSA9PT0gRU1QVFlfQkJPWDtcbiAgfVxuICBtaW5YKGkpIHtcbiAgICByZXR1cm4gdGhpcy4jY29vcmRzW2kgKiA0ICsgMF0gLyAyNTY7XG4gIH1cbiAgbWluWShpKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nvb3Jkc1tpICogNCArIDFdIC8gMjU2O1xuICB9XG4gIG1heFgoaSkge1xuICAgIHJldHVybiAodGhpcy4jY29vcmRzW2kgKiA0ICsgMl0gKyAxKSAvIDI1NjtcbiAgfVxuICBtYXhZKGkpIHtcbiAgICByZXR1cm4gKHRoaXMuI2Nvb3Jkc1tpICogNCArIDNdICsgMSkgLyAyNTY7XG4gIH1cbn1cbmNvbnN0IGVuc3VyZURlYnVnTWV0YWRhdGEgPSAobWFwLCBrZXkpID0+IHtcbiAgaWYgKCFtYXApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhbHVlID0ge1xuICAgICAgZGVwZW5kZW5jaWVzOiBuZXcgU2V0KCksXG4gICAgICBpc1JlbmRlcmluZ09wZXJhdGlvbjogZmFsc2VcbiAgICB9O1xuICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIENhbnZhc0RlcGVuZGVuY3lUcmFja2VyIHtcbiAgI3NpbXBsZSA9IHtcbiAgICBfX3Byb3RvX186IG51bGxcbiAgfTtcbiAgI2luY3JlbWVudGFsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB0cmFuc2Zvcm06IFtdLFxuICAgIG1vdmVUZXh0OiBbXSxcbiAgICBzYW1lTGluZVRleHQ6IFtdLFxuICAgIFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF06IFtdXG4gIH07XG4gICNuYW1lZERlcGVuZGVuY2llcyA9IG5ldyBNYXAoKTtcbiAgI3NhdmVzU3RhY2sgPSBbXTtcbiAgI21hcmtlZENvbnRlbnRTdGFjayA9IFtdO1xuICAjYmFzZVRyYW5zZm9ybVN0YWNrID0gW1sxLCAwLCAwLCAxLCAwLCAwXV07XG4gICNjbGlwQm94ID0gWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuICAjcGVuZGluZ0JCb3ggPSBuZXcgRmxvYXQ2NEFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICNwZW5kaW5nQkJveElkeCA9IC0xO1xuICAjcGVuZGluZ0RlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgI29wZXJhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICNmb250QkJveFRydXN0d29ydGh5ID0gbmV3IE1hcCgpO1xuICAjY2FudmFzV2lkdGg7XG4gICNjYW52YXNIZWlnaHQ7XG4gICNiYm94ZXNDb29yZHM7XG4gICNiYm94ZXM7XG4gICNkZWJ1Z01ldGFkYXRhO1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIG9wZXJhdGlvbnNDb3VudCwgcmVjb3JkRGVidWdNZXRhZGF0YSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdGhpcy4jY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB0aGlzLiNpbml0aWFsaXplQkJveGVzKG9wZXJhdGlvbnNDb3VudCk7XG4gICAgaWYgKHJlY29yZERlYnVnTWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuI2RlYnVnTWV0YWRhdGEgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGdyb3dPcGVyYXRpb25zQ291bnQob3BlcmF0aW9uc0NvdW50KSB7XG4gICAgaWYgKG9wZXJhdGlvbnNDb3VudCA+PSB0aGlzLiNiYm94ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNpbml0aWFsaXplQkJveGVzKG9wZXJhdGlvbnNDb3VudCwgdGhpcy4jYmJveGVzKTtcbiAgICB9XG4gIH1cbiAgI2luaXRpYWxpemVCQm94ZXMob3BlcmF0aW9uc0NvdW50LCBvbGRCQm94ZXMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3BlcmF0aW9uc0NvdW50ICogNCk7XG4gICAgdGhpcy4jYmJveGVzQ29vcmRzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy4jYmJveGVzID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgaWYgKG9sZEJCb3hlcyAmJiBvbGRCQm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy4jYmJveGVzLnNldChvbGRCQm94ZXMpO1xuICAgICAgdGhpcy4jYmJveGVzLmZpbGwoRU1QVFlfQkJPWCwgb2xkQkJveGVzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2Jib3hlcy5maWxsKEVNUFRZX0JCT1gpO1xuICAgIH1cbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNzaW1wbGVcbiAgICB9O1xuICAgIHRoaXMuI2luY3JlbWVudGFsID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbCxcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLnRyYW5zZm9ybVxuICAgICAgfSxcbiAgICAgIG1vdmVUZXh0OiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwubW92ZVRleHRcbiAgICAgIH0sXG4gICAgICBzYW1lTGluZVRleHQ6IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC5zYW1lTGluZVRleHRcbiAgICAgIH0sXG4gICAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWxbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiNjbGlwQm94ID0ge1xuICAgICAgX19wcm90b19fOiB0aGlzLiNjbGlwQm94XG4gICAgfTtcbiAgICB0aGlzLiNzYXZlc1N0YWNrLnB1c2gob3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNzaW1wbGUpO1xuICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuI3NpbXBsZSA9IHByZXZpb3VzO1xuICAgIHRoaXMuI2luY3JlbWVudGFsID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI2luY3JlbWVudGFsKTtcbiAgICB0aGlzLiNjbGlwQm94ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI2NsaXBCb3gpO1xuICAgIGNvbnN0IGxhc3RTYXZlID0gdGhpcy4jc2F2ZXNTdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdFNhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5zdXJlRGVidWdNZXRhZGF0YSh0aGlzLiNkZWJ1Z01ldGFkYXRhLCBvcElkeCk/LmRlcGVuZGVuY2llcy5hZGQobGFzdFNhdmUpO1xuICAgICAgdGhpcy4jYmJveGVzW29wSWR4XSA9IHRoaXMuI2Jib3hlc1tsYXN0U2F2ZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZW5NYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jc2F2ZXNTdGFjay5wdXNoKGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0T3Blbk1hcmtlcigpIHtcbiAgICBpZiAodGhpcy4jc2F2ZXNTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jc2F2ZXNTdGFjay5hdCgtMSk7XG4gIH1cbiAgcmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpIHtcbiAgICBjb25zdCBsYXN0U2F2ZSA9IHRoaXMuI3NhdmVzU3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RTYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuc3VyZURlYnVnTWV0YWRhdGEodGhpcy4jZGVidWdNZXRhZGF0YSwgb3BJZHgpPy5kZXBlbmRlbmNpZXMuYWRkKGxhc3RTYXZlKTtcbiAgICAgIHRoaXMuI2Jib3hlc1tvcElkeF0gPSB0aGlzLiNiYm94ZXNbbGFzdFNhdmVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2sucHVzaChvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIGNvbnN0IGxhc3RTYXZlID0gdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0U2F2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIG9wSWR4KT8uZGVwZW5kZW5jaWVzLmFkZChsYXN0U2F2ZSk7XG4gICAgICB0aGlzLiNiYm94ZXNbb3BJZHhdID0gdGhpcy4jYmJveGVzW2xhc3RTYXZlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaEJhc2VUcmFuc2Zvcm0oY3R4KSB7XG4gICAgdGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2goVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvcEJhc2VUcmFuc2Zvcm0oKSB7XG4gICAgaWYgKHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlW25hbWVdID0gaWR4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNpbmNyZW1lbnRhbFtuYW1lXS5wdXNoKGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jaW5jcmVtZW50YWxbbmFtZV0ubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuc2V0KG5hbWUsIGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChuYW1lLCBkZXBOYW1lLCBmYWxsYmFja0lkeCkge1xuICAgIHRoaXMuI3NpbXBsZVtuYW1lXSA9IHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLmdldChkZXBOYW1lKSA/PyBmYWxsYmFja0lkeDtcbiAgfVxuICByZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIGlkeCkge1xuICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMLCBpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuI3NpbXBsZSkge1xuICAgICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgdGhpcy4jc2ltcGxlW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwsIGRlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0QkJveChpZHgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ0JCb3hJZHggIT09IGlkeCkge1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hJZHggPSBpZHg7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IEluZmluaXR5O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gLUluZmluaXR5O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENsaXBCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICBjb25zdCBjbGlwQm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIGNsaXBCb3gpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuI2NsaXBCb3gsIGNsaXBCb3gpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMF0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgICB0aGlzLiNjbGlwQm94WzFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICAgICAgdGhpcy4jY2xpcEJveFsyXSA9IGludGVyc2VjdGlvblsyXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbM10gPSBpbnRlcnNlY3Rpb25bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMF0gPSB0aGlzLiNjbGlwQm94WzFdID0gSW5maW5pdHk7XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gdGhpcy4jY2xpcEJveFszXSA9IC1JbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQkJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGNvbnN0IGNsaXBCb3ggPSB0aGlzLiNjbGlwQm94O1xuICAgIGlmIChjbGlwQm94WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGlmIChjbGlwQm94WzBdID09PSAtSW5maW5pdHkpIHtcbiAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIHRoaXMuI3BlbmRpbmdCQm94KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goW21pblgsIG1pblksIG1heFgsIG1heFldLCB0cmFuc2Zvcm0sIGJib3gpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gTWF0aC5taW4odGhpcy4jcGVuZGluZ0JCb3hbMF0sIE1hdGgubWF4KGJib3hbMF0sIGNsaXBCb3hbMF0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsxXSA9IE1hdGgubWluKHRoaXMuI3BlbmRpbmdCQm94WzFdLCBNYXRoLm1heChiYm94WzFdLCBjbGlwQm94WzFdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSBNYXRoLm1heCh0aGlzLiNwZW5kaW5nQkJveFsyXSwgTWF0aC5taW4oYmJveFsyXSwgY2xpcEJveFsyXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzNdID0gTWF0aC5tYXgodGhpcy4jcGVuZGluZ0JCb3hbM10sIE1hdGgubWluKGJib3hbM10sIGNsaXBCb3hbM10pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDaGFyYWN0ZXJCQm94KGlkeCwgY3R4LCBmb250LCBzY2FsZSA9IDEsIHggPSAwLCB5ID0gMCwgZ2V0TWVhc3VyZSkge1xuICAgIGNvbnN0IGZvbnRCQm94ID0gZm9udC5iYm94O1xuICAgIGxldCBpc0JCb3hUcnVzdHdvcnRoeTtcbiAgICBsZXQgY29tcHV0ZWRCQm94O1xuICAgIGlmIChmb250QkJveCkge1xuICAgICAgaXNCQm94VHJ1c3R3b3J0aHkgPSBmb250QkJveFsyXSAhPT0gZm9udEJCb3hbMF0gJiYgZm9udEJCb3hbM10gIT09IGZvbnRCQm94WzFdICYmIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuZ2V0KGZvbnQpO1xuICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5ICE9PSBmYWxzZSkge1xuICAgICAgICBjb21wdXRlZEJCb3ggPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZm9udEJCb3gsIGZvbnQuZm9udE1hdHJpeCwgY29tcHV0ZWRCQm94KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxIHx8IHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICAgIFV0aWwuc2NhbGVNaW5NYXgoW3NjYWxlLCAwLCAwLCAtc2NhbGUsIHgsIHldLCBjb21wdXRlZEJCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIGNvbXB1dGVkQkJveFswXSwgY29tcHV0ZWRCQm94WzJdLCBjb21wdXRlZEJCb3hbMV0sIGNvbXB1dGVkQkJveFszXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnZXRNZWFzdXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvcmRGdWxsUGFnZUJCb3goaWR4KTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZSA9IGdldE1lYXN1cmUoKTtcbiAgICBpZiAoZm9udEJCb3ggJiYgY29tcHV0ZWRCQm94ICYmIGlzQkJveFRydXN0d29ydGh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlzQkJveFRydXN0d29ydGh5ID0gY29tcHV0ZWRCQm94WzBdIDw9IHggLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94TGVmdCAmJiBjb21wdXRlZEJCb3hbMl0gPj0geCArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCAmJiBjb21wdXRlZEJCb3hbMV0gPD0geSAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgJiYgY29tcHV0ZWRCQm94WzNdID49IHkgKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICAgIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuc2V0KGZvbnQsIGlzQkJveFRydXN0d29ydGh5KTtcbiAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCBjb21wdXRlZEJCb3hbMF0sIGNvbXB1dGVkQkJveFsyXSwgY29tcHV0ZWRCQm94WzFdLCBjb21wdXRlZEJCb3hbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCB4IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQsIHggKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIHkgLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCB5ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuICB9XG4gIHJlY29yZEZ1bGxQYWdlQkJveChpZHgpIHtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IE1hdGgubWF4KDAsIHRoaXMuI2NsaXBCb3hbMF0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gTWF0aC5tYXgoMCwgdGhpcy4jY2xpcEJveFsxXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSBNYXRoLm1pbih0aGlzLiNjYW52YXNXaWR0aCwgdGhpcy4jY2xpcEJveFsyXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSBNYXRoLm1pbih0aGlzLiNjYW52YXNIZWlnaHQsIHRoaXMuI2NsaXBCb3hbM10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFNpbXBsZUluZGV4KGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpbXBsZVtkZXBlbmRlbmN5TmFtZV07XG4gIH1cbiAgcmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgY29uc3QgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXM7XG4gICAgY29uc3Qgc2ltcGxlID0gdGhpcy4jc2ltcGxlO1xuICAgIGNvbnN0IGluY3JlbWVudGFsID0gdGhpcy4jaW5jcmVtZW50YWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGRlcGVuZGVuY3lOYW1lcykge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy4jc2ltcGxlKSB7XG4gICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKHNpbXBsZVtuYW1lXSk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgaW4gaW5jcmVtZW50YWwpIHtcbiAgICAgICAgaW5jcmVtZW50YWxbbmFtZV0uZm9yRWFjaChwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCwgcGVuZGluZ0RlcGVuZGVuY2llcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGVwZW5kZW5jeShpZHgsIG5hbWUpIHtcbiAgICBpZiAodGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZCh0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5nZXQobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdKTtcbiAgICBpZiAodGhpcy4jZGVidWdNZXRhZGF0YSkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIGlkeCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgfSA9IG1ldGFkYXRhO1xuICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcyk7XG4gICAgICB0aGlzLiNzYXZlc1N0YWNrLmZvckVhY2goZGVwZW5kZW5jaWVzLmFkZCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIHRoaXMuI21hcmtlZENvbnRlbnRTdGFjay5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcyk7XG4gICAgICBkZXBlbmRlbmNpZXMuZGVsZXRlKGlkeCk7XG4gICAgICBtZXRhZGF0YS5pc1JlbmRlcmluZ09wZXJhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwZW5kaW5nQkJveElkeCA9PT0gaWR4KSB7XG4gICAgICBjb25zdCBtaW5YID0gZmxvb3IodGhpcy4jcGVuZGluZ0JCb3hbMF0gKiAyNTYgLyB0aGlzLiNjYW52YXNXaWR0aCk7XG4gICAgICBjb25zdCBtaW5ZID0gZmxvb3IodGhpcy4jcGVuZGluZ0JCb3hbMV0gKiAyNTYgLyB0aGlzLiNjYW52YXNIZWlnaHQpO1xuICAgICAgY29uc3QgbWF4WCA9IGNlaWwodGhpcy4jcGVuZGluZ0JCb3hbMl0gKiAyNTYgLyB0aGlzLiNjYW52YXNXaWR0aCk7XG4gICAgICBjb25zdCBtYXhZID0gY2VpbCh0aGlzLiNwZW5kaW5nQkJveFszXSAqIDI1NiAvIHRoaXMuI2NhbnZhc0hlaWdodCk7XG4gICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3JkcywgaWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgIGZvciAoY29uc3QgZGVwSWR4IG9mIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcElkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgZXhwYW5kQkJveCh0aGlzLiNiYm94ZXNDb29yZHMsIGRlcElkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2F2ZUlkeCBvZiB0aGlzLiNzYXZlc1N0YWNrKSB7XG4gICAgICAgIGlmIChzYXZlSWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3Jkcywgc2F2ZUlkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2F2ZUlkeCBvZiB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2spIHtcbiAgICAgICAgaWYgKHNhdmVJZHggIT09IGlkeCkge1xuICAgICAgICAgIGV4cGFuZEJCb3godGhpcy4jYmJveGVzQ29vcmRzLCBzYXZlSWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNob3dUZXh0T3BlcmF0aW9uKGlkeCwgcHJlc2VydmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlcHMgPSBBcnJheS5mcm9tKHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpO1xuICAgIHRoaXMucmVjb3JkT3BlcmF0aW9uKGlkeCwgcHJlc2VydmUpO1xuICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIsIGlkeCk7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgdGhpcy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIiwgZGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdCQm94SWR4ID09PSBpZHgpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gTWF0aC5tYXgodGhpcy4jY2xpcEJveFswXSwgdGhpcy4jcGVuZGluZ0JCb3hbMF0pO1xuICAgICAgdGhpcy4jY2xpcEJveFsxXSA9IE1hdGgubWF4KHRoaXMuI2NsaXBCb3hbMV0sIHRoaXMuI3BlbmRpbmdCQm94WzFdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSBNYXRoLm1pbih0aGlzLiNjbGlwQm94WzJdLCB0aGlzLiNwZW5kaW5nQkJveFsyXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzNdID0gTWF0aC5taW4odGhpcy4jY2xpcEJveFszXSwgdGhpcy4jcGVuZGluZ0JCb3hbM10pO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF90YWtlUGVuZGluZ0RlcGVuZGVuY2llcygpIHtcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICB9XG4gIF9leHRyYWN0T3BlcmF0aW9uKGlkeCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuI29wZXJhdGlvbnMuZ2V0KGlkeCk7XG4gICAgdGhpcy4jb3BlcmF0aW9ucy5kZWxldGUoaWR4KTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xuICB9XG4gIF9wdXNoUGVuZGluZ0RlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKGRlcCk7XG4gICAgfVxuICB9XG4gIHRha2UoKSB7XG4gICAgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5jbGVhcigpO1xuICAgIHJldHVybiBuZXcgQkJveFJlYWRlcih0aGlzLiNiYm94ZXMsIHRoaXMuI2Jib3hlc0Nvb3Jkcyk7XG4gIH1cbiAgdGFrZURlYnVnTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlYnVnTWV0YWRhdGE7XG4gIH1cbn1cbmNsYXNzIENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyIHtcbiAgI2RlcGVuZGVuY3lUcmFja2VyO1xuICAjb3BJZHg7XG4gICNpZ25vcmVCQm94ZXM7XG4gICNuZXN0aW5nTGV2ZWwgPSAwO1xuICAjc2F2ZXNMZXZlbCA9IDA7XG4gIGNvbnN0cnVjdG9yKGRlcGVuZGVuY3lUcmFja2VyLCBvcElkeCwgaWdub3JlQkJveGVzKSB7XG4gICAgaWYgKGRlcGVuZGVuY3lUcmFja2VyIGluc3RhbmNlb2YgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIgJiYgZGVwZW5kZW5jeVRyYWNrZXIuI2lnbm9yZUJCb3hlcyA9PT0gISFpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB9XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB0aGlzLiNvcElkeCA9IG9wSWR4O1xuICAgIHRoaXMuI2lnbm9yZUJCb3hlcyA9ICEhaWdub3JlQkJveGVzO1xuICB9XG4gIGdyb3dPcGVyYXRpb25zQ291bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIHRoaXMuI3NhdmVzTGV2ZWwrKztcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5zYXZlKHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXN0b3JlKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuI3NhdmVzTGV2ZWwgPiAwKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXN0b3JlKHRoaXMuI29wSWR4KTtcbiAgICAgIHRoaXMuI3NhdmVzTGV2ZWwtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3Blbk1hcmtlcihpZHgpIHtcbiAgICB0aGlzLiNuZXN0aW5nTGV2ZWwrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRPcGVuTWFya2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNuZXN0aW5nTGV2ZWwgPiAwID8gdGhpcy4jb3BJZHggOiB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5nZXRPcGVuTWFya2VyKCk7XG4gIH1cbiAgcmVjb3JkQ2xvc2VNYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jbmVzdGluZ0xldmVsLS07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2hCYXNlVHJhbnNmb3JtKGN0eCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnB1c2hCYXNlVHJhbnNmb3JtKGN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9wQmFzZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRTaW1wbGVEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREYXRhKG5hbWUsIGlkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGFGcm9tTmFtZWQobmFtZSwgZGVwTmFtZSwgZmFsbGJhY2tJZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkKG5hbWUsIGRlcE5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5pbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKG5hbWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEJCb3goaWR4KSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc2V0QkJveCh0aGlzLiNvcElkeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENsaXBCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2xpcEJveCh0aGlzLiNvcElkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQkJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRCQm94KHRoaXMuI29wSWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDaGFyYWN0ZXJCQm94KGlkeCwgY3R4LCBmb250LCBzY2FsZSwgeCwgeSwgZ2V0TWVhc3VyZSkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRDaGFyYWN0ZXJCQm94KHRoaXMuI29wSWR4LCBjdHgsIGZvbnQsIHNjYWxlLCB4LCB5LCBnZXRNZWFzdXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkRnVsbFBhZ2VCQm94KGlkeCkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdWxsUGFnZUJCb3godGhpcy4jb3BJZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5nZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSk7XG4gIH1cbiAgcmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRGVwZW5kZW5jaWVzKHRoaXMuI29wSWR4LCBkZXBlbmRlbmN5TmFtZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGVwZW5kZW5jeShpZHgsIG5hbWUpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmROYW1lZERlcGVuZGVuY3kodGhpcy4jb3BJZHgsIG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZXJhdGlvbihpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRPcGVyYXRpb24odGhpcy4jb3BJZHgsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNob3dUZXh0T3BlcmF0aW9uKGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZFNob3dUZXh0T3BlcmF0aW9uKHRoaXMuI29wSWR4LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihpZHgpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24odGhpcy4jb3BJZHgsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0YWtlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG4gIHRha2VEZWJ1Z01ldGFkYXRhKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG59XG5jb25zdCBEZXBlbmRlbmNpZXMgPSB7XG4gIHN0cm9rZTogW1wicGF0aFwiLCBcInRyYW5zZm9ybVwiLCBcImZpbHRlclwiLCBcInN0cm9rZUNvbG9yXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZGFzaFwiXSxcbiAgZmlsbDogW1wicGF0aFwiLCBcInRyYW5zZm9ybVwiLCBcImZpbHRlclwiLCBcImZpbGxDb2xvclwiLCBcImZpbGxBbHBoYVwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcIlNNYXNrXCJdLFxuICBpbWFnZVhPYmplY3Q6IFtcInRyYW5zZm9ybVwiLCBcIlNNYXNrXCIsIFwiZmlsdGVyXCIsIFwiZmlsbEFscGhhXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIl0sXG4gIHJhd0ZpbGxQYXRoOiBbXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJmaWxsQWxwaGFcIl0sXG4gIHNob3dUZXh0OiBbXCJ0cmFuc2Zvcm1cIiwgXCJsZWFkaW5nXCIsIFwiY2hhclNwYWNpbmdcIiwgXCJ3b3JkU3BhY2luZ1wiLCBcImhTY2FsZVwiLCBcInRleHRSaXNlXCIsIFwibW92ZVRleHRcIiwgXCJ0ZXh0TWF0cml4XCIsIFwiZm9udFwiLCBcImZvbnRPYmpcIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJ0ZXh0UmVuZGVyaW5nTW9kZVwiLCBcIlNNYXNrXCIsIFwiZmlsbEFscGhhXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJzYW1lTGluZVRleHRcIl0sXG4gIHRyYW5zZm9ybTogW1widHJhbnNmb3JtXCJdLFxuICB0cmFuc2Zvcm1BbmRGaWxsOiBbXCJ0cmFuc2Zvcm1cIiwgXCJmaWxsQ29sb3JcIl1cbn07XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3BhdHRlcm5faGVscGVyLmpzXG5cblxuXG5cblxuXG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYGdldFBhdHRlcm5gIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdHlwZSA9IElSWzFdO1xuICAgIHRoaXMuX2Jib3ggPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvclN0b3BzID0gSVJbM107XG4gICAgdGhpcy5fcDAgPSBJUls0XTtcbiAgICB0aGlzLl9wMSA9IElSWzVdO1xuICAgIHRoaXMuX3IwID0gSVJbNl07XG4gICAgdGhpcy5fcjEgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUdyYWRpZW50KGN0eCkge1xuICAgIGxldCBncmFkO1xuICAgIGlmICh0aGlzLl90eXBlID09PSBcImF4aWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gXCJyYWRpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3IwLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0sIHRoaXMuX3IxKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2xvclN0b3Agb2YgdGhpcy5fY29sb3JTdG9wcykge1xuICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wWzBdLCBjb2xvclN0b3BbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZDtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UgfHwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLkZJTEwpIHtcbiAgICAgIGNvbnN0IG93bmVyQkJveCA9IG93bmVyLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGFwcGx5Qm91bmRpbmdCb3godG1wQ3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9jcmVhdGVHcmFkaWVudCh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LmZpbGwoKTtcbiAgICAgIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgoaW52ZXJzZSk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gIGNvbnN0IGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgIGNvbG9ycyA9IGNvbnRleHQuY29sb3JzO1xuICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YSxcbiAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICBjb25zdCBjMnIgPSBjb2xvcnNbYzJdLFxuICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICBjb25zdCBjM3IgPSBjb2xvcnNbYzNdLFxuICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICBsZXQgeGEsIGNhciwgY2FnLCBjYWI7XG4gIGxldCB4YiwgY2JyLCBjYmcsIGNiYjtcbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgY29uc3QgayA9IHkgPCB5MSA/IDAgOiAoeTEgLSB5KSAvICh5MSAtIHkyKTtcbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcbiAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSAoeTIgLSB5KSAvICh5MiAtIHkzKTtcbiAgICAgIH1cbiAgICAgIHhhID0geDIgLSAoeDIgLSB4MykgKiBrO1xuICAgICAgY2FyID0gYzJyIC0gKGMyciAtIGMzcikgKiBrO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgY2FiID0gYzJiIC0gKGMyYiAtIGMzYikgKiBrO1xuICAgIH1cbiAgICBsZXQgaztcbiAgICBpZiAoeSA8IHkxKSB7XG4gICAgICBrID0gMDtcbiAgICB9IGVsc2UgaWYgKHkgPiB5Mykge1xuICAgICAgayA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSAoeTEgLSB5KSAvICh5MSAtIHkzKTtcbiAgICB9XG4gICAgeGIgPSB4MSAtICh4MSAtIHgzKSAqIGs7XG4gICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICBjYmIgPSBjMWIgLSAoYzFiIC0gYzNiKSAqIGs7XG4gICAgY29uc3QgeDFfID0gTWF0aC5yb3VuZChNYXRoLm1pbih4YSwgeGIpKTtcbiAgICBjb25zdCB4Ml8gPSBNYXRoLnJvdW5kKE1hdGgubWF4KHhhLCB4YikpO1xuICAgIGxldCBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9XG4gICAgICBieXRlc1tqKytdID0gY2FyIC0gKGNhciAtIGNicikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gMjU1O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcbiAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICBjb25zdCB2ZXJ0aWNlc1BlclJvdyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHBzLmxlbmd0aCAvIHZlcnRpY2VzUGVyUm93KSAtIDE7XG4gICAgICBjb25zdCBjb2xzID0gdmVydGljZXNQZXJSb3cgLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBsZXQgcSA9IGkgKiB2ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls2XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBkYXRhID0gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiYWNrZ3JvdW5kQ29sb3JbMF07XG4gICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICBieXRlc1tpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlndXJlIG9mIHRoaXMuX2ZpZ3VyZXMpIHtcbiAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIHNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgICBjb25zdCBbbWF0cml4U2NhbGVYLCBtYXRyaXhTY2FsZVldID0gc2NhbGU7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICAgIHNjYWxlWzBdICo9IG1hdHJpeFNjYWxlWDtcbiAgICAgIHNjYWxlWzFdICo9IG1hdHJpeFNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmNvbG9yID0gSVJbMV07XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIsIG9wSWR4KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmJveCxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhaW50VHlwZSxcbiAgICAgIHRpbGluZ1R5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIGNhbnZhc0dyYXBoaWNzRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4c3RlcCxcbiAgICAgIHlzdGVwXG4gICAgfSA9IHRoaXM7XG4gICAgeHN0ZXAgPSBNYXRoLmFicyh4c3RlcCk7XG4gICAgeXN0ZXAgPSBNYXRoLmFicyh5c3RlcCk7XG4gICAgaW5mbyhcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVggPSBtYXRyaXhTY2FsZVggKiBzY2FsZVswXTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWSA9IG1hdHJpeFNjYWxlWSAqIHNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLFxuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gZmFsc2UsXG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCwgb3BJZHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC1kaW14LnNjYWxlICogeDAsIC1kaW15LnNjYWxlICogeTApO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgwLCBkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICBncmFwaGljcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzdG9yZSgpO1xuICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHJlZHJhd0hvcml6b250YWxseSB8fCByZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAocmVkcmF3VmVydGljYWxseSkge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbXgyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgICAgY29uc3QgZGlteTIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICAgIGNvbnN0IHhTaXplID0gZGlteDIuc2l6ZTtcbiAgICAgIGNvbnN0IHlTaXplID0gZGlteTIuc2l6ZTtcbiAgICAgIGNvbnN0IHRtcENhbnZhczIgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuLXdvcmthcm91bmRcIiwgeFNpemUsIHlTaXplKTtcbiAgICAgIGNvbnN0IHRtcEN0eDIgPSB0bXBDYW52YXMyLmNvbnRleHQ7XG4gICAgICBjb25zdCBpaSA9IHJlZHJhd0hvcml6b250YWxseSA/IE1hdGguZmxvb3Iod2lkdGggLyB4c3RlcCkgOiAwO1xuICAgICAgY29uc3QgamogPSByZWRyYXdWZXJ0aWNhbGx5ID8gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RlcCkgOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaWk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBqajsgaisrKSB7XG4gICAgICAgICAgdG1wQ3R4Mi5kcmF3SW1hZ2UoaW1hZ2UsIHhTaXplICogaSwgeVNpemUgKiBqLCB4U2l6ZSwgeVNpemUsIDAsIDAsIHhTaXplLCB5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczogdG1wQ2FudmFzMi5jYW52YXMsXG4gICAgICAgIHNjYWxlWDogZGlteDIuc2NhbGUsXG4gICAgICAgIHNjYWxlWTogZGlteTIuc2NhbGUsXG4gICAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgICBvZmZzZXRZOiB5MFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgb2Zmc2V0WTogeTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbeDAsIHkwLCB4MSwgeTFdLCBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIGdyYXBoaWNzLmN1cnJlbnQubWluTWF4KTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZpbGxTdHlsZSxcbiAgICAgICAgICBzdHJva2VTdHlsZVxuICAgICAgICB9ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3VycmVudC5maWxsQ29sb3IgPSBmaWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlLCBvcElkeCkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lciwgb3BJZHgpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9pbWFnZV91dGlscy5qc1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zLmtpbmQpIHtcbiAgICBjYXNlIEltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShwYXJhbXMpO1xuICAgIGNhc2UgSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0UkdCVG9SR0JBKHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbm9uQmxhY2tDb2xvciA9IDB4ZmZmZmZmZmYsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1Bvc10gOiAyNTU7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIGRlc3RQb3MgPSAwLFxuICB3aWR0aCxcbiAgaGVpZ2h0XG59KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gd2lkdGggKiBoZWlnaHQgKiAzO1xuICBjb25zdCBsZW4zMiA9IGxlbiA+PiAyO1xuICBjb25zdCBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyLCBzcmNQb3MsIGxlbjMyKTtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxID4+PiAyNCB8IHMyIDw8IDggfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA+Pj4gMTYgfCBzMyA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzID4+PiA4IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSB8IHNyY1tqICsgMV0gPDwgOCB8IHNyY1tqICsgMl0gPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPDwgMjQgfCBzMiA+Pj4gOCB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyIDw8IDE2IHwgczMgPj4+IDE2IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPDwgOCB8IDB4ZmY7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmNQb3MgKyBsZW47IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gPDwgMjQgfCBzcmNbaiArIDFdIDw8IDE2IHwgc3JjW2ogKyAyXSA8PCA4IHwgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3M6IHNyY1BvcyArIGxlbixcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBncmF5VG9SR0JBKHNyYywgZGVzdCkge1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEwMCB8IDB4MDAwMDAwZmY7XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhcy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgRlVMTF9DSFVOS19IRUlHSFQgPSAxNjtcbmNvbnN0IFNDQUxFX01BVFJJWCA9IG5ldyBET01NYXRyaXgoKTtcbmNvbnN0IFhZID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbmNvbnN0IE1JTl9NQVhfSU5JVCA9IG5ldyBGbG9hdDMyQXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuICBjdHguX19vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXN0b3JlID0gY3R4LnJlc3RvcmU7XG4gIGN0eC5fX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGUgPSBjdHgudHJhbnNsYXRlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSA9IGN0eC5yZXNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxDbGlwID0gY3R4LmNsaXA7XG4gIGN0eC5fX29yaWdpbmFsTW92ZVRvID0gY3R4Lm1vdmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxMaW5lVG8gPSBjdHgubGluZVRvO1xuICBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG8gPSBjdHguYmV6aWVyQ3VydmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxSZWN0ID0gY3R4LnJlY3Q7XG4gIGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcbiAgY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGggPSBjdHguYmVnaW5QYXRoO1xuICBjdHguX3JlbW92ZU1pcnJvcmluZyA9ICgpID0+IHtcbiAgICBjdHguc2F2ZSA9IGN0eC5fX29yaWdpbmFsU2F2ZTtcbiAgICBjdHgucmVzdG9yZSA9IGN0eC5fX29yaWdpbmFsUmVzdG9yZTtcbiAgICBjdHgucm90YXRlID0gY3R4Ll9fb3JpZ2luYWxSb3RhdGU7XG4gICAgY3R4LnNjYWxlID0gY3R4Ll9fb3JpZ2luYWxTY2FsZTtcbiAgICBjdHgudHJhbnNsYXRlID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGU7XG4gICAgY3R4LnRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtO1xuICAgIGN0eC5jbGlwID0gY3R4Ll9fb3JpZ2luYWxDbGlwO1xuICAgIGN0eC5tb3ZlVG8gPSBjdHguX19vcmlnaW5hbE1vdmVUbztcbiAgICBjdHgubGluZVRvID0gY3R4Ll9fb3JpZ2luYWxMaW5lVG87XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG87XG4gICAgY3R4LnJlY3QgPSBjdHguX19vcmlnaW5hbFJlY3Q7XG4gICAgY3R4LmNsb3NlUGF0aCA9IGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoO1xuICAgIGN0eC5iZWdpblBhdGggPSBjdHguX19vcmlnaW5hbEJlZ2luUGF0aDtcbiAgICBkZWxldGUgY3R4Ll9yZW1vdmVNaXJyb3Jpbmc7XG4gIH07XG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgZGVzdEN0eC5jbGlwKHJ1bGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsaXAocnVsZSk7XG4gIH07XG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1vdmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgZGVzdEN0eC5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gIH07XG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgY3R4LmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmVnaW5QYXRoKCk7XG4gIH07XG59XG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBhbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgZm9udFNpemUgPSAwO1xuICBmb250U2l6ZVNjYWxlID0gMTtcbiAgdGV4dE1hdHJpeCA9IG51bGw7XG4gIHRleHRNYXRyaXhTY2FsZSA9IDE7XG4gIGZvbnRNYXRyaXggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgbGVhZGluZyA9IDA7XG4gIHggPSAwO1xuICB5ID0gMDtcbiAgbGluZVggPSAwO1xuICBsaW5lWSA9IDA7XG4gIGNoYXJTcGFjaW5nID0gMDtcbiAgd29yZFNwYWNpbmcgPSAwO1xuICB0ZXh0SFNjYWxlID0gMTtcbiAgdGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICB0ZXh0UmlzZSA9IDA7XG4gIGZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBzdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBwYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICBwYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIGZpbGxBbHBoYSA9IDE7XG4gIHN0cm9rZUFscGhhID0gMTtcbiAgbGluZVdpZHRoID0gMTtcbiAgYWN0aXZlU01hc2sgPSBudWxsO1xuICB0cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcHJlSW5pdCkge1xuICAgIHByZUluaXQ/Lih0aGlzKTtcbiAgICB0aGlzLmNsaXBCb3ggPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdGhpcy5taW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIGNsb25lLm1pbk1heCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIGdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLm1pbk1heC5zbGljZSgpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB1bnJlYWNoYWJsZShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IFhZWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IFhZWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pbk1heFswXSA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3guc2V0KGJveCwgMCk7XG4gICAgdGhpcy5taW5NYXguc2V0KE1JTl9NQVhfSU5JVCwgMCk7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgY29uc3QgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICBjb25zdCB3aGl0ZSA9IDB4ZmZmZmZmZmY7XG4gICAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICBjb25zdCBzcmNEaWZmID0gc3JjTGVuZ3RoIC0gc3JjUG9zO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgY29uc3Qga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICBsZXQgbWFzayA9IDA7XG4gICAgICAgIGxldCBzcmNCeXRlID0gMDtcbiAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEyOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDMyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxNiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoZGVzdFBvcyA8IGRlc3QzMkRhdGFMZW5ndGgpIHtcbiAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSBmdWxsQ2h1bmtzKSB7XG4gICAgICAgIHRoaXNDaHVua0hlaWdodCA9IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSBlbGVtc0luVGhpc0NodW5rOyBqLS07KSB7XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBpbWFnZSBraW5kOiAke2ltZ0RhdGEua2luZH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICBjdHguZHJhd0ltYWdlKGltZ0RhdGEuYml0bWFwLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgY29uc3QgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAoe1xuICAgICAgc3JjUG9zXG4gICAgfSA9IGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgICAgIHNyYyxcbiAgICAgIHNyY1BvcyxcbiAgICAgIGRlc3QsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogdGhpc0NodW5rSGVpZ2h0LFxuICAgICAgbm9uQmxhY2tDb2xvcjogMFxuICAgIH0pKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgfVxufVxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIl07XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvdXJjZUN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4KSB7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJcbiAgfSA9IGN0eDtcbiAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKE91dHB1dFNjYWxlLnBpeGVsUmF0aW8gKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gWFlbMF0gPD0gYWN0dWFsU2NhbGUgJiYgWFlbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycywgZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXIgPz8gbnVsbDtcbiAgfVxuICBnZXRPYmplY3Qob3BJZHgsIGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkTmFtZWREZXBlbmRlbmN5KG9wSWR4LCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi5nZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIsIG9wZXJhdGlvbnNGaWx0ZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkLCBmbkFyZ3M7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChzdGVwcGVyICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gc3RlcHBlci5uZXh0QnJlYWtQb2ludCkge1xuICAgICAgICBzdGVwcGVyLmJyZWFrSXQoaSwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcGVyYXRpb25zRmlsdGVyIHx8IG9wZXJhdGlvbnNGaWx0ZXIoaSkpIHtcbiAgICAgICAgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICAgIGZuQXJncyA9IGFyZ3NBcnJheVtpXSA/PyBudWxsO1xuICAgICAgICBpZiAoZm5JZCAhPT0gT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgICBpZiAoZm5BcmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGksIC4uLmZuQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgZm5BcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERhdGEoZGVwT2JqSWQsIGkpO1xuICAgICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICAgIGlmICghb2Jqc1Bvb2wuaGFzKGRlcE9iaklkKSkge1xuICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aCA/PyBpbWcuZGlzcGxheVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQgPz8gaW1nLmRpc3BsYXlIZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzLCBtaW5NYXgpO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IG1pbk1heDtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQobWF4WSAtIG1pblkpIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gbWluWDtcbiAgICBjb25zdCBvZmZzZXRZID0gbWluWTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpKTtcbiAgICAgIHNjYWxlZCA9IHNjYWxlZC5pbWc7XG4gICAgICBpZiAoY2FjaGUgJiYgaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHNjYWxlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBQYXRoVHlwZS5GSUxMLCBvcElkeCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgob3BJZHgsIHdpZHRoKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVXaWR0aFwiLCBvcElkeCk7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lQ2FwXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihvcElkeCwgc3R5bGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZUpvaW5cIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChvcElkeCwgbGltaXQpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibWl0ZXJMaW1pdFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2gob3BJZHgsIGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImRhc2hcIiwgb3BJZHgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChvcElkeCwgaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhvcElkeCwgZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShvcElkeCwgc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbihvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2gob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3Mob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQWxwaGFcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcIlNNYXNrXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbHRlclwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUob3BJZHgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLmNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgICBjb25zdCBsYXllck9mZnNldFggPSBsYXllckJveFswXTtcbiAgICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSBsYXllckJveFszXSAtIGxheWVyT2Zmc2V0WTtcbiAgICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyaWNDb21wb3NlU01hc2soc21hc2suY29udGV4dCwgbGF5ZXJDdHgsIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBzbWFzay5iYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICAgIGxldCBtYXNrQ2FudmFzID0gbWFza0N0eC5jYW52YXM7XG4gICAgbGV0IG1hc2tYID0gbGF5ZXJPZmZzZXRYIC0gbWFza09mZnNldFg7XG4gICAgbGV0IG1hc2tZID0gbGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFk7XG4gICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICBpZiAobWFza1ggPCAwIHx8IG1hc2tZIDwgMCB8fCBtYXNrWCArIHdpZHRoID4gbWFza0NhbnZhcy53aWR0aCB8fCBtYXNrWSArIGhlaWdodCA+IG1hc2tDYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0V4dGVuc2lvblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgLW1hc2tYLCAtbWFza1kpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICBtYXNrQ2FudmFzID0gY2FudmFzLmNhbnZhcztcbiAgICAgICAgbWFza1ggPSBtYXNrWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIG1hc2tDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjbGlwLnJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5jbGlwKGNsaXApO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXllckN0eC5zYXZlKCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGxheWVyQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAoc3VidHlwZSA9PT0gXCJBbHBoYVwiICYmIHRyYW5zZmVyTWFwKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkQWxwaGFGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH0gZWxzZSBpZiAoc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIpIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRMdW1pbm9zaXR5RmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LmNsaXAoY2xpcCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgIGxheWVyQ3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIHRyYW5zZm9ybShvcElkeCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcInRyYW5zZm9ybVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wSWR4LCBvcCwgZGF0YSwgbWluTWF4KSB7XG4gICAgbGV0IFtwYXRoXSA9IGRhdGE7XG4gICAgaWYgKCFtaW5NYXgpIHtcbiAgICAgIHBhdGggfHw9IGRhdGFbMF0gPSBuZXcgUGF0aDJEKCk7XG4gICAgICB0aGlzW29wXShvcElkeCwgcGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvdXRlckV4dHJhU2l6ZSA9IG9wID09PSBPUFMuc3Ryb2tlID8gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCAvIDIgOiAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBtaW5NYXhbMF0gLSBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzJdICsgb3V0ZXJFeHRyYVNpemUsIG1pbk1heFsxXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbM10gKyBvdXRlckV4dHJhU2l6ZSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBbXCJ0cmFuc2Zvcm1cIl0pO1xuICAgIH1cbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgUGF0aDJEKSkge1xuICAgICAgY29uc3QgcGF0aDJkID0gZGF0YVswXSA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7KSB7XG4gICAgICAgIHN3aXRjaCAocGF0aFtpKytdKSB7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLm1vdmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5tb3ZlVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmxpbmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5saW5lVG8ocGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmN1cnZlVG86XG4gICAgICAgICAgICBwYXRoMmQuYmV6aWVyQ3VydmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICBwYXRoMmQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgd2FybihgVW5yZWNvZ25pemVkIGRyYXdpbmcgcGF0aCBvcGVyYXRvcjogJHtwYXRoW2kgLSAxXX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aDJkO1xuICAgIH1cbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KG1pbk1heCwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICB0aGlzLl9wYXRoU3RhcnRJZHggPSBvcElkeDtcbiAgfVxuICBjbG9zZVBhdGgob3BJZHgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2Uob3BJZHgsIHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3Ryb2tlQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFLCBvcElkeCk7XG4gICAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKS5tdWx0aXBseVNlbGYoYmFzZVRyYW5zZm9ybSkpO1xuICAgICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCBmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UocGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnN0cm9rZSk7XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChQYXRoVHlwZS5TVFJPS0UsIGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgZmlsbChvcElkeCwgcGF0aCwgY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGxldCBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gZmlsbENvbG9yLmlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpID8gY3R4LmdldFRyYW5zZm9ybSgpIDogbnVsbDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgfVxuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpO1xuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJva2Uob3BJZHgsIHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlbmRQYXRoKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCk7XG4gIH1cbiAgcmF3RmlsbFBhdGgob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmN0eC5maWxsKHBhdGgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnJhd0ZpbGxQYXRoKS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIGNsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dChvcElkeCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZW5NYXJrZXIob3BJZHgpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICB9XG4gIGVuZFRleHQob3BJZHgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpKS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpO1xuICAgICAgfVxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpO1xuICAgIH1cbiAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNvbnN0IGludlRyYW5zZiA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSBvZiBwYXRocykge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pLnByZU11bHRpcGx5U2VsZihpbnZUcmFuc2YpLnRyYW5zbGF0ZSh4LCB5KS5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKSk7XG4gICAgICB9XG4gICAgICBjdHguY2xpcChuZXdQYXRoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJjaGFyU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ3b3JkU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUob3BJZHgsIHNjYWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImhTY2FsZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKG9wSWR4LCBsZWFkaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxlYWRpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChvcElkeCwgZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZm9udFwiLCBvcElkeCkucmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChcImZvbnRPYmpcIiwgZm9udFJlZk5hbWUsIG9wSWR4KTtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG9wSWR4LCBtb2RlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSZW5kZXJpbmdNb2RlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKG9wSWR4LCByaXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSaXNlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KG9wSWR4LCB4LCB5KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIikucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQob3BJZHgsIHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcob3BJZHgsIC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KG9wSWR4LCB4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KG9wSWR4LCBtYXRyaXgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dE1hdHJpeFwiLCBvcElkeCk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IG1hdHJpeDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QobWF0cml4WzBdLCBtYXRyaXhbMV0pO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKG9wSWR4KSB7XG4gICAgdGhpcy5tb3ZlVGV4dChvcElkeCwgMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcIm1vdmVUZXh0XCIsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoXCJsZWFkaW5nXCIpID8/IG9wSWR4KTtcbiAgfVxuICAjZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihjdXJyZW50VHJhbnNmb3JtKSk7XG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH1cbiAgcGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBjb25zdCBwYXR0ZXJuU3Ryb2tlID0gY3VycmVudC5wYXR0ZXJuU3Ryb2tlICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmICgoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkgJiYgIWZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgIHBhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAocGF0aCAmJiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCAtZm9udFNpemUpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250KTtcbiAgICAgIGxldCBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAocGF0dGVybkZpbGxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFBhdGggPSB0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5GaWxsVHJhbnNmb3JtKTtcbiAgICAgICAgICBjdHguZmlsbChzY2FsZWRQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSB8fD0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZFxuICAgICAgICAgIH0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICAgIGNvbnN0IGludlBhdHRlcm5UcmFuc2Zvcm0gPSBVdGlsLmludmVyc2VUcmFuc2Zvcm0ocGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmID0gVXRpbC50cmFuc2Zvcm0oW2EsIGIsIGMsIGQsIDAsIDBdLCBpbnZQYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZiwgWFkpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggKj0gTWF0aC5tYXgoWFlbMF0sIFhZWzFdKSAvIGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UodGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAvPSBmb250U2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc3Ryb2tlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8PSBbXTtcbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250LCBmb250U2l6ZSwgeCwgeSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQob3BJZHgsIGdseXBocykge1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnNob3dUZXh0KS5yZXNldEJCb3gob3BJZHgpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpLmluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICB0aGlzLnNob3dUeXBlM1RleHQob3BJZHgsIGdseXBocyk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdXJyZW50LnRleHRNYXRyaXgpIHtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm07XG4gICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSwgb3BJZHgpO1xuICAgICAgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZENoYXJzID0gY2hhcnMuam9pbihcIlwiKTtcbiAgICAgIGN0eC5maWxsVGV4dChqb2luZWRDaGFycywgMCwgMCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGpvaW5lZENoYXJzKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgLW1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIC1tZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkucmVjb3JkU2hvd1RleHRPcGVyYXRpb24ob3BJZHgpO1xuICAgICAgfVxuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBtZWFzdXJlO1xuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcik7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBtZWFzdXJlLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBtZWFzdXJlID8ge1xuICAgICAgICAgICAgYmJveDogbnVsbFxuICAgICAgICAgIH0gOiBmb250LCBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGUsIHNjYWxlZFgsIHNjYWxlZFksICgpID0+IG1lYXN1cmUgPz8gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KG9wSWR4LCBnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRyYWNrZXIgPSB0aGlzLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/IG5ldyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIDogbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHdhcm4oYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBbZ2x5cGgud2lkdGgsIDBdO1xuICAgICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCBmb250TWF0cml4KTtcbiAgICAgIHdpZHRoID0gcFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAoZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB9XG4gIH1cbiAgc2V0Q2hhcldpZHRoKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpLnJlY29yZENsaXBCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpO1xuICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IChjdHgsIHJlbmRlcmluZ09wSWR4KSA9PiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPyBuZXcgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIodGhpcy5kZXBlbmRlbmN5VHJhY2tlciwgcmVuZGVyaW5nT3BJZHgsIHRydWUpIDogbnVsbClcbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IFRpbGluZ1BhdHRlcm4oSVIsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKG9wSWR4LCAuLi5hcmdzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IHRydWU7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihvcElkeCwgLi4uYXJncykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKG9wSWR4LCBjb2xvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihvcElkeCwgY29sb3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvcElkeCwgb2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgb2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HLCBvcElkeCk7XG4gICAgY29uc3QgaW52ID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgbWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52LCBtaW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IG1pbk1heDtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRnVsbFBhZ2VCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm0pLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihvcElkeCwgbWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChiYm94LCB0aGlzLmJhc2VUcmFuc2Zvcm0sIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGJib3g7XG4gICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2xpcEJveChvcElkeCwgdGhpcy5jdHgsIHgwLCB4MSwgeTAsIHkxKTtcbiAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgIGluZm8oXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgIHdhcm4oXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KSwgYm91bmRzKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGxldCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBncm91cC5iYm94O1xuICAgIGNsaXAucmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoLmFkZFBhdGgoY2xpcCwgbmV3IERPTU1hdHJpeChncm91cC5tYXRyaXgpKTtcbiAgICAgIGNsaXAgPSBwYXRoO1xuICAgIH1cbiAgICBncm91cEN0eC5jbGlwKGNsaXApO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5zbWFzayB8fCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5pbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKFtcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdKS5wdXNoQmFzZVRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCwgZGlydHlCb3gpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24ob3BJZHgsIGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCBYWSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oWFlbMF0sIDAsIDAsIC1YWVsxXSwgMCwgaGVpZ2h0ICogWFlbMV0pO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KG9wSWR4LCBpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFggKyBtYXNrQ2FudmFzLndpZHRoLCBtYXNrLm9mZnNldFksIG1hc2sub2Zmc2V0WSArIG1hc2tDYW52YXMuaGVpZ2h0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KG9wSWR4LCBpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgdHJhbnNbNF0sIHRyYW5zWzVdKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCB0cmFuc1s0XSwgdHJhbnNbNF0gKyBtYXNrLmNhbnZhcy53aWR0aCwgdHJhbnNbNV0sIHRyYW5zWzVdICsgbWFzay5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKG9wSWR4LCBpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCwgb3BJZHgpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCB3aWR0aCwgMCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob3BJZHgsIG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Qob3BJZHgsIGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9wSWR4LCBvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KG9wSWR4LCBpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgIWltZ0RhdGEuZGF0YSkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKGltZ1RvUGFpbnQsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgd2lkdGgsIC1oZWlnaHQsIDApLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmltYWdlWE9iamVjdCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUob3BJZHgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIDEsIC0xLCAwKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKG9wSWR4KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIDAsIDEsIDAsIDEpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KG9wSWR4LCB0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKG9wSWR4LCB0YWcsIHByb3BlcnRpZXMpIHt9XG4gIGJlZ2luTWFya2VkQ29udGVudChvcElkeCwgdGFnKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyhvcElkeCwgdGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICBpZiAodGFnID09PSBcIk9DXCIpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uZW5kTWFya2VkQ29udGVudChvcElkeCk7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KG9wSWR4KSB7fVxuICBlbmRDb21wYXQob3BJZHgpIHt9XG4gIGNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCBjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAocGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKG9wSWR4KS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcFBhdGhcIiwgb3BJZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveCh0aGlzLmN1cnJlbnQuY2xpcEJveCk7XG4gIH1cbiAgZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgpIHtcbiAgICAgIGNvbnN0IG0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IDEgLyBNYXRoLm1pbihNYXRoLmFicyhtWzBdKSwgTWF0aC5hYnMobVszXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChtWzBdLCBtWzJdKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KG1bMV0sIG1bM10pO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gTWF0aC5tYXgobm9ybVgsIG5vcm1ZKSAvIGFic0RldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGg7XG4gIH1cbiAgZ2V0U2NhbGVGb3JTdHJva2luZygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkXG4gICAgICB9ID0gdGhpcy5jdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICBsZXQgc2NhbGVYLCBzY2FsZVk7XG4gICAgICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5hYnMoYSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5hYnMoZCk7XG4gICAgICAgIGlmIChub3JtWCA9PT0gbm9ybVkpIHtcbiAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSAxIC8gbm9ybVg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gc2NhbGVkTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAxIC8gbm9ybVg7XG4gICAgICAgICAgc2NhbGVZID0gMSAvIG5vcm1ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFhMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZWRZTGluZVdpZHRoID0gbm9ybVkgKiBsaW5lV2lkdGg7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVkWExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gc2NhbGVkWUxpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWUxpbmVXaWR0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKGEgKiBkIC0gYiAqIGMpO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZIC8gYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YIC8gYWJzRGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2VBcmVhID0gbGluZVdpZHRoICogYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZID4gYmFzZUFyZWEgPyBub3JtWSAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCA+IGJhc2VBcmVhID8gbm9ybVggLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSBzY2FsZVg7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzFdID0gc2NhbGVZO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZztcbiAgfVxuICByZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIHNhdmVSZXN0b3JlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4LFxuICAgICAgY3VycmVudDoge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gdGhpcy5nZXRTY2FsZUZvclN0cm9raW5nKCk7XG4gICAgaWYgKHNjYWxlWCA9PT0gc2NhbGVZKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gKGxpbmVXaWR0aCB8fCAxKSAqIHNjYWxlWDtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhc2hlcyA9IGN0eC5nZXRMaW5lRGFzaCgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBTQ0FMRV9NQVRSSVguYSA9IDEgLyBzY2FsZVg7XG4gICAgU0NBTEVfTUFUUklYLmQgPSAxIC8gc2NhbGVZO1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIFNDQUxFX01BVFJJWCk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBjdHguc3Ryb2tlKG5ld1BhdGgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZW50VmlzaWJsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mb3IgKGNvbnN0IG9wIGluIE9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW09QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL29iai1iaW4tdHJhbnNmb3JtLmpzXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIENzc0ZvbnRJbmZvIHtcbiAgI2J1ZmZlcjtcbiAgI3ZpZXc7XG4gICNkZWNvZGVyO1xuICBzdGF0aWMgc3RyaW5ncyA9IFtcImZvbnRGYW1pbHlcIiwgXCJmb250V2VpZ2h0XCIsIFwiaXRhbGljQW5nbGVcIl07XG4gIHN0YXRpYyB3cml0ZShpbmZvKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmdzID0ge307XG4gICAgbGV0IHN0cmluZ3NMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBDc3NGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoaW5mb1twcm9wXSk7XG4gICAgICBlbmNvZGVkU3RyaW5nc1twcm9wXSA9IGVuY29kZWQ7XG4gICAgICBzdHJpbmdzTGVuZ3RoICs9IDQgKyBlbmNvZGVkLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0cmluZ3NMZW5ndGgpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgQ3NzRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZWRTdHJpbmdzW3Byb3BdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBkYXRhLnNldChlbmNvZGVkLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgbGVuZ3RoO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJDc3NGb250SW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93XCIpO1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy4jYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyKTtcbiAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIH1cbiAgI3JlYWRTdHJpbmcoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBDc3NGb250SW5mby5zdHJpbmdzLmxlbmd0aCwgXCJJbnZhbGlkIHN0cmluZyBpbmRleFwiKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpICsgNDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpKTtcbiAgfVxuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygwKTtcbiAgfVxuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygxKTtcbiAgfVxuICBnZXQgaXRhbGljQW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMik7XG4gIH1cbn1cbmNsYXNzIFN5c3RlbUZvbnRJbmZvIHtcbiAgI2J1ZmZlcjtcbiAgI3ZpZXc7XG4gICNkZWNvZGVyO1xuICBzdGF0aWMgc3RyaW5ncyA9IFtcImNzc1wiLCBcImxvYWRlZE5hbWVcIiwgXCJiYXNlRm9udE5hbWVcIiwgXCJzcmNcIl07XG4gIHN0YXRpYyB3cml0ZShpbmZvKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmdzID0ge307XG4gICAgbGV0IHN0cmluZ3NMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBTeXN0ZW1Gb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoaW5mb1twcm9wXSk7XG4gICAgICBlbmNvZGVkU3RyaW5nc1twcm9wXSA9IGVuY29kZWQ7XG4gICAgICBzdHJpbmdzTGVuZ3RoICs9IDQgKyBlbmNvZGVkLmxlbmd0aDtcbiAgICB9XG4gICAgc3RyaW5nc0xlbmd0aCArPSA0O1xuICAgIGxldCBlbmNvZGVkU3R5bGVTdHlsZSxcbiAgICAgIGVuY29kZWRTdHlsZVdlaWdodCxcbiAgICAgIGxlbmd0aEVzdGltYXRlID0gMSArIHN0cmluZ3NMZW5ndGg7XG4gICAgaWYgKGluZm8uc3R5bGUpIHtcbiAgICAgIGVuY29kZWRTdHlsZVN0eWxlID0gZW5jb2Rlci5lbmNvZGUoaW5mby5zdHlsZS5zdHlsZSk7XG4gICAgICBlbmNvZGVkU3R5bGVXZWlnaHQgPSBlbmNvZGVyLmVuY29kZShpbmZvLnN0eWxlLndlaWdodCk7XG4gICAgICBsZW5ndGhFc3RpbWF0ZSArPSA0ICsgZW5jb2RlZFN0eWxlU3R5bGUubGVuZ3RoICsgNCArIGVuY29kZWRTdHlsZVdlaWdodC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGhFc3RpbWF0ZSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGluZm8uZ3Vlc3NGYWxsYmFjayA/IDEgOiAwKTtcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHN0cmluZ3NMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBTeXN0ZW1Gb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlZFN0cmluZ3NbcHJvcF07XG4gICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgIHN0cmluZ3NMZW5ndGggKz0gNCArIGxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCAtIHN0cmluZ3NMZW5ndGggLSA0LCBzdHJpbmdzTGVuZ3RoKTtcbiAgICBpZiAoaW5mby5zdHlsZSkge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBlbmNvZGVkU3R5bGVTdHlsZS5sZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZFN0eWxlU3R5bGUsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBlbmNvZGVkU3R5bGVTdHlsZS5sZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGVuY29kZWRTdHlsZVdlaWdodC5sZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZFN0eWxlV2VpZ2h0LCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgZW5jb2RlZFN0eWxlV2VpZ2h0Lmxlbmd0aDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA8PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJTdWJzdGl0aW9uSW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93XCIpO1xuICAgIHJldHVybiBidWZmZXIudHJhbnNmZXJUb0ZpeGVkTGVuZ3RoKG9mZnNldCk7XG4gIH1cbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy4jYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyKTtcbiAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIH1cbiAgZ2V0IGd1ZXNzRmFsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI3ZpZXcuZ2V0VWludDgoMCkgIT09IDA7XG4gIH1cbiAgI3JlYWRTdHJpbmcoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBTeXN0ZW1Gb250SW5mby5zdHJpbmdzLmxlbmd0aCwgXCJJbnZhbGlkIHN0cmluZyBpbmRleFwiKTtcbiAgICBsZXQgb2Zmc2V0ID0gNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpICsgNDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpKTtcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDApO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDEpO1xuICB9XG4gIGdldCBiYXNlRm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMik7XG4gIH1cbiAgZ2V0IHNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygzKTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgbGV0IG9mZnNldCA9IDE7XG4gICAgb2Zmc2V0ICs9IDQgKyB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHN0eWxlTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgc3R5bGVMZW5ndGgpKTtcbiAgICBvZmZzZXQgKz0gNCArIHN0eWxlTGVuZ3RoO1xuICAgIGNvbnN0IHdlaWdodExlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3Qgd2VpZ2h0ID0gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCB3ZWlnaHRMZW5ndGgpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGUsXG4gICAgICB3ZWlnaHRcbiAgICB9O1xuICB9XG59XG5jbGFzcyBGb250SW5mbyB7XG4gIHN0YXRpYyBib29scyA9IFtcImJsYWNrXCIsIFwiYm9sZFwiLCBcImRpc2FibGVGb250RmFjZVwiLCBcImZvbnRFeHRyYVByb3BlcnRpZXNcIiwgXCJpc0ludmFsaWRQREZqc0ZvbnRcIiwgXCJpc1R5cGUzRm9udFwiLCBcIml0YWxpY1wiLCBcIm1pc3NpbmdGaWxlXCIsIFwicmVtZWFzdXJlXCIsIFwidmVydGljYWxcIl07XG4gIHN0YXRpYyBudW1iZXJzID0gW1wiYXNjZW50XCIsIFwiZGVmYXVsdFdpZHRoXCIsIFwiZGVzY2VudFwiXTtcbiAgc3RhdGljIHN0cmluZ3MgPSBbXCJmYWxsYmFja05hbWVcIiwgXCJsb2FkZWROYW1lXCIsIFwibWltZXR5cGVcIiwgXCJuYW1lXCJdO1xuICBzdGF0aWMgI09GRlNFVF9OVU1CRVJTID0gTWF0aC5jZWlsKHRoaXMuYm9vbHMubGVuZ3RoICogMiAvIDgpO1xuICBzdGF0aWMgI09GRlNFVF9CQk9YID0gdGhpcy4jT0ZGU0VUX05VTUJFUlMgKyB0aGlzLm51bWJlcnMubGVuZ3RoICogODtcbiAgc3RhdGljICNPRkZTRVRfRk9OVF9NQVRSSVggPSB0aGlzLiNPRkZTRVRfQkJPWCArIDEgKyAyICogNDtcbiAgc3RhdGljICNPRkZTRVRfREVGQVVMVF9WTUVUUklDUyA9IHRoaXMuI09GRlNFVF9GT05UX01BVFJJWCArIDEgKyA4ICogNjtcbiAgc3RhdGljICNPRkZTRVRfU1RSSU5HUyA9IHRoaXMuI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTICsgMSArIDIgKiAzO1xuICAjYnVmZmVyO1xuICAjZGVjb2RlcjtcbiAgI3ZpZXc7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIGV4dHJhXG4gIH0pIHtcbiAgICB0aGlzLiNidWZmZXIgPSBkYXRhO1xuICAgIHRoaXMuI2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlcik7XG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGV4dHJhKTtcbiAgICB9XG4gIH1cbiAgI3JlYWRCb29sZWFuKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgRm9udEluZm8uYm9vbHMubGVuZ3RoLCBcIkludmFsaWQgYm9vbGVhbiBpbmRleFwiKTtcbiAgICBjb25zdCBieXRlT2Zmc2V0ID0gTWF0aC5mbG9vcihpbmRleCAvIDQpO1xuICAgIGNvbnN0IGJpdE9mZnNldCA9IGluZGV4ICogMiAlIDg7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+IGJpdE9mZnNldCAmIDB4MDM7XG4gICAgcmV0dXJuIHZhbHVlID09PSAweDAwID8gdW5kZWZpbmVkIDogdmFsdWUgPT09IDB4MDI7XG4gIH1cbiAgZ2V0IGJsYWNrKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbigwKTtcbiAgfVxuICBnZXQgYm9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMSk7XG4gIH1cbiAgZ2V0IGRpc2FibGVGb250RmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMik7XG4gIH1cbiAgZ2V0IGZvbnRFeHRyYVByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDMpO1xuICB9XG4gIGdldCBpc0ludmFsaWRQREZqc0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDQpO1xuICB9XG4gIGdldCBpc1R5cGUzRm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNSk7XG4gIH1cbiAgZ2V0IGl0YWxpYygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNik7XG4gIH1cbiAgZ2V0IG1pc3NpbmdGaWxlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig3KTtcbiAgfVxuICBnZXQgcmVtZWFzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig4KTtcbiAgfVxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDkpO1xuICB9XG4gICNyZWFkTnVtYmVyKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgRm9udEluZm8ubnVtYmVycy5sZW5ndGgsIFwiSW52YWxpZCBudW1iZXIgaW5kZXhcIik7XG4gICAgcmV0dXJuIHRoaXMuI3ZpZXcuZ2V0RmxvYXQ2NChGb250SW5mby4jT0ZGU0VUX05VTUJFUlMgKyBpbmRleCAqIDgpO1xuICB9XG4gIGdldCBhc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWROdW1iZXIoMCk7XG4gIH1cbiAgZ2V0IGRlZmF1bHRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZE51bWJlcigxKTtcbiAgfVxuICBnZXQgZGVzY2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZE51bWJlcigyKTtcbiAgfVxuICBnZXQgYmJveCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9CQk9YO1xuICAgIGNvbnN0IG51bUNvb3JkcyA9IHRoaXMuI3ZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBpZiAobnVtQ29vcmRzID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTtcbiAgICBjb25zdCBiYm94ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGJib3gucHVzaCh0aGlzLiN2aWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuICAgIHJldHVybiBiYm94O1xuICB9XG4gIGdldCBmb250TWF0cml4KCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX0ZPTlRfTUFUUklYO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IHRoaXMuI3ZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBpZiAobnVtUG9pbnRzID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTtcbiAgICBjb25zdCBmb250TWF0cml4ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGZvbnRNYXRyaXgucHVzaCh0aGlzLiN2aWV3LmdldEZsb2F0NjQob2Zmc2V0LCB0cnVlKSk7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIGZvbnRNYXRyaXg7XG4gIH1cbiAgZ2V0IGRlZmF1bHRWTWV0cmljcygpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTO1xuICAgIGNvbnN0IG51bU1ldHJpY3MgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KG9mZnNldCk7XG4gICAgaWYgKG51bU1ldHJpY3MgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9mZnNldCArPSAxO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBkZWZhdWx0Vk1ldHJpY3MucHVzaCh0aGlzLiN2aWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Vk1ldHJpY3M7XG4gIH1cbiAgI3JlYWRTdHJpbmcoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBGb250SW5mby5zdHJpbmdzLmxlbmd0aCwgXCJJbnZhbGlkIHN0cmluZyBpbmRleFwiKTtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTICsgNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpICsgNDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBzdHJpbmdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBzdHJpbmdEYXRhLnNldChuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCkpO1xuICAgIHJldHVybiB0aGlzLiNkZWNvZGVyLmRlY29kZShzdHJpbmdEYXRhKTtcbiAgfVxuICBnZXQgZmFsbGJhY2tOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDApO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDEpO1xuICB9XG4gIGdldCBtaW1ldHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygyKTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygzKTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzeXN0ZW1Gb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBjc3NGb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBjc3NGb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCk7XG4gIH1cbiAgY2xlYXJEYXRhKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1M7XG4gICAgY29uc3Qgc3RyaW5nc0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN5c3RlbUZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGNzc0ZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIGNzc0ZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKTtcbiAgICBkYXRhLmZpbGwoMCk7XG4gICAgdGhpcy4jdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgfVxuICBnZXQgY3NzRm9udEluZm8oKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUztcbiAgICBjb25zdCBzdHJpbmdzTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN0cmluZ3NMZW5ndGg7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3lzdGVtRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgY3NzRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGlmIChjc3NGb250SW5mb0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNzc0ZvbnRJbmZvRGF0YSA9IG5ldyBVaW50OEFycmF5KGNzc0ZvbnRJbmZvTGVuZ3RoKTtcbiAgICBjc3NGb250SW5mb0RhdGEuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgY3NzRm9udEluZm9MZW5ndGgpKTtcbiAgICByZXR1cm4gbmV3IENzc0ZvbnRJbmZvKGNzc0ZvbnRJbmZvRGF0YS5idWZmZXIpO1xuICB9XG4gIGdldCBzeXN0ZW1Gb250SW5mbygpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgaWYgKHN5c3RlbUZvbnRJbmZvTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9EYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3lzdGVtRm9udEluZm9MZW5ndGgpO1xuICAgIHN5c3RlbUZvbnRJbmZvRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBzeXN0ZW1Gb250SW5mb0xlbmd0aCkpO1xuICAgIHJldHVybiBuZXcgU3lzdGVtRm9udEluZm8oc3lzdGVtRm9udEluZm9EYXRhLmJ1ZmZlcik7XG4gIH1cbiAgc3RhdGljIHdyaXRlKGZvbnQpIHtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0J1ZmZlciA9IGZvbnQuc3lzdGVtRm9udEluZm8gPyBTeXN0ZW1Gb250SW5mby53cml0ZShmb250LnN5c3RlbUZvbnRJbmZvKSA6IG51bGw7XG4gICAgY29uc3QgY3NzRm9udEluZm9CdWZmZXIgPSBmb250LmNzc0ZvbnRJbmZvID8gQ3NzRm9udEluZm8ud3JpdGUoZm9udC5jc3NGb250SW5mbykgOiBudWxsO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5ncyA9IHt9O1xuICAgIGxldCBzdHJpbmdzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgZW5jb2RlZFN0cmluZ3NbcHJvcF0gPSBlbmNvZGVyLmVuY29kZShmb250W3Byb3BdKTtcbiAgICAgIHN0cmluZ3NMZW5ndGggKz0gNCArIGVuY29kZWRTdHJpbmdzW3Byb3BdLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoRXN0aW1hdGUgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MgKyA0ICsgc3RyaW5nc0xlbmd0aCArIDQgKyAoc3lzdGVtRm9udEluZm9CdWZmZXIgPyBzeXN0ZW1Gb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoIDogMCkgKyA0ICsgKGNzc0ZvbnRJbmZvQnVmZmVyID8gY3NzRm9udEluZm9CdWZmZXIuYnl0ZUxlbmd0aCA6IDApICsgNCArIChmb250LmRhdGEgPyBmb250LmRhdGEubGVuZ3RoIDogMCk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aEVzdGltYXRlKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbnVtQm9vbHMgPSBGb250SW5mby5ib29scy5sZW5ndGg7XG4gICAgbGV0IGJvb2xCeXRlID0gMCxcbiAgICAgIGJvb2xCaXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQm9vbHM7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBmb250W0ZvbnRJbmZvLmJvb2xzW2ldXTtcbiAgICAgIGNvbnN0IGJpdHMgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMHgwMCA6IHZhbHVlID8gMHgwMiA6IDB4MDE7XG4gICAgICBib29sQnl0ZSB8PSBiaXRzIDw8IGJvb2xCaXQ7XG4gICAgICBib29sQml0ICs9IDI7XG4gICAgICBpZiAoYm9vbEJpdCA9PT0gOCB8fCBpID09PSBudW1Cb29scyAtIDEpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgYm9vbEJ5dGUpO1xuICAgICAgICBib29sQnl0ZSA9IDA7XG4gICAgICAgIGJvb2xCaXQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX05VTUJFUlMsIFwiRm9udEluZm8ud3JpdGU6IEJvb2xlYW4gcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIEZvbnRJbmZvLm51bWJlcnMpIHtcbiAgICAgIHZpZXcuc2V0RmxvYXQ2NChvZmZzZXQsIGZvbnRbcHJvcF0pO1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfQkJPWCwgXCJGb250SW5mby53cml0ZTogTnVtYmVyIHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIGlmIChmb250LmJib3gpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDQpO1xuICAgICAgZm9yIChjb25zdCBjb29yZCBvZiBmb250LmJib3gpIHtcbiAgICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQsIGNvb3JkLCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDApO1xuICAgICAgb2Zmc2V0ICs9IDIgKiA0O1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX0ZPTlRfTUFUUklYLCBcIkZvbnRJbmZvLndyaXRlOiBCQm94IHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIGlmIChmb250LmZvbnRNYXRyaXgpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDYpO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBmb250LmZvbnRNYXRyaXgpIHtcbiAgICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCwgcG9pbnQsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMCk7XG4gICAgICBvZmZzZXQgKz0gOCAqIDY7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfREVGQVVMVF9WTUVUUklDUywgXCJGb250SW5mby53cml0ZTogRm9udE1hdHJpeCBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICBpZiAoZm9udC5kZWZhdWx0Vk1ldHJpY3MpIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDEpO1xuICAgICAgZm9yIChjb25zdCBtZXRyaWMgb2YgZm9udC5kZWZhdWx0Vk1ldHJpY3MpIHtcbiAgICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQsIG1ldHJpYywgdHJ1ZSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAwKTtcbiAgICAgIG9mZnNldCArPSAzICogMjtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTLCBcIkZvbnRJbmZvLndyaXRlOiBEZWZhdWx0Vk1ldHJpY3MgcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgdmlldy5zZXRVaW50MzIoRm9udEluZm8uI09GRlNFVF9TVFJJTkdTLCAwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZWRTdHJpbmdzW3Byb3BdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBkYXRhLnNldChlbmNvZGVkLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgbGVuZ3RoO1xuICAgIH1cbiAgICB2aWV3LnNldFVpbnQzMihGb250SW5mby4jT0ZGU0VUX1NUUklOR1MsIG9mZnNldCAtIEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUyAtIDQpO1xuICAgIGlmICghc3lzdGVtRm9udEluZm9CdWZmZXIpIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gc3lzdGVtRm9udEluZm9CdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGFzc2VydChvZmZzZXQgKyA0ICsgbGVuZ3RoIDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIkZvbnRJbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3cgYXQgc3lzdGVtRm9udEluZm9cIik7XG4gICAgICBkYXRhLnNldChuZXcgVWludDhBcnJheShzeXN0ZW1Gb250SW5mb0J1ZmZlciksIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmICghY3NzRm9udEluZm9CdWZmZXIpIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gY3NzRm9udEluZm9CdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGFzc2VydChvZmZzZXQgKyA0ICsgbGVuZ3RoIDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIkZvbnRJbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3cgYXQgY3NzRm9udEluZm9cIik7XG4gICAgICBkYXRhLnNldChuZXcgVWludDhBcnJheShjc3NGb250SW5mb0J1ZmZlciksIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIGlmIChmb250LmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGZvbnQuZGF0YS5sZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZm9udC5kYXRhLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgZm9udC5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA8PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJGb250SW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93XCIpO1xuICAgIHJldHVybiBidWZmZXIudHJhbnNmZXJUb0ZpeGVkTGVuZ3RoKG9mZnNldCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd29ya2VyX29wdGlvbnMuanNcbmNsYXNzIEdsb2JhbFdvcmtlck9wdGlvbnMge1xuICBzdGF0aWMgI3BvcnQgPSBudWxsO1xuICBzdGF0aWMgI3NyYyA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgd29ya2VyUG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclBvcnQodmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBXb3JrZXIpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyUG9ydGAgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3BvcnQgPSB2YWw7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NyYztcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclNyYyh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyU3JjYCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3JjID0gdmFsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L21ldGFkYXRhLmpzXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvb3B0aW9uYWxfY29udGVudF9jb25maWcuanNcblxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjaXNEaXNwbGF5ID0gZmFsc2U7XG4gICNpc1ByaW50ID0gZmFsc2U7XG4gICN1c2VyU2V0ID0gZmFsc2U7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IocmVuZGVyaW5nSW50ZW50LCB7XG4gICAgbmFtZSxcbiAgICBpbnRlbnQsXG4gICAgdXNhZ2UsXG4gICAgcmJHcm91cHNcbiAgfSkge1xuICAgIHRoaXMuI2lzRGlzcGxheSA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSk7XG4gICAgdGhpcy4jaXNQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMucmJHcm91cHMgPSByYkdyb3VwcztcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jdXNlclNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwcmludCxcbiAgICAgIHZpZXdcbiAgICB9ID0gdGhpcy51c2FnZTtcbiAgICBpZiAodGhpcy4jaXNEaXNwbGF5KSB7XG4gICAgICByZXR1cm4gdmlldz8udmlld1N0YXRlICE9PSBcIk9GRlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNQcmludCkge1xuICAgICAgcmV0dXJuIHByaW50Py5wcmludFN0YXRlICE9PSBcIk9GRlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSwgdXNlclNldCA9IGZhbHNlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgdW5yZWFjaGFibGUoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN1c2VyU2V0ID0gdXNlclNldDtcbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0ludGVudCA9IHJlbmRlcmluZ0ludGVudDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKHJlbmRlcmluZ0ludGVudCwgZ3JvdXApKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGluZm8oXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2FybihgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybihgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUsIHByZXNlcnZlUkIgPSB0cnVlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGlkKTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlUkIgJiYgdmlzaWJsZSAmJiBncm91cC5yYkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcmJHcm91cCBvZiBncm91cC5yYkdyb3Vwcykge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgcmJHcm91cCkge1xuICAgICAgICAgIGlmIChvdGhlcklkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhpcy4jZ3JvdXBzLmdldChvdGhlcklkKT8uX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgc2V0T0NHU3RhdGUoe1xuICAgIHN0YXRlLFxuICAgIHByZXNlcnZlUkJcbiAgfSkge1xuICAgIGxldCBvcGVyYXRvcjtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbSkge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgb3BlcmF0b3IgPSBlbGVtO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW0pO1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIHRydWUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIGZhbHNlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCAhZ3JvdXAudmlzaWJsZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SGFzaCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkR2V0SGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2g7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZ3JvdXBdIG9mIHRoaXMuI2dyb3Vwcykge1xuICAgICAgaGFzaC51cGRhdGUoYCR7aWR9OiR7Z3JvdXAudmlzaWJsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBoYXNoLmhleGRpZ2VzdCgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZW50cmllcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RyYW5zcG9ydF9zdHJlYW0uanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3IocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCB7XG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0pIHtcbiAgICBhc3NlcnQocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGgsXG4gICAgICBpbml0aWFsRGF0YSxcbiAgICAgIHByb2dyZXNzaXZlRG9uZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lXG4gICAgfSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0KGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBpc1BkZkZpbGUoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY29udGVudF9kaXNwb3NpdGlvbi5qc1xuXG5cblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmtfdXRpbHMuanNcblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhpc0h0dHAsIGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBpZiAoIWlzSHR0cCB8fCAhaHR0cEhlYWRlcnMgfHwgdHlwZW9mIGh0dHBIZWFkZXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWwgPSBodHRwSGVhZGVyc1trZXldO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlT3JpZ2luKHVybCkge1xuICByZXR1cm4gVVJMLnBhcnNlKHVybCk/Lm9yaWdpbiA/PyBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICByZXNwb25zZUhlYWRlcnMsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksIDEwKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5zdWdnZXN0ZWRMZW5ndGggPSBsZW5ndGg7XG4gIGlmIChsZW5ndGggPD0gMiAqIHJhbmdlQ2h1bmtTaXplKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLmFsbG93UmFuZ2VSZXF1ZXN0cyA9IHRydWU7XG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycykge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKGlzUGRmRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdXJsKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzLCBzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSAyMDAgfHwgc3RhdHVzID09PSAyMDY7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZldGNoX3N0cmVhbS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB3YXJuKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgc3RyZWFtLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHN0cmVhbS5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHtzdHJlYW0uX3Jlc3BvbnNlT3JpZ2lufVwiLmApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29yay5qc1xuXG5cblxuXG5cblxuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaHR0cEhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBodHRwSGVhZGVycyk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuaGVhZGVycykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgYXNzZXJ0KGFyZ3Mub25FcnJvciwgXCJFeHBlY3RlZCBgb25FcnJvcmAgY2FsbGJhY2sgdG8gYmUgcHJvdmlkZWQuXCIpO1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgTWlzc2luZyBvciBpbnZhbGlkIFwiQ29udGVudC1SYW5nZVwiIGhlYWRlci5gKTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcigwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UpO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdCh7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHJJZCA9IHRoaXMuX2Z1bGxSZXF1ZXN0SWQ7XG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihmdWxsUmVxdWVzdFhoci5yZXNwb25zZVVSTCk7XG4gICAgY29uc3QgcmF3UmVzcG9uc2VIZWFkZXJzID0gZnVsbFJlcXVlc3RYaHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMocmF3UmVzcG9uc2VIZWFkZXJzID8gcmF3UmVzcG9uc2VIZWFkZXJzLnRyaW1TdGFydCgpLnJlcGxhY2UoL1teXFxTIF0rJC8sIFwiXCIpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoeCA9PiB7XG4gICAgICBjb25zdCBba2V5LCAuLi52YWxdID0geC5zcGxpdChcIjogXCIpO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbC5qb2luKFwiOiBcIildO1xuICAgIH0pIDogW10pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4odGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKHRoaXMuX3JlcXVlc3RJZCk/LnJlc3BvbnNlVVJMKTtcbiAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHRoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7dGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB0aGlzLl9vbkVycm9yKDApO1xuICAgIH1cbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA/Pz0gY3JlYXRlUmVzcG9uc2VFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3N0cmVhbS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgdXJsUmVnZXggPSAvXlthLXpdW2EtejAtOVxcLSsuXSs6L2k7XG5mdW5jdGlvbiBwYXJzZVVybE9yUGF0aChzb3VyY2VVcmwpIHtcbiAgaWYgKHVybFJlZ2V4LnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiBuZXcgVVJMKHNvdXJjZVVybCk7XG4gIH1cbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwidXJsXCIpO1xuICByZXR1cm4gbmV3IFVSTCh1cmwucGF0aFRvRmlsZVVSTChzb3VyY2VVcmwpKTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHBhcnNlVXJsT3JQYXRoKHNvdXJjZS51cmwpO1xuICAgIGFzc2VydCh0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiLCBcIlBERk5vZGVTdHJlYW0gb25seSBzdXBwb3J0cyBmaWxlOi8vIFVSTHMuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICAgIGZzLnByb21pc2VzLmxzdGF0KHRoaXMuX3VybCkudGhlbihzdGF0ID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCkpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGVycm9yID0gY3JlYXRlUmVzcG9uc2VFcnJvcigwLCB0aGlzLl91cmwuaHJlZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IEFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGRmX29iamVjdHMuanNcblxuY29uc3QgSU5JVElBTF9EQVRBID0gU3ltYm9sKFwiSU5JVElBTF9EQVRBXCIpO1xuY2xhc3MgUERGT2JqZWN0cyB7XG4gICNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgLi4uUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBkYXRhOiBJTklUSUFMX0RBVEFcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLnByb21pc2UudGhlbigoKSA9PiBjYWxsYmFjayhvYmouZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmRhdGEgIT09IElOSVRJQUxfREFUQTtcbiAgfVxuICBkZWxldGUob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBpZiAoZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgW29iaklkLCBkYXRhXTtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdGV4dF9sYXllci5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIHRoaXMuI2xhbmcpO1xuICAgIGxldCBsZWZ0LCB0b3A7XG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKlwiO1xuICAgIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgICBpZiAodGhpcy4jY29udGFpbmVyID09PSB0aGlzLiNyb290Q29udGFpbmVyKSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIGxlZnQgLyB0aGlzLiNwYWdlV2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGhpcy4jcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7bGVmdC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgfVxuICAgIGRpdlN0eWxlLmZvbnRTaXplID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHsoVGV4dExheWVyLiNtaW5Gb250U2l6ZSAqIGZvbnRIZWlnaHQpLnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5mb250U2l6ZSA9IGZvbnRIZWlnaHQ7XG4gICAgdGV4dERpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgICB0ZXh0RGl2LmRpciA9IGdlb20uZGlyO1xuICAgIGlmICh0aGlzLiNmb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gc3R5bGUuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUgfHwgZ2VvbS5mb250TmFtZTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkU2NhbGVUZXh0ID0gZmFsc2U7XG4gICAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChnZW9tLnN0ciAhPT0gXCIgXCIgJiYgZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcbiAgICAgIGlmIChhYnNTY2FsZVggIT09IGFic1NjYWxlWSAmJiBNYXRoLm1heChhYnNTY2FsZVgsIGFic1NjYWxlWSkgLyBNYXRoLm1pbihhYnNTY2FsZVgsIGFic1NjYWxlWSkgPiAxLjUpIHtcbiAgICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggPSBzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aDtcbiAgICB9XG4gICAgdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLmRpdiA9IHRleHREaXY7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXM7XG4gICAgdGhpcy4jbGF5b3V0KHRoaXMuI2xheW91dFRleHRQYXJhbXMpO1xuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzRU9MKSB7XG4gICAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKGJyKTtcbiAgICB9XG4gIH1cbiAgI2xheW91dChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgY3R4XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG4gICAgaWYgKFRleHRMYXllci4jbWluRm9udFNpemUgPiAxKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gVGV4dExheWVyLiNtaW5Gb250U2l6ZX0pYDtcbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FudmFzV2lkdGgsXG4gICAgICAgIGZvbnRTaXplXG4gICAgICB9ID0gcHJvcGVydGllcztcbiAgICAgIFRleHRMYXllci4jZW5zdXJlQ3R4Rm9udChjdHgsIGZvbnRTaXplICogdGhpcy4jc2NhbGUsIGZvbnRGYW1pbHkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y2FudmFzV2lkdGggKiB0aGlzLiNzY2FsZSAvIHdpZHRofSkgJHt0cmFuc2Zvcm19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHtwcm9wZXJ0aWVzLmFuZ2xlfWRlZykgJHt0cmFuc2Zvcm19YDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nVGV4dExheWVycy5zaXplID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgY2FudmFzXG4gICAgfSBvZiB0aGlzLiNjYW52YXNDb250ZXh0cy52YWx1ZXMoKSkge1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyAjZ2V0Q3R4KGxhbmcgPSBudWxsKSB7XG4gICAgbGV0IGN0eCA9IHRoaXMuI2NhbnZhc0NvbnRleHRzLmdldChsYW5nIHx8PSBcIlwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImhpZGRlbkNhbnZhc0VsZW1lbnRcIjtcbiAgICAgIGNhbnZhcy5sYW5nID0gbGFuZztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGNhbnZhcyk7XG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jY2FudmFzQ29udGV4dHMuc2V0KGxhbmcsIGN0eCk7XG4gICAgICB0aGlzLiNjYW52YXNDdHhGb250cy5zZXQoY3R4LCB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGZhbWlseTogXCJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVDdHhGb250KGN0eCwgc2l6ZSwgZmFtaWx5KSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy4jY2FudmFzQ3R4Rm9udHMuZ2V0KGN0eCk7XG4gICAgaWYgKHNpemUgPT09IGNhY2hlZC5zaXplICYmIGZhbWlseSA9PT0gY2FjaGVkLmZhbWlseSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguZm9udCA9IGAke3NpemV9cHggJHtmYW1pbHl9YDtcbiAgICBjYWNoZWQuc2l6ZSA9IHNpemU7XG4gICAgY2FjaGVkLmZhbWlseSA9IGZhbWlseTtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQoKSB7XG4gICAgaWYgKHRoaXMuI21pbkZvbnRTaXplICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gMTtcbiAgICBkaXYuc3R5bGUuZm9udFNpemUgPSBcIjFweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYudGV4dENvbnRlbnQgPSBcIlhcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIHRoaXMuI21pbkZvbnRTaXplID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICBkaXYucmVtb3ZlKCk7XG4gIH1cbiAgc3RhdGljICNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBjb25zdCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGxldCByYXRpbyA9IDAuODtcbiAgICBpZiAoYXNjZW50KSB7XG4gICAgICByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KSB7XG4gICAgICAgIHdhcm4oXCJFbmFibGUgdGhlIGBkb20udGV4dE1ldHJpY3MuZm9udEJvdW5kaW5nQm94LmVuYWJsZWRgIHByZWZlcmVuY2UgXCIgKyBcImluIGBhYm91dDpjb25maWdgIHRvIGltcHJvdmUgVGV4dExheWVyIHJlbmRlcmluZy5cIik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gc3R5bGUuYXNjZW50O1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5kZXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gMSArIHN0eWxlLmRlc2NlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiIHx8IHNyYyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHNyYyA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoc3JjKSkge1xuICAgIHNyYyA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBQREZEb2N1bWVudExvYWRpbmdUYXNrKCk7XG4gIGNvbnN0IHtcbiAgICBkb2NJZFxuICB9ID0gdGFzaztcbiAgY29uc3QgdXJsID0gc3JjLnVybCA/IGdldFVybFByb3Aoc3JjLnVybCkgOiBudWxsO1xuICBjb25zdCBkYXRhID0gc3JjLmRhdGEgPyBnZXREYXRhUHJvcChzcmMuZGF0YSkgOiBudWxsO1xuICBjb25zdCBodHRwSGVhZGVycyA9IHNyYy5odHRwSGVhZGVycyB8fCBudWxsO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBzcmMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlO1xuICBjb25zdCBwYXNzd29yZCA9IHNyYy5wYXNzd29yZCA/PyBudWxsO1xuICBjb25zdCByYW5nZVRyYW5zcG9ydCA9IHNyYy5yYW5nZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA/IHNyYy5yYW5nZSA6IG51bGw7XG4gIGNvbnN0IHJhbmdlQ2h1bmtTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMucmFuZ2VDaHVua1NpemUpICYmIHNyYy5yYW5nZUNodW5rU2l6ZSA+IDAgPyBzcmMucmFuZ2VDaHVua1NpemUgOiAyICoqIDE2O1xuICBsZXQgd29ya2VyID0gc3JjLndvcmtlciBpbnN0YW5jZW9mIFBERldvcmtlciA/IHNyYy53b3JrZXIgOiBudWxsO1xuICBjb25zdCB2ZXJib3NpdHkgPSBzcmMudmVyYm9zaXR5O1xuICBjb25zdCBkb2NCYXNlVXJsID0gdHlwZW9mIHNyYy5kb2NCYXNlVXJsID09PSBcInN0cmluZ1wiICYmICFpc0RhdGFTY2hlbWUoc3JjLmRvY0Jhc2VVcmwpID8gc3JjLmRvY0Jhc2VVcmwgOiBudWxsO1xuICBjb25zdCBjTWFwVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLmNNYXBVcmwpO1xuICBjb25zdCBjTWFwUGFja2VkID0gc3JjLmNNYXBQYWNrZWQgIT09IGZhbHNlO1xuICBjb25zdCBDTWFwUmVhZGVyRmFjdG9yeSA9IHNyYy5DTWFwUmVhZGVyRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgOiBET01DTWFwUmVhZGVyRmFjdG9yeSk7XG4gIGNvbnN0IGljY1VybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5pY2NVcmwpO1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLnN0YW5kYXJkRm9udERhdGFVcmwpO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgOiBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSk7XG4gIGNvbnN0IHdhc21VcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMud2FzbVVybCk7XG4gIGNvbnN0IFdhc21GYWN0b3J5ID0gc3JjLldhc21GYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVXYXNtRmFjdG9yeSA6IERPTVdhc21GYWN0b3J5KTtcbiAgY29uc3QgaWdub3JlRXJyb3JzID0gc3JjLnN0b3BBdEVycm9ycyAhPT0gdHJ1ZTtcbiAgY29uc3QgbWF4SW1hZ2VTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMubWF4SW1hZ2VTaXplKSAmJiBzcmMubWF4SW1hZ2VTaXplID4gLTEgPyBzcmMubWF4SW1hZ2VTaXplIDogLTE7XG4gIGNvbnN0IGlzRXZhbFN1cHBvcnRlZCA9IHNyYy5pc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICBjb25zdCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9IHR5cGVvZiBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPT09IFwiYm9vbGVhblwiID8gc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIDogIWlzTm9kZUpTO1xuICBjb25zdCBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA9IHR5cGVvZiBzcmMuaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPT09IFwiYm9vbGVhblwiID8gc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkIDogIWlzTm9kZUpTICYmICh1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCB8fCAhZ2xvYmFsVGhpcy5jaHJvbWUpO1xuICBjb25zdCBjYW52YXNNYXhBcmVhSW5CeXRlcyA9IE51bWJlci5pc0ludGVnZXIoc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzKSA/IHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcyA6IC0xO1xuICBjb25zdCBkaXNhYmxlRm9udEZhY2UgPSB0eXBlb2Ygc3JjLmRpc2FibGVGb250RmFjZSA9PT0gXCJib29sZWFuXCIgPyBzcmMuZGlzYWJsZUZvbnRGYWNlIDogaXNOb2RlSlM7XG4gIGNvbnN0IGZvbnRFeHRyYVByb3BlcnRpZXMgPSBzcmMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgY29uc3QgZW5hYmxlWGZhID0gc3JjLmVuYWJsZVhmYSA9PT0gdHJ1ZTtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHNyYy5vd25lckRvY3VtZW50IHx8IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IGRpc2FibGVSYW5nZSA9IHNyYy5kaXNhYmxlUmFuZ2UgPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVTdHJlYW0gPSBzcmMuZGlzYWJsZVN0cmVhbSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZUF1dG9GZXRjaCA9IHNyYy5kaXNhYmxlQXV0b0ZldGNoID09PSB0cnVlO1xuICBjb25zdCBwZGZCdWcgPSBzcmMucGRmQnVnID09PSB0cnVlO1xuICBjb25zdCBDYW52YXNGYWN0b3J5ID0gc3JjLkNhbnZhc0ZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUNhbnZhc0ZhY3RvcnkgOiBET01DYW52YXNGYWN0b3J5KTtcbiAgY29uc3QgRmlsdGVyRmFjdG9yeSA9IHNyYy5GaWx0ZXJGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVGaWx0ZXJGYWN0b3J5IDogRE9NRmlsdGVyRmFjdG9yeSk7XG4gIGNvbnN0IGVuYWJsZUhXQSA9IHNyYy5lbmFibGVIV0EgPT09IHRydWU7XG4gIGNvbnN0IHVzZVdhc20gPSBzcmMudXNlV2FzbSAhPT0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlVHJhbnNwb3J0ID8gcmFuZ2VUcmFuc3BvcnQubGVuZ3RoIDogc3JjLmxlbmd0aCA/PyBOYU47XG4gIGNvbnN0IHVzZVN5c3RlbUZvbnRzID0gdHlwZW9mIHNyYy51c2VTeXN0ZW1Gb250cyA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlU3lzdGVtRm9udHMgOiAhaXNOb2RlSlMgJiYgIWRpc2FibGVGb250RmFjZTtcbiAgY29uc3QgdXNlV29ya2VyRmV0Y2ggPSB0eXBlb2Ygc3JjLnVzZVdvcmtlckZldGNoID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VXb3JrZXJGZXRjaCA6ICEhKENNYXBSZWFkZXJGYWN0b3J5ID09PSBET01DTWFwUmVhZGVyRmFjdG9yeSAmJiBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9PT0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgV2FzbUZhY3RvcnkgPT09IERPTVdhc21GYWN0b3J5ICYmIGNNYXBVcmwgJiYgc3RhbmRhcmRGb250RGF0YVVybCAmJiB3YXNtVXJsICYmIGlzVmFsaWRGZXRjaFVybChjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHdhc21VcmwsIGRvY3VtZW50LmJhc2VVUkkpKTtcbiAgY29uc3Qgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgc2V0VmVyYm9zaXR5TGV2ZWwodmVyYm9zaXR5KTtcbiAgY29uc3QgdHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgICBjYW52YXNGYWN0b3J5OiBuZXcgQ2FudmFzRmFjdG9yeSh7XG4gICAgICBvd25lckRvY3VtZW50LFxuICAgICAgZW5hYmxlSFdBXG4gICAgfSksXG4gICAgZmlsdGVyRmFjdG9yeTogbmV3IEZpbHRlckZhY3Rvcnkoe1xuICAgICAgZG9jSWQsXG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSksXG4gICAgY01hcFJlYWRlckZhY3Rvcnk6IHVzZVdvcmtlckZldGNoID8gbnVsbCA6IG5ldyBDTWFwUmVhZGVyRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBjTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBjTWFwUGFja2VkXG4gICAgfSksXG4gICAgc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk6IHVzZVdvcmtlckZldGNoID8gbnVsbCA6IG5ldyBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBzdGFuZGFyZEZvbnREYXRhVXJsXG4gICAgfSksXG4gICAgd2FzbUZhY3Rvcnk6IHVzZVdvcmtlckZldGNoID8gbnVsbCA6IG5ldyBXYXNtRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiB3YXNtVXJsXG4gICAgfSlcbiAgfTtcbiAgaWYgKCF3b3JrZXIpIHtcbiAgICB3b3JrZXIgPSBQREZXb3JrZXIuY3JlYXRlKHtcbiAgICAgIHZlcmJvc2l0eSxcbiAgICAgIHBvcnQ6IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH0pO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuICBjb25zdCBkb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogXCI1LjQuMjk2XCIsXG4gICAgZGF0YSxcbiAgICBwYXNzd29yZCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGxlbmd0aCxcbiAgICBkb2NCYXNlVXJsLFxuICAgIGVuYWJsZVhmYSxcbiAgICBldmFsdWF0b3JPcHRpb25zOiB7XG4gICAgICBtYXhJbWFnZVNpemUsXG4gICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICBpZ25vcmVFcnJvcnMsXG4gICAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgICAgIGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICB1c2VXYXNtLFxuICAgICAgdXNlV29ya2VyRmV0Y2gsXG4gICAgICBjTWFwVXJsLFxuICAgICAgaWNjVXJsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybCxcbiAgICAgIHdhc21VcmxcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIHBkZkJ1ZyxcbiAgICBzdHlsZUVsZW1lbnQsXG4gICAgbG9hZGluZ1BhcmFtczoge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH1cbiAgfTtcbiAgd29ya2VyLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgfVxuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya2VySWRQcm9taXNlID0gd29ya2VyLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY1JlcXVlc3RcIiwgZG9jUGFyYW1zLCBkYXRhID8gW2RhdGEuYnVmZmVyXSA6IG51bGwpO1xuICAgIGxldCBuZXR3b3JrU3RyZWFtO1xuICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKHJhbmdlVHJhbnNwb3J0LCB7XG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQgLSBubyBgdXJsYCBwYXJhbWV0ZXIgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgTmV0d29ya1N0cmVhbSA9IGlzVmFsaWRGZXRjaFVybCh1cmwpID8gUERGRmV0Y2hTdHJlYW0gOiBpc05vZGVKUyA/IFBERk5vZGVTdHJlYW0gOiBQREZOZXR3b3JrU3RyZWFtO1xuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VySWRQcm9taXNlLnRoZW4od29ya2VySWQgPT4ge1xuICAgICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoZG9jSWQsIHdvcmtlcklkLCB3b3JrZXIucG9ydCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCB0YXNrLCBuZXR3b3JrU3RyZWFtLCB0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydEZhY3RvcnksIGVuYWJsZUhXQSk7XG4gICAgICB0YXNrLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiUmVhZHlcIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKHRhc2suX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgcmV0dXJuIHRhc2s7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIF9jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gIF90cmFuc3BvcnQgPSBudWxsO1xuICBfd29ya2VyID0gbnVsbDtcbiAgZG9jSWQgPSBgZCR7UERGRG9jdW1lbnRMb2FkaW5nVGFzay4jZG9jSWQrK31gO1xuICBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgb25QYXNzd29yZCA9IG51bGw7XG4gIG9uUHJvZ3Jlc3MgPSBudWxsO1xuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3kgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3k7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93b3JrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICB9XG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNwcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyA9IFtdO1xuICAjcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgI3JhbmdlTGlzdGVuZXJzID0gW107XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICB9XG4gIGFkZFJhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNyYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNwcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNwcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNyYW5nZUxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoYmVnaW4sIGNodW5rKTtcbiAgICB9XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRyYW5zcG9ydFJlYWR5KCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIFBERkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlXCIpO1xuICB9XG4gIGFib3J0KCkge31cbn1cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5O1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnNCeVR5cGUodHlwZXMsIHBhZ2VJbmRleGVzVG9Ta2lwKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYWNoZWRQYWdlTnVtYmVyKHJlZik7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG4gIGdldCBsb2FkaW5nVGFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEZpZWxkT2JqZWN0cygpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRDYWxjdWxhdGlvbk9yZGVySWRzKCk7XG4gIH1cbn1cbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IFN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlY29yZGVkQkJveGVzID0gbnVsbDtcbiAgfVxuICBnZXQgcGFnZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZGV4ICsgMTtcbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucmVmO1xuICB9XG4gIGdldCB1c2VyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udXNlclVuaXQ7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoe1xuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGUsXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXcsXG4gICAgICB1c2VyVW5pdDogdGhpcy51c2VyVW5pdCxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudFxuICAgIH0gPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUpTQWN0aW9ucyh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGFzeW5jIGdldFhmYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhPy5jaGlsZHJlblt0aGlzLl9wYWdlSW5kZXhdIHx8IG51bGw7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIGNhbnZhcyA9IGNhbnZhc0NvbnRleHQuY2FudmFzLFxuICAgIHZpZXdwb3J0LFxuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgYmFja2dyb3VuZCA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGwsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2UsXG4gICAgcmVjb3JkT3BlcmF0aW9ucyA9IGZhbHNlLFxuICAgIG9wZXJhdGlvbnNGaWx0ZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9zdGF0cz8udGltZShcIk92ZXJhbGxcIik7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleVxuICAgIH0gPSBpbnRlbnRBcmdzO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSB8fD0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlbnRQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY29yZEZvckRlYnVnZ2VyID0gQm9vbGVhbih0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCk7XG4gICAgY29uc3Qgc2hvdWxkUmVjb3JkT3BlcmF0aW9ucyA9ICF0aGlzLnJlY29yZGVkQkJveGVzICYmIChyZWNvcmRPcGVyYXRpb25zIHx8IHJlY29yZEZvckRlYnVnZ2VyKTtcbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgaWYgKHNob3VsZFJlY29yZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkZWRCQm94ZXMgPSBpbnRlcm5hbFJlbmRlclRhc2suZ2Z4Py5kZXBlbmRlbmN5VHJhY2tlci50YWtlKCk7XG4gICAgICAgIGlmIChyZWNvcmRlZEJCb3hlcykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbFJlbmRlclRhc2suc3RlcHBlcikge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLnN0ZXBwZXIuc2V0T3BlcmF0b3JCQm94ZXMocmVjb3JkZWRCQm94ZXMsIGludGVybmFsUmVuZGVyVGFzay5nZnguZGVwZW5kZW5jeVRyYWNrZXIudGFrZURlYnVnTWV0YWRhdGEoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGVkQkJveGVzID0gcmVjb3JkZWRCQm94ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLlN0YXRzPy5lbmFibGVkKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5TdGF0cy5hZGQodGhpcy5wYWdlTnVtYmVyLCB0aGlzLl9zdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgZGVwZW5kZW5jeVRyYWNrZXI6IHNob3VsZFJlY29yZE9wZXJhdGlvbnMgPyBuZXcgQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIoY2FudmFzLCBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGVuZ3RoLCByZWNvcmRGb3JEZWJ1Z2dlcikgOiBudWxsLFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIG9wZXJhdG9yTGlzdDogaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBjYW52YXNGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5LFxuICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhaW50ZW50UHJpbnQsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1ZyxcbiAgICAgIHBhZ2VDb2xvcnMsXG4gICAgICBlbmFibGVIV0E6IHRoaXMuX3RyYW5zcG9ydC5lbmFibGVIV0EsXG4gICAgICBvcGVyYXRpb25zRmlsdGVyXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgaWYgKCEob3B0aW9uYWxDb250ZW50Q29uZmlnLnJlbmRlcmluZ0ludGVudCAmIHJlbmRlcmluZ0ludGVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCB1c2UgdGhlIHNhbWUgYGludGVudGAtYXJndW1lbnQgd2hlbiBjYWxsaW5nIHRoZSBgUERGUGFnZVByb3h5LnJlbmRlcmAgXCIgKyBcImFuZCBgUERGRG9jdW1lbnRQcm94eS5nZXRPcHRpb25hbENvbnRlbnRDb25maWdgIG1ldGhvZHMuXCIpO1xuICAgICAgfVxuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG4gIGdldE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKG9wTGlzdFRhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiBYZmFUZXh0LnRleHRDb250ZW50KHhmYSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudC5sYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBsYW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IFN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cCgpIHtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdDbGVhbnVwIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgcmVuZGVyVGFza3MsXG4gICAgICBvcGVyYXRvckxpc3RcbiAgICB9IG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlbmRlclRhc2tzLnNpemUgPiAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIF9wdW1wT3BlcmF0b3JMaXN0KHtcbiAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgY2FjaGVLZXksXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgbW9kaWZpZWRJZHNcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0T3BlcmF0b3JMaXN0XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH0sIHRyYW5zZmVyKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBwdW1wKCk7XG4gIH1cbiAgX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnRTdGF0ZSxcbiAgICByZWFzb24sXG4gICAgZm9yY2UgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbikge1xuICAgICAgICBsZXQgZGVsYXkgPSBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQ7XG4gICAgICAgIGlmIChyZWFzb24uZXh0cmFEZWxheSA+IDAgJiYgcmVhc29uLmV4dHJhRGVsYXkgPCAxMDAwKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5jbGFzcyBQREZXb3JrZXIge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAjcG9ydCA9IG51bGw7XG4gICN3ZWJXb3JrZXIgPSBudWxsO1xuICBzdGF0aWMgI2Zha2VXb3JrZXJJZCA9IDA7XG4gIHN0YXRpYyAjaXNXb3JrZXJEaXNhYmxlZCA9IGZhbHNlO1xuICBzdGF0aWMgI3dvcmtlclBvcnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHRoaXMuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICAgIH1cbiAgICB0aGlzLl9pc1NhbWVPcmlnaW4gPSAoYmFzZVVybCwgb3RoZXJVcmwpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBVUkwucGFyc2UoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2U/Lm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICAgIH07XG4gICAgdGhpcy5fY3JlYXRlQ0ROV3JhcHBlciA9IHVybCA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYGF3YWl0IGltcG9ydChcIiR7dXJsfVwiKTtgO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuZnJvbVBvcnQgPSBwYXJhbXMgPT4ge1xuICAgICAgZGVwcmVjYXRlZChcImBQREZXb3JrZXIuZnJvbVBvcnRgIC0gcGxlYXNlIHVzZSBgUERGV29ya2VyLmNyZWF0ZWAgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIXBhcmFtcz8ucG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHBhcmFtcyk7XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSA9IG51bGwsXG4gICAgcG9ydCA9IG51bGwsXG4gICAgdmVyYm9zaXR5ID0gZ2V0VmVyYm9zaXR5TGV2ZWwoKVxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIGlmIChQREZXb3JrZXIuI3dvcmtlclBvcnRzLmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIFBERldvcmtlci4jd29ya2VyUG9ydHMuc2V0KHBvcnQsIHRoaXMpO1xuICAgICAgdGhpcy4jaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpbml0aWFsaXplKCk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcnQ7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLiNtZXNzYWdlSGFuZGxlcjtcbiAgfVxuICAjaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpIHtcbiAgICB0aGlzLiNwb3J0ID0gcG9ydDtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgcG9ydCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7fSk7XG4gICAgdGhpcy4jcmVzb2x2ZSgpO1xuICB9XG4gICNpbml0aWFsaXplKCkge1xuICAgIGlmIChQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgfHwgUERGV29ya2VyLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgd29ya2VyU3JjXG4gICAgfSA9IFBERldvcmtlcjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFQREZXb3JrZXIuX2lzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24sIHdvcmtlclNyYykpIHtcbiAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyLl9jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTcmMsIHtcbiAgICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgIGNvbnN0IHRlcm1pbmF0ZUVhcmx5ID0gKCkgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLiN3ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy4jcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgIH07XG4gICAgICBzZW5kVGVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICAjc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLiNwb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlci4jZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy4jd2ViV29ya2VyPy50ZXJtaW5hdGUoKTtcbiAgICB0aGlzLiN3ZWJXb3JrZXIgPSBudWxsO1xuICAgIFBERldvcmtlci4jd29ya2VyUG9ydHMuZGVsZXRlKHRoaXMuI3BvcnQpO1xuICAgIHRoaXMuI3BvcnQgPSBudWxsO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IHRoaXMuI3dvcmtlclBvcnRzLmdldChwYXJhbXM/LnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmNyZWF0ZSAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblwiICsgXCJQbGVhc2UgcmVtZW1iZXIgdG8gYXdhaXQgYFBERkRvY3VtZW50TG9hZGluZ1Rhc2suZGVzdHJveSgpYC1jYWxscy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkUG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpIHtcbiAgICAgIHJldHVybiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IGltcG9ydChcbiAgICAgIC8qd2VicGFja0lnbm9yZTogdHJ1ZSovXG4gICAgICAvKkB2aXRlLWlnbm9yZSovXG4gICAgICB0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlUmVmQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSwgZW5hYmxlSFdBKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBGb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkaW5nUGFyYW1zID0gcGFyYW1zLmxvYWRpbmdQYXJhbXM7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy53YXNtRmFjdG9yeSA9IGZhY3Rvcnkud2FzbUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgZGF0YSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IEFubm90YXRpb25TdG9yYWdlKCkpO1xuICB9XG4gIGdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLCBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCwgaXNFZGl0aW5nID0gZmFsc2UsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5ZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5XCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByaW50XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBpbnRlbnQ6ICR7aW50ZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgPyBwcmludEFubm90YXRpb25TdG9yYWdlIDogdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBzd2l0Y2ggKGFubm90YXRpb25Nb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkRJU0FCTEU6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0RJU0FCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfRk9STVM6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0ZPUk1TO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX1NUT1JBR0U7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgYW5ub3RhdGlvbk1vZGU6ICR7YW5ub3RhdGlvbk1vZGV9YCk7XG4gICAgfVxuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLklTX0VESVRJTkc7XG4gICAgfVxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZHM6IG1vZGlmaWVkSWRzLFxuICAgICAgaGFzaDogbW9kaWZpZWRJZHNIYXNoXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlLm1vZGlmaWVkSWRzO1xuICAgIGNvbnN0IGNhY2hlS2V5QnVmID0gW3JlbmRlcmluZ0ludGVudCwgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUuaGFzaCwgbW9kaWZpZWRJZHNIYXNoXTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5QnVmLmpvaW4oXCJfXCIpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHk/LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy4jcGFnZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVJlZkNhY2hlLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJhbm5vdGF0aW9uU3RvcmFnZVwiKSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSgpO1xuICAgICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgICAgIHRoaXMuX25ldHdvcmtTdHJlYW0/LmNhbmNlbEFsbFJlcXVlc3RzKG5ldyBBYm9ydEV4Y2VwdGlvbihcIldvcmtlciB3YXMgdGVybWluYXRlZC5cIikpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcj8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX2Z1bGxSZWFkZXIuaGVhZGVyc1JlYWR5O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfSA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBpZiAoIWlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFpc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJhbmdlUmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGV4ID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGV4KSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXggPT4ge1xuICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgICB0aHJvdyB3cmFwUmVhc29uKGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXguY29kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBkYXRhID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlN0YXJ0UmVuZGVyUGFnZVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuY2FjaGVLZXkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiY29tbW9ub2JqXCIsIChbaWQsIHR5cGUsIGV4cG9ydGVkRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgd2FybihgRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogJHtleHBvcnRlZEVycm9yfWApO1xuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZvbnREYXRhID0gbmV3IEZvbnRJbmZvKGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgY29uc3QgaW5zcGVjdEZvbnQgPSB0aGlzLl9wYXJhbXMucGRmQnVnICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZCA/IChmb250LCB1cmwpID0+IGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5mb250QWRkZWQoZm9udCwgdXJsKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBGb250RmFjZU9iamVjdChmb250RGF0YSwgaW5zcGVjdEZvbnQsIGV4cG9ydGVkRGF0YS5leHRyYSwgZXhwb3J0ZWREYXRhLmNoYXJQcm9jT3BlcmF0b3JMaXN0KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaCgoKSA9PiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvbnQuZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5jbGVhckRhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNvcHlMb2NhbEltYWdlXCI6XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW1hZ2VSZWZcbiAgICAgICAgICB9ID0gZXhwb3J0ZWREYXRhO1xuICAgICAgICAgIGFzc2VydChpbWFnZVJlZiwgXCJUaGUgaW1hZ2VSZWYgbXVzdCBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2VQcm94eSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgZGF0YV0gb2YgcGFnZVByb3h5Lm9ianMpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGE/LnJlZiAhPT0gaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGEuZGF0YUxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBzdHJ1Y3R1cmVkQ2xvbmUoZGF0YSkpO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5kYXRhTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlUHJveHkuX2ludGVudFN0YXRlcy5zaXplID09PSAwKSB7XG4gICAgICAgIGltYWdlRGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQmluYXJ5RGF0YVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBmYWN0b3J5ID0gdGhpc1tkYXRhLnR5cGVdO1xuICAgICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkYXRhLnR5cGV9IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBcXGB1c2VXb3JrZXJGZXRjaFxcYCBwYXJhbWV0ZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERhdGFcIiwgbnVsbCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25TdG9yYWdlLnNpemUgPD0gMCkge1xuICAgICAgd2FybihcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgaXNQdXJlWGZhOiAhIXRoaXMuX2h0bWxGb3JYZmEsXG4gICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgZmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGxcbiAgICB9LCB0cmFuc2ZlcikuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI3BhZ2VQcm9taXNlcy5nZXQocGFnZUluZGV4KTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSkudGhlbihwYWdlSW5mbyA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlSW5mby5yZWZTdHIpIHtcbiAgICAgICAgdGhpcy4jcGFnZVJlZkNhY2hlLnNldChwYWdlSW5mby5yZWZTdHIsIHBhZ2VOdW1iZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlSW5kZXggcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSW5kZXhcIiwge1xuICAgICAgbnVtOiByZWYubnVtLFxuICAgICAgZ2VuOiByZWYuZ2VuXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMocGFnZUluZGV4LCBpbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBpbnRlbnRcbiAgICB9KTtcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RmllbGRPYmplY3RzXCIpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJIYXNKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRDYWxjdWxhdGlvbk9yZGVySWRzXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXN0aW5hdGlvbiByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uXCIsIHtcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxheW91dFwiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTW9kZVwiLCBudWxsKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLCBudWxsKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wZW5BY3Rpb25cIiwgbnVsbCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QXR0YWNobWVudHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnNCeVR5cGUodHlwZXMsIHBhZ2VJbmRleGVzVG9Ta2lwKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNCeVR5cGVcIiwge1xuICAgICAgdHlwZXMsXG4gICAgICBwYWdlSW5kZXhlc1RvU2tpcFxuICAgIH0pO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiKS50aGVuKGRhdGEgPT4gbmV3IE9wdGlvbmFsQ29udGVudENvbmZpZyhkYXRhLCByZW5kZXJpbmdJbnRlbnQpKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQZXJtaXNzaW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBuYW1lID0gXCJHZXRNZXRhZGF0YVwiLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBudWxsKS50aGVuKHJlc3VsdHMgPT4gKHtcbiAgICAgIGluZm86IHJlc3VsdHNbMF0sXG4gICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBNZXRhZGF0YShyZXN1bHRzWzFdKSA6IG51bGwsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgIH0pKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gIH1cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZlN0ciA9IHJlZi5nZW4gPT09IDAgPyBgJHtyZWYubnVtfVJgIDogYCR7cmVmLm51bX1SJHtyZWYuZ2VufWA7XG4gICAgcmV0dXJuIHRoaXMuI3BhZ2VSZWZDYWNoZS5nZXQocmVmU3RyKSA/PyBudWxsO1xuICB9XG59XG5jbGFzcyBSZW5kZXJUYXNrIHtcbiAgI2ludGVybmFsUmVuZGVyVGFzayA9IG51bGw7XG4gIG9uQ29udGludWUgPSBudWxsO1xuICBvbkVycm9yID0gbnVsbDtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwobnVsbCwgZXh0cmFEZWxheSk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRlQW5ub3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRlQW5ub3RzXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3Q7XG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzaztcbiAgICByZXR1cm4gc2VwYXJhdGVBbm5vdHMuZm9ybSB8fCBzZXBhcmF0ZUFubm90cy5jYW52YXMgJiYgYW5ub3RhdGlvbkNhbnZhc01hcD8uc2l6ZSA+IDA7XG4gIH1cbn1cbmNsYXNzIEludGVybmFsUmVuZGVyVGFzayB7XG4gICNyQUYgPSBudWxsO1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhbGxiYWNrLFxuICAgIHBhcmFtcyxcbiAgICBvYmpzLFxuICAgIGNvbW1vbk9ianMsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBvcGVyYXRvckxpc3QsXG4gICAgcGFnZUluZGV4LFxuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeSxcbiAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICBwZGZCdWcgPSBmYWxzZSxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZSxcbiAgICBvcGVyYXRpb25zRmlsdGVyID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzO1xuICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSBwYXJhbXMuY2FudmFzID8gbnVsbCA6IHBhcmFtcy5jYW52YXNDb250ZXh0O1xuICAgIHRoaXMuX2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgICB0aGlzLl9kZXBlbmRlbmN5VHJhY2tlciA9IHBhcmFtcy5kZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB0aGlzLl9vcGVyYXRpb25zRmlsdGVyID0gb3BlcmF0aW9uc0ZpbHRlcjtcbiAgfVxuICBnZXQgY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gIH1cbiAgaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgfSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICBpZiAoSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBzYW1lIGNhbnZhcyBkdXJpbmcgbXVsdGlwbGUgcmVuZGVyKCkgb3BlcmF0aW9ucy4gXCIgKyBcIlVzZSBkaWZmZXJlbnQgY2FudmFzIG9yIGVuc3VyZSBwcmV2aW91cyBvcGVyYXRpb25zIHdlcmUgXCIgKyBcImNhbmNlbGxlZCBvciBjb21wbGV0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5hZGQodGhpcy5fY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgdGhpcy5zdGVwcGVyLmluaXQodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgYmFja2dyb3VuZCxcbiAgICAgIGRlcGVuZGVuY3lUcmFja2VyXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNhbnZhc0NvbnRleHQgPSB0aGlzLl9jYW52YXNDb250ZXh0IHx8IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy5fZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5nZnggPSBuZXcgQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycywgZGVwZW5kZW5jeVRyYWNrZXIpO1xuICAgIHRoaXMuZ2Z4LmJlZ2luRHJhd2luZyh7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9KTtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IDA7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaz8uKCk7XG4gIH1cbiAgY2FuY2VsKGVycm9yID0gbnVsbCwgZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdGhpcy5nZng/LmVuZERyYXdpbmcoKTtcbiAgICBpZiAodGhpcy4jckFGKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy4jckFGKTtcbiAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgfVxuICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgZXJyb3IgfHw9IG5ldyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oYFJlbmRlcmluZyBjYW5jZWxsZWQsIHBhZ2UgJHt0aGlzLl9wYWdlSW5kZXggKyAxfWAsIGV4dHJhRGVsYXkpO1xuICAgIHRoaXMuY2FsbGJhY2soZXJyb3IpO1xuICAgIHRoaXMudGFzay5vbkVycm9yPy4oZXJyb3IpO1xuICB9XG4gIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHkpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIHx8PSB0aGlzLl9jb250aW51ZUJvdW5kO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdmeC5kZXBlbmRlbmN5VHJhY2tlcj8uZ3Jvd09wZXJhdGlvbnNDb3VudCh0aGlzLm9wZXJhdG9yTGlzdC5mbkFycmF5Lmxlbmd0aCk7XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuI3JBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlciwgdGhpcy5fb3BlcmF0aW9uc0ZpbHRlcik7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gXCI1LjQuMjk2XCI7XG5jb25zdCBidWlsZCA9IFwiZjU2ZGM4NjAxXCI7XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb2xvcl9waWNrZXIuanNcblxuXG5cbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgI2J1dHRvbiA9IG51bGw7XG4gICNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAjZGVmYXVsdENvbG9yO1xuICAjZHJvcGRvd24gPSBudWxsO1xuICAjZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZXZlbnRCdXM7XG4gICNvcGVuRHJvcGRvd25BQyA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gZWRpdG9yPy5fdWlNYW5hZ2VyIHx8IHVpTWFuYWdlcjtcbiAgICB0aGlzLiNldmVudEJ1cyA9IHRoaXMuI3VpTWFuYWdlci5fZXZlbnRCdXM7XG4gICAgdGhpcy4jZGVmYXVsdENvbG9yID0gZWRpdG9yPy5jb2xvcj8udG9VcHBlckNhc2UoKSB8fCB0aGlzLiN1aU1hbmFnZXI/LmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgfHwgXCIjRkZGRjk4XCI7XG4gICAgQ29sb3JQaWNrZXIuI2wxMG5Db2xvciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBibHVlOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ibHVlXCIsXG4gICAgICBncmVlbjogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZ3JlZW5cIixcbiAgICAgIHBpbms6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXBpbmtcIixcbiAgICAgIHJlZDogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcmVkXCIsXG4gICAgICB5ZWxsb3c6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXllbGxvd1wiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiY29sb3JQaWNrZXJcIjtcbiAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJ1dHRvblwiKTtcbiAgICBidXR0b24uYXJpYUhhc1BvcHVwID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI29wZW5Ecm9wZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBzd2F0Y2ggPSB0aGlzLiNidXR0b25Td2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICBzd2F0Y2guYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5hcmlhT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIjtcbiAgICBkcm9wZG93bi5hcmlhTGFiZWxsZWRCeSA9IFwiaGlnaGxpZ2h0Q29sb3JQaWNrZXJMYWJlbFwiO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LmFyaWFNdWx0aVNlbGVjdGFibGUgPSBcImZhbHNlXCI7XG4gICAgZGl2LmFyaWFPcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWRyb3Bkb3duXCIpO1xuICAgIGlmICh0aGlzLiNlZGl0b3IpIHtcbiAgICAgIGRpdi5pZCA9IGAke3RoaXMuI2VkaXRvci5pZH1fY29sb3JwaWNrZXJfZHJvcGRvd25gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xvcl0gb2YgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgICAgYnV0dG9uLnJvbGUgPSBcIm9wdGlvblwiO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIiwgY29sb3IpO1xuICAgICAgYnV0dG9uLnRpdGxlID0gbmFtZTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltuYW1lXSk7XG4gICAgICBjb25zdCBzd2F0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGJ1dHRvbi5hcHBlbmQoc3dhdGNoKTtcbiAgICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgYnV0dG9uLmFyaWFTZWxlY3RlZCA9IGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2NvbG9yU2VsZWN0LmJpbmQodGhpcywgY29sb3IpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYXBwZW5kKGJ1dHRvbik7XG4gICAgfVxuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuI2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICB2YWx1ZTogY29sb3JcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKGNvbG9yKTtcbiAgfVxuICBfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpO1xuICB9XG4gIF9tb3ZlVG9OZXh0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jYnV0dG9uKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb1ByZXZpb3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jZHJvcGRvd24/LmZpcnN0Q2hpbGQgfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIGlmICh0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvQmVnaW5uaW5nKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24uZmlyc3RDaGlsZD8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24ubGFzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGV2ZW50LmRldGFpbCA9PT0gMDtcbiAgICBpZiAoIXRoaXMuI29wZW5Ecm9wZG93bkFDKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNvcGVuRHJvcGRvd25BQylcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICB0aGlzLiNidXR0b24uYXBwZW5kKHJvb3QpO1xuICB9XG4gICNwb2ludGVyRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiNkcm9wZG93bj8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHtcbiAgICB0aGlzLiNkcm9wZG93bj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJmYWxzZVwiO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgfVxuICBnZXQgI2lzRHJvcGRvd25WaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkcm9wZG93biAmJiAhdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICB9XG4gIF9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI2VkaXRvcj8udW5zZWxlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICB0aGlzLiNidXR0b24uZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0aGlzLiNidXR0b25Td2F0Y2gpIHtcbiAgICAgIHRoaXMuI2J1dHRvblN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkcm9wZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI2Ryb3Bkb3duLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5hcmlhU2VsZWN0ZWQgPSBpLm5leHQoKS52YWx1ZSA9PT0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5jbGFzcyBCYXNpY0NvbG9yUGlja2VyIHtcbiAgI2lucHV0ID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3IuX3VpTWFuYWdlcjtcbiAgICBCYXNpY0NvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLWNvbG9yLXBpY2tlci1mcmVlLXRleHQtaW5wdXRcIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWluay1pbnB1dFwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2lucHV0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgY29sb3JUeXBlLFxuICAgICAgY29sb3JWYWx1ZVxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLiNpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJjb2xvclwiO1xuICAgIGlucHV0LnZhbHVlID0gY29sb3JWYWx1ZSB8fCBcIiMwMDAwMDBcIjtcbiAgICBpbnB1dC5jbGFzc05hbWUgPSBcImJhc2ljQ29sb3JQaWNrZXJcIjtcbiAgICBpbnB1dC50YWJJbmRleCA9IDA7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEJhc2ljQ29sb3JQaWNrZXIuI2wxMG5Db2xvcltlZGl0b3JUeXBlXSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVQYXJhbXMoY29sb3JUeXBlLCBpbnB1dC52YWx1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2lucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNpbnB1dD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jaW5wdXQgPSBudWxsO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHt9XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmZpbmQuanNcbnZhciBlc19pdGVyYXRvcl9maW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZmxhdC1tYXAuanNcbnZhciBlc19pdGVyYXRvcl9mbGF0X21hcCA9IF9fd2VicGFja19yZXF1aXJlX18oNTMxKTtcbjsvLyAuL3NyYy9zaGFyZWQvc2NyaXB0aW5nX3V0aWxzLmpzXG5cblxuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDEgLSBNYXRoLm1pbigxLCAwLjMgKiBjICsgMC41OSAqIG0gKyAwLjExICogeSArIGspXTtcbiAgfVxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuICBzdGF0aWMgR19SR0IoW2ddKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCBnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19yZ2IoW2ddKSB7XG4gICAgZyA9IHNjYWxlQW5kQ2xhbXAoZyk7XG4gICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19IVE1MKFtnXSkge1xuICAgIGNvbnN0IEcgPSBtYWtlQ29sb3JDb21wKGcpO1xuICAgIHJldHVybiBgIyR7R30ke0d9JHtHfWA7XG4gIH1cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuICBzdGF0aWMgUkdCX3JnYihjb2xvcikge1xuICAgIHJldHVybiBjb2xvci5tYXAoc2NhbGVBbmRDbGFtcCk7XG4gIH1cbiAgc3RhdGljIFJHQl9IVE1MKGNvbG9yKSB7XG4gICAgcmV0dXJuIGAjJHtjb2xvci5tYXAobWFrZUNvbG9yQ29tcCkuam9pbihcIlwiKX1gO1xuICB9XG4gIHN0YXRpYyBUX0hUTUwoKSB7XG4gICAgcmV0dXJuIFwiIzAwMDAwMDAwXCI7XG4gIH1cbiAgc3RhdGljIFRfcmdiKCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH1cbiAgc3RhdGljIENNWUtfUkdCKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIENNWUtfcmdiKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgYyArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgbSArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgeSArIGspKV07XG4gIH1cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG4gIHN0YXRpYyBSR0JfQ01ZSyhbciwgZywgYl0pIHtcbiAgICBjb25zdCBjID0gMSAtIHI7XG4gICAgY29uc3QgbSA9IDEgLSBnO1xuICAgIGNvbnN0IHkgPSAxIC0gYjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgYywgbSwgeSwga107XG4gIH1cbn1cbmNvbnN0IERhdGVGb3JtYXRzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wibS9kXCIsIFwibS9kL3l5XCIsIFwibW0vZGQveXlcIiwgXCJtbS95eVwiLCBcImQtbW1tXCIsIFwiZC1tbW0teXlcIiwgXCJkZC1tbW0teXlcIiwgXCJ5eS1tbS1kZFwiLCBcIm1tbS15eVwiLCBcIm1tbW0teXlcIiwgXCJtbW0gZCwgeXl5eVwiLCBcIm1tbW0gZCwgeXl5eVwiLCBcIm0vZC95eSBoOk1NIHR0XCIsIFwibS9kL3l5IEhIOk1NXCJdKSk7XG5jb25zdCBUaW1lRm9ybWF0cyA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtcIkhIOk1NXCIsIFwiaDpNTSB0dFwiLCBcIkhIOk1NOnNzXCIsIFwiaDpNTTpzcyB0dFwiXSkpO1xuXG47Ly8gLi9zcmMvZGlzcGxheS9zdmdfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX2xheWVyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRSA9IDk7XG5jb25zdCBHZXRFbGVtZW50c0J5TmFtZVNldCA9IG5ldyBXZWFrU2V0KCk7XG5jb25zdCBUSU1FWk9ORV9PRkZTRVQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gICNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZUNvbW1lbnQgPSBwYXJhbWV0ZXJzLmVuYWJsZUNvbW1lbnQ7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhIShjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBfaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlzRWRpdGFibGU7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRGF0YSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YSh0aGlzLmRhdGEpIHx8IHRoaXMuZW5hYmxlQ29tbWVudCAmJiAhIXRoaXMuY29tbWVudFRleHQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnREYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlPy5nZXRFZGl0b3IoZGF0YS5pZCk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgcmV0dXJuIGVkaXRvci5nZXREYXRhKCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldCBoYXNDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUNvbW1lbnQgJiYgdGhpcy5oYXNQb3B1cEVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlPy5nZXRFZGl0b3IodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLmNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50cyxcbiAgICAgIGlua0xpc3RzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG4gICAgaWYgKHF1YWRQb2ludHM/Lmxlbmd0aCA+PSA4KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRQb2ludHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgaWYgKHF1YWRQb2ludHNbaSArIDFdID4gbWF4WSkge1xuICAgICAgICAgIG1heFkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBtYXhYID0gcXVhZFBvaW50c1tpICsgMl07XG4gICAgICAgIH0gZWxzZSBpZiAocXVhZFBvaW50c1tpICsgMV0gPT09IG1heFkpIHtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcXVhZFBvaW50c1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW21heFgsIG1heFldO1xuICAgIH1cbiAgICBpZiAoaW5rTGlzdHM/Lmxlbmd0aCA+PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGlua0xpc3Qgb2YgaW5rTGlzdHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5rTGlzdC5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGlua0xpc3RbaSArIDFdID4gbWF4WSkge1xuICAgICAgICAgICAgbWF4WSA9IGlua0xpc3RbaSArIDFdO1xuICAgICAgICAgICAgbWF4WCA9IGlua0xpc3RbaV07XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmtMaXN0W2kgKyAxXSA9PT0gbWF4WSkge1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGlua0xpc3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFggIT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBbbWF4WCwgbWF4WV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICByZXR1cm4gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfbm9ybWFsaXplUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBwb2ludFsxXSA9IHZpZXdbM10gLSBwb2ludFsxXSArIHZpZXdbMV07XG4gICAgcG9pbnRbMF0gPSAxMDAgKiAocG9pbnRbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgcG9pbnRbMV0gPSAxMDAgKiAocG9pbnRbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICBnZXQgY29tbWVudFRleHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHtkYXRhLmlkfWApPy5wb3B1cD8uY29udGVudHMgfHwgZGF0YS5jb250ZW50c09iaj8uc3RyIHx8IFwiXCI7XG4gIH1cbiAgc2V0IGNvbW1lbnRUZXh0KHRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcG9wdXAgPSB7XG4gICAgICBkZWxldGVkOiAhdGV4dCxcbiAgICAgIGNvbnRlbnRzOiB0ZXh0IHx8IFwiXCJcbiAgICB9O1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS51cGRhdGVFZGl0b3IoZGF0YS5pZCwge1xuICAgICAgcG9wdXBcbiAgICB9KSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZShgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7ZGF0YS5pZH1gLCB7XG4gICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICBhbm5vdGF0aW9uVHlwZTogZGF0YS5hbm5vdGF0aW9uVHlwZSxcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLnBhcmVudC5wYWdlLl9wYWdlSW5kZXgsXG4gICAgICAgIHBvcHVwLFxuICAgICAgICBwb3B1cFJlZjogZGF0YS5wb3B1cFJlZixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogbmV3IERhdGUoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdGV4dCkge1xuICAgICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVQb3B1cCgpIHtcbiAgICAodGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cCB8fCB0aGlzLnBvcHVwKT8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50ID0gdGhpcy5wb3B1cCA9IG51bGw7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5yZWN0KSB7XG4gICAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LnNsaWNlKDApXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgcG9wdXA6IG5ld1BvcHVwXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAocmVjdCkge1xuICAgICAgdGhpcy4jc2V0UmVjdEVkaXRlZChyZWN0KTtcbiAgICB9XG4gICAgbGV0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cCB8fCB0aGlzLnBvcHVwO1xuICAgIGlmICghcG9wdXAgJiYgbmV3UG9wdXA/LnRleHQpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG5ld1BvcHVwKTtcbiAgICAgIHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50LnBvcHVwO1xuICAgIH1cbiAgICBpZiAoIXBvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBvcHVwLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGlmIChuZXdQb3B1cD8uZGVsZXRlZCkge1xuICAgICAgcG9wdXAucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHRoaXMuI3VwZGF0ZXMucmVjdCk7XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cC5yZXNldEVkaXRlZCgpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICB9XG4gICNzZXRSZWN0RWRpdGVkKHJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3Q6IGN1cnJlbnRSZWN0LFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudFJlY3Q/LnNwbGljZSgwLCA0LCAuLi5yZWN0KTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHBhZ2VIZWlnaHQgLSByZWN0WzNdICsgcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBpZiAocm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpICYmICEodGhpcyBpbnN0YW5jZW9mIExpbmtBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRhaW5lcjtcbiAgICBzdHlsZS56SW5kZXggPSB0aGlzLnBhcmVudC56SW5kZXg7XG4gICAgdGhpcy5wYXJlbnQuekluZGV4ICs9IDI7XG4gICAgaWYgKGRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSBkYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEubm9Sb3RhdGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9yb3RhdGVcIik7XG4gICAgfVxuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuREFTSEVEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIHN0eWxlLmJvcmRlckNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGFuZ2xlICUgMTgwICE9PSAwKSB7XG4gICAgICBbd2lkdGgsIGhlaWdodF0gPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9IVE1MYF0oY29sb3JBcnJheSk7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICBbc3R5bGVOYW1lXTogQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdC5tYXAoeCA9PiBNYXRoLmZyb3VuZCh4KSk7XG4gICAgaWYgKHF1YWRQb2ludHMubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBbdHJYLCB0clksIGJsWCwgYmxZXSA9IHF1YWRQb2ludHMuc3ViYXJyYXkoMiwgNik7XG4gICAgICBpZiAocmVjdFRyWCA9PT0gdHJYICYmIHJlY3RUclkgPT09IHRyWSAmJiByZWN0QmxYID09PSBibFggJiYgcmVjdEJsWSA9PT0gYmxZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5jb250YWluZXI7XG4gICAgbGV0IHN2Z0J1ZmZlcjtcbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICBib3JkZXJXaWR0aFxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgc3ZnQnVmZmVyID0gW1widXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiwgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiYCwgYCBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMSAxXCI+YCwgYDxnIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiR7Ym9yZGVyQ29sb3J9XCIgc3Ryb2tlLXdpZHRoPVwiJHtib3JkZXJXaWR0aH1cIj5gXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNCb3JkZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gcmVjdFRyWCAtIHJlY3RCbFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdFRyWSAtIHJlY3RCbFk7XG4gICAgY29uc3Qge1xuICAgICAgc3ZnRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Z1wiKTtcbiAgICBzdmcuY2xhc3NMaXN0LmFkZChcInF1YWRyaWxhdGVyYWxzQ29udGFpbmVyXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgIHN2Zy5yb2xlID0gXCJub25lXCI7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcXVhZFBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSA4KSB7XG4gICAgICBjb25zdCB0clggPSBxdWFkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgdHJZID0gcXVhZFBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCBibFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGJsWSA9IHF1YWRQb2ludHNbaSArIDNdO1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAocG9wdXBEYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgY29udGVudHNPYmosIG1vZGlmaWNhdGlvbkRhdGU7XG4gICAgaWYgKHBvcHVwRGF0YSkge1xuICAgICAgY29udGVudHNPYmogPSB7XG4gICAgICAgIHN0cjogcG9wdXBEYXRhLnRleHRcbiAgICAgIH07XG4gICAgICBtb2RpZmljYXRpb25EYXRlID0gcG9wdXBEYXRhLmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRzT2JqID0gZGF0YS5jb250ZW50c09iajtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBkYXRhLm1vZGlmaWNhdGlvbkRhdGU7XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb24sXG4gICAgICAgIG5vUm90YXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMubGlua1NlcnZpY2UsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5wYXJlbnQuX2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuYXBwZW5kKHBvcHVwLnJlbmRlcigpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRWxlbWVudCgpIHtcbiAgICByZXR1cm4gISEodGhpcy4jcG9wdXBFbGVtZW50IHx8IHRoaXMucG9wdXAgfHwgdGhpcy5kYXRhLnBvcHVwUmVmKTtcbiAgfVxuICBnZXQgZXh0cmFQb3B1cEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcHVwRWxlbWVudDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYEFubm90YXRpb25FbGVtZW50LnJlbmRlcmAgY2FsbGVkXCIpO1xuICB9XG4gIF9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBza2lwSWQgPSBudWxsKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgaWYgKHRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgY29uc3QgZmllbGRPYmogPSB0aGlzLl9maWVsZE9iamVjdHNbbmFtZV07XG4gICAgICBpZiAoZmllbGRPYmopIHtcbiAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgcGFnZSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBleHBvcnRWYWx1ZXNcbiAgICAgICAgfSBvZiBmaWVsZE9iaikge1xuICAgICAgICAgIGlmIChwYWdlID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSB0eXBlb2YgZXhwb3J0VmFsdWVzID09PSBcInN0cmluZ1wiID8gZXhwb3J0VmFsdWVzIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgJiYgIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICAgd2FybihgX2dldEVsZW1lbnRzQnlOYW1lIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgIH0gPSBkb21FbGVtZW50O1xuICAgICAgY29uc3QgaWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiKTtcbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgZG9tRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5tYXliZVNob3coKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8uZm9yY2VIaWRlKCk7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJzLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgIH1cbiAgfVxuICBfZWRpdE9uRG91YmxlQ2xpY2soKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FZGl0b3JUeXBlOiBtb2RlLFxuICAgICAgZGF0YToge1xuICAgICAgICBpZDogZWRpdElkXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGVkaXRJZCxcbiAgICAgICAgbXVzdEVudGVySW5FZGl0TW9kZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV07XG4gIH1cbn1cbmNsYXNzIEVkaXRvckFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSBwYXJhbWV0ZXJzLmVkaXRvcjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJlZGl0b3JBbm5vdGF0aW9uXCI7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGNyZWF0ZU9yVXBkYXRlUG9wdXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlZGl0b3IuaGFzQ29tbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jcmVhdGVQb3B1cChlZGl0b3IuY29tbWVudCk7XG4gICAgdGhpcy5leHRyYVBvcHVwRWxlbWVudC5wb3B1cC5yZW5kZXJDb21tZW50QnV0dG9uKCk7XG4gIH1cbiAgZ2V0IGhhc0NvbW1lbnRCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlQ29tbWVudCAmJiB0aGlzLmVkaXRvci5oYXNDb21tZW50O1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZTtcbiAgfVxuICBnZXQgY29tbWVudFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1lbnQudGV4dDtcbiAgfVxuICBzZXQgY29tbWVudFRleHQodGV4dCkge1xuICAgIHRoaXMuZWRpdG9yLmNvbW1lbnQgPSB0ZXh0O1xuICAgIGlmICghdGV4dCkge1xuICAgICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICAgIH1cbiAgfVxuICBnZXQgY29tbWVudERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldERhdGEoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogISFvcHRpb25zPy5pZ25vcmVCb3JkZXIsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNUb29sdGlwT25seSA9IHBhcmFtZXRlcnMuZGF0YS5pc1Rvb2x0aXBPbmx5O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgbGlua1NlcnZpY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgZGF0YS5pZCk7XG4gICAgbGV0IGlzQm91bmQgPSBmYWxzZTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24sIGRhdGEub3ZlcmxhaWRUZXh0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRhY2htZW50KSB7XG4gICAgICB0aGlzLiNiaW5kQXR0YWNobWVudChsaW5rLCBkYXRhLmF0dGFjaG1lbnQsIGRhdGEub3ZlcmxhaWRUZXh0LCBkYXRhLmF0dGFjaG1lbnREZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUsIGRhdGEub3ZlcmxhaWRUZXh0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5kZXN0KSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QsIGRhdGEub3ZlcmxhaWRUZXh0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YS5hY3Rpb25zICYmIChkYXRhLmFjdGlvbnMuQWN0aW9uIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIFVwXCJdIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIERvd25cIl0pICYmIHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5yZXNldEZvcm0pIHtcbiAgICAgICAgdGhpcy5fYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCBkYXRhLnJlc2V0Rm9ybSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVG9vbHRpcE9ubHkgJiYgIWlzQm91bmQpIHtcbiAgICAgICAgdGhpcy5fYmluZExpbmsobGluaywgXCJcIik7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGlua0Fubm90YXRpb25cIik7XG4gICAgaWYgKGlzQm91bmQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gICNzZXRJbnRlcm5hbExpbmsoKSB7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1pbnRlcm5hbC1saW5rXCIsIFwiXCIpO1xuICB9XG4gIF9iaW5kTGluayhsaW5rLCBkZXN0aW5hdGlvbiwgb3ZlcmxhaWRUZXh0ID0gXCJcIikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0RGVzdGluYXRpb25IYXNoKGRlc3RpbmF0aW9uKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5nb1RvRGVzdGluYXRpb24oZGVzdGluYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKGRlc3RpbmF0aW9uIHx8IGRlc3RpbmF0aW9uID09PSBcIlwiKSB7XG4gICAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICB9XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gIH1cbiAgX2JpbmROYW1lZEFjdGlvbihsaW5rLCBhY3Rpb24sIG92ZXJsYWlkVGV4dCA9IFwiXCIpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVOYW1lZEFjdGlvbihhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRBdHRhY2htZW50KGxpbmssIGF0dGFjaG1lbnQsIG92ZXJsYWlkVGV4dCA9IFwiXCIsIGRlc3QgPSBudWxsKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgaWYgKGF0dGFjaG1lbnQuZGVzY3JpcHRpb24pIHtcbiAgICAgIGxpbmsudGl0bGUgPSBhdHRhY2htZW50LmRlc2NyaXB0aW9uO1xuICAgIH0gZWxzZSBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKGF0dGFjaG1lbnQuY29udGVudCwgYXR0YWNobWVudC5maWxlbmFtZSwgZGVzdCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZFNldE9DR1N0YXRlKGxpbmssIGFjdGlvbiwgb3ZlcmxhaWRUZXh0ID0gXCJcIikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZVNldE9DR1N0YXRlKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKFtbXCJBY3Rpb25cIiwgXCJvbmNsaWNrXCJdLCBbXCJNb3VzZSBVcFwiLCBcIm9ubW91c2V1cFwiXSwgW1wiTW91c2UgRG93blwiLCBcIm9ubW91c2Vkb3duXCJdXSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRhdGEuYWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGpzTmFtZSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICBpZiAoIWpzTmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxpbmtbanNOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZGF0YS5vdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBkYXRhLm92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtdGV4dC1hbm5vdGF0aW9uLXR5cGVcIik7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCByb3VuZFRvT25lRGVjaW1hbCA9IHggPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSB0aGlzLmRhdGEucGFzc3dvcmQgPyBcInBhc3N3b3JkXCIgOiBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGV0aW1lRm9ybWF0LFxuICAgICAgICBkYXRldGltZVR5cGUsXG4gICAgICAgIHRpbWVTdGVwXG4gICAgICB9ID0gdGhpcy5kYXRhO1xuICAgICAgY29uc3QgaGFzRGF0ZU9yVGltZSA9ICEhZGF0ZXRpbWVUeXBlICYmIHRoaXMuZW5hYmxlU2NyaXB0aW5nO1xuICAgICAgaWYgKGRhdGV0aW1lRm9ybWF0KSB7XG4gICAgICAgIGVsZW1lbnQudGl0bGUgPSBkYXRldGltZUZvcm1hdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgICBpZiAobWF4TGVuKSB7XG4gICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gbWF4TGVuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU9uU2libGluZ3MoZWxlbWVudCwgXCJ2YWx1ZVwiLCBldmVudC50YXJnZXQudmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlID8/IFwiXCI7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgbGV0IGJsdXJMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgIHRhcmdldC50eXBlID0gZGF0ZXRpbWVUeXBlO1xuICAgICAgICAgICAgaWYgKHRpbWVTdGVwKSB7XG4gICAgICAgICAgICAgIHRhcmdldC5zdGVwID0gdGltZVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS51c2VyVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGV0aW1lVHlwZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gW2RhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBwYXJ0cy5tYXAodiA9PiB2LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiOlwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSAtIFRJTUVaT05FX09GRlNFVCkudG9JU09TdHJpbmcoKS5zcGxpdChkYXRldGltZVR5cGUgPT09IFwiZGF0ZVwiID8gXCJUXCIgOiBcIi5cIiwgMSlbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgaWYgKCFoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbFJhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSguLi5ldmVudC5kZXRhaWwuc2VsUmFuZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYXJMaW1pdDogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgY2hhckxpbWl0XG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICBpZiAoY2hhckxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcIm1heExlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcIm1heExlbmd0aFwiLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoIDw9IGNoYXJMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQ6IHRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgIHNlbEVuZDogdGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGxldCBjb21taXRLZXkgPSAtMTtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIXRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21taXRLZXkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgY29tbWl0S2V5LFxuICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9ibHVyTGlzdGVuZXIgPSBibHVyTGlzdGVuZXI7XG4gICAgICAgIGJsdXJMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgZGF0ZXRpbWVUeXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KFwiOlwiKS5tYXAodiA9PiBwYXJzZUludCh2LCAxMCkpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKDIwMDAsIDAsIDEsIHBhcnRzWzBdLCBwYXJ0c1sxXSwgcGFydHNbMl0gfHwgMCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICB0YXJnZXQuc3RlcCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKFwiVFwiKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9VDAwOjAwYDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tbWl0S2V5OiBlbGVtZW50RGF0YS5jb21taXRLZXksXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ibHVyTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hY3Rpb25zPy5LZXlzdHJva2UpIHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgc2VsU3RhcnQgPSBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXFx3KlteXFx3XSokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCkubWF0Y2goL15bXlxcd10qXFx3Ki8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogZGF0YSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJsdXJMaXN0ZW5lcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgY29uc3QgZmllbGRXaWR0aCA9IHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IGNvbWJXaWR0aCA9IGZpZWxkV2lkdGggLyBtYXhMZW47XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNvbWJcIik7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGV0dGVyU3BhY2luZyA9IGBjYWxjKCR7Y29tYldpZHRofXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAtIDFjaClgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlLWNlbGxcIjtcbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0VGV4dFN0eWxlKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogISFwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZXhwb3J0VmFsdWUgPT09IGRhdGEuZmllbGRWYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJjaGVja0JveFwiKTtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZXhwb3J0VmFsdWVcIiwgZGF0YS5leHBvcnRWYWx1ZSk7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgY2hlY2tib3ggb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIGNoZWNrYm94LmV4cG9ydFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgICAgICBpZiAoY2hlY2tib3guZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrYm94LmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgfHwgXCJPZmZcIjtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZXZlbnQuZGV0YWlsLnZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJyYWRpb0J1dHRvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5maWVsZFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZGF0YS5maWVsZE5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgbGV0IGFkZEFuRW1wdHlFbnRyeSA9IHRoaXMuZGF0YS5jb21ibyAmJiB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGggPiAwO1xuICAgIGlmICghdGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpU2VsZWN0KSB7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi52YWx1ZSA9PT0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMuZGF0YS5vcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb24uZGlzcGxheVZhbHVlO1xuICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IG9wdGlvbi5leHBvcnRWYWx1ZTtcbiAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlLmluY2x1ZGVzKG9wdGlvbi5leHBvcnRWYWx1ZSkpIHtcbiAgICAgICAgb3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgICAgYWRkQW5FbXB0eUVudHJ5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICB9XG4gICAgbGV0IHJlbW92ZUVtcHR5RW50cnkgPSBudWxsO1xuICAgIGlmIChhZGRBbkVtcHR5RW50cnkpIHtcbiAgICAgIGNvbnN0IG5vbmVPcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnZhbHVlID0gXCIgXCI7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgIHNlbGVjdEVsZW1lbnQucHJlcGVuZChub25lT3B0aW9uRWxlbWVudCk7XG4gICAgICByZW1vdmVFbXB0eUVudHJ5ID0gKCkgPT4ge1xuICAgICAgICBub25lT3B0aW9uRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgIH1cbiAgICBjb25zdCBnZXRWYWx1ZSA9IGlzRXhwb3J0ID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpc0V4cG9ydCA/IFwidmFsdWVcIiA6IFwidGV4dENvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgIH0gPSBzZWxlY3RFbGVtZW50O1xuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWxlY3RlZEluZGV4ID09PSAtMSA/IG51bGwgOiBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF1bbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpLm1hcChvcHRpb24gPT4gb3B0aW9uW25hbWVdKTtcbiAgICB9O1xuICAgIGxldCBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwob3B0aW9ucywgb3B0aW9uID0+ICh7XG4gICAgICAgIGRpc3BsYXlWYWx1ZTogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICBleHBvcnRWYWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICByZW1vdmVFbXB0eUVudHJ5Py4oKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWVzLmhhcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdWx0aXBsZVNlbGVjdGlvbihldmVudCkge1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZWxlY3RFbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmRldGFpbC5yZW1vdmU7XG4gICAgICAgICAgICBvcHRpb25zW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBpID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGVhcihldmVudCkge1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsLmluc2VydDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdENoaWxkID0gc2VsZWN0RWxlbWVudC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgc2VsZWN0Q2hpbGQuYmVmb3JlKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1zKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGl0ZW1zXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgICAgfSA9IGl0ZW07XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdEVsZW1lbnQub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZGljZXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgU2V0KGV2ZW50LmRldGFpbC5pbmRpY2VzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGV2ZW50LnRhcmdldC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGluZGljZXMuaGFzKG9wdGlvbi5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVkaXRhYmxlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSAhZXZlbnQuZGV0YWlsLmVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBleHBvcnRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICBjaGFuZ2UsXG4gICAgICAgICAgICBjaGFuZ2VFeDogZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgIGtleURvd246IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoc2VsZWN0RWxlbWVudCwgbnVsbCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl0sIFtcImlucHV0XCIsIFwiQWN0aW9uXCJdLCBbXCJpbnB1dFwiLCBcIlZhbGlkYXRlXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5jb21ibykge1xuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlKHNlbGVjdEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7fVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihzZWxlY3RFbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhzZWxlY3RFbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc2VsZWN0RWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgcGFyZW50XG4gICAgfSA9IHBhcmFtZXRlcnM7XG4gICAgY29uc3QgaGFzQ29tbWVudE1hbmFnZXIgPSAhIXBhcmVudC5fY29tbWVudE1hbmFnZXI7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhaGFzQ29tbWVudE1hbmFnZXIgJiYgQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICBpZiAoaGFzQ29tbWVudE1hbmFnZXIgJiYgQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKSkge1xuICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwID0gdGhpcy4jY3JlYXRlUG9wdXAoKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50LnBvcHVwID0gcG9wdXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgIH1cbiAgfVxuICAjY3JlYXRlUG9wdXAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb3B1cEVsZW1lbnQoe1xuICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEuY29sb3IsXG4gICAgICB0aXRsZU9iajogdGhpcy5kYXRhLnRpdGxlT2JqLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGUgfHwgdGhpcy5kYXRhLmNyZWF0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLmRhdGEuY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy5kYXRhLnJpY2hUZXh0LFxuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3QsXG4gICAgICBwYXJlbnRSZWN0OiB0aGlzLmRhdGEucGFyZW50UmVjdCB8fCBudWxsLFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLFxuICAgICAgb3BlbjogdGhpcy5kYXRhLm9wZW4sXG4gICAgICBjb21tZW50TWFuYWdlcjogdGhpcy5wYXJlbnQuX2NvbW1lbnRNYW5hZ2VyXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwicG9wdXBBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnRhaW5lci5yb2xlID0gXCJjb21tZW50XCI7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwID0gdGhpcy4jY3JlYXRlUG9wdXAoKTtcbiAgICBjb25zdCBlbGVtZW50SWRzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyLmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjY29tbWVudE1hbmFnZXIgPSBudWxsO1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNkYXRlT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAjcG9zaXRpb24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvbiA9IG51bGw7XG4gICNjb21tZW50QnV0dG9uUG9zaXRpb24gPSBudWxsO1xuICAjcG9wdXBQb3NpdGlvbiA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAjZmlyc3RFbGVtZW50ID0gbnVsbDtcbiAgI2NvbW1lbnRUZXh0ID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBjb2xvcixcbiAgICBlbGVtZW50cyxcbiAgICB0aXRsZU9iaixcbiAgICBtb2RpZmljYXRpb25EYXRlLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0LFxuICAgIHBhcmVudCxcbiAgICByZWN0LFxuICAgIHBhcmVudFJlY3QsXG4gICAgb3BlbixcbiAgICBjb21tZW50TWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN0aXRsZU9iaiA9IHRpdGxlT2JqO1xuICAgIHRoaXMuI2NvbnRlbnRzT2JqID0gY29udGVudHNPYmo7XG4gICAgdGhpcy4jcmljaFRleHQgPSByaWNoVGV4dDtcbiAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy4jY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLiNyZWN0ID0gcmVjdDtcbiAgICB0aGlzLiNwYXJlbnRSZWN0ID0gcGFyZW50UmVjdDtcbiAgICB0aGlzLiNlbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXI7XG4gICAgdGhpcy4jZmlyc3RFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgdGhpcy4jZGF0ZU9iaiA9IFBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgaWYgKGNvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgdGhpcy4jYm91bmRTaG93LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy4jYm91bmRIaWRlLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWxlbWVudHMuZmluZChlID0+IGUuaGFzQ29tbWVudEJ1dHRvbik7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbiA9IGVsZW1lbnQuX25vcm1hbGl6ZVBvaW50KGVsZW1lbnQuY29tbWVudEJ1dHRvblBvc2l0aW9uKTtcbiAgfVxuICByZW5kZXJDb21tZW50QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uKSB7XG4gICAgICB0aGlzLiNzZXRDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGhhc093bkJ1dHRvbiA9ICEhdGhpcy4jZmlyc3RFbGVtZW50LmV4dHJhUG9wdXBFbGVtZW50O1xuICAgIGNvbnN0IHRvZ2dsZVBvcHVwID0gKCkgPT4ge1xuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXIudG9nZ2xlQ29tbWVudFBvcHVwKHRoaXMsIHRydWUsIHVuZGVmaW5lZCwgIWhhc093bkJ1dHRvbik7XG4gICAgfTtcbiAgICBjb25zdCBzaG93UG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgZmFsc2UsIHRydWUsICFoYXNPd25CdXR0b24pO1xuICAgIH07XG4gICAgY29uc3QgaGlkZVBvcHVwID0gKCkgPT4ge1xuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXIudG9nZ2xlQ29tbWVudFBvcHVwKHRoaXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBpZiAoIWhhc093bkJ1dHRvbikge1xuICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24uY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29tbWVudEJ1dHRvblwiO1xuICAgICAgY29uc3QgcGFyZW50Q29udGFpbmVyID0gdGhpcy4jZmlyc3RFbGVtZW50LmNvbnRhaW5lcjtcbiAgICAgIGJ1dHRvbi5zdHlsZS56SW5kZXggPSBwYXJlbnRDb250YWluZXIuc3R5bGUuekluZGV4ICsgMTtcbiAgICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgICBidXR0b24uYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGJ1dHRvbi5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXNob3ctY29tbWVudC1idXR0b25cIik7XG4gICAgICB0aGlzLiN1cGRhdGVDb2xvcigpO1xuICAgICAgdGhpcy4jdXBkYXRlQ29tbWVudEJ1dHRvblBvc2l0aW9uKCk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvZ2dsZVBvcHVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBzaG93UG9wdXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIGhpZGVQb3B1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgcGFyZW50Q29udGFpbmVyLmFmdGVyKGJ1dHRvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRCdXR0b24gPSB0aGlzLiNmaXJzdEVsZW1lbnQuY29udGFpbmVyO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgICBlbGVtZW50LmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgICAgIGVsZW1lbnQuYXJpYUNvbnRyb2xzID0gXCJjb21tZW50UG9wdXBcIjtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvZ2dsZVBvcHVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgc2hvd1BvcHVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgaGlkZVBvcHVwLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjdXBkYXRlQ29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNmaXJzdEVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQgJiYgIXRoaXMuI2ZpcnN0RWxlbWVudC5lZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJDb21tZW50QnV0dG9uKCk7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbW1lbnRCdXR0b247XG4gICAgc3R5bGUubGVmdCA9IGBjYWxjKCR7eH0lKWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHt5fSUgLSB2YXIoLS1jb21tZW50LWJ1dHRvbi1kaW0pKWA7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKCkge1xuICAgIGlmICh0aGlzLiNmaXJzdEVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJDb21tZW50QnV0dG9uKCk7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbW1lbnRCdXR0b25Db2xvciB8fCBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uQ29sb3IoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5XG4gICAgfSA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50RGF0YTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3BhcmVudC5fY29tbWVudE1hbmFnZXIubWFrZUNvbW1lbnRDb2xvcihjb2xvciwgb3BhY2l0eSk7XG4gIH1cbiAgZm9jdXNDb21tZW50QnV0dG9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbj8uZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJpY2hUZXh0LFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgIH0gPSB0aGlzLiNmaXJzdEVsZW1lbnQuY29tbWVudERhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRzT2JqOiB7XG4gICAgICAgIHN0cjogdGhpcy5jb21tZW50XG4gICAgICB9LFxuICAgICAgcmljaFRleHQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgfTtcbiAgfVxuICBnZXQgZWxlbWVudEJlZm9yZVBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50QnV0dG9uO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIHRoaXMuI2NvbW1lbnRUZXh0IHx8PSB0aGlzLiNmaXJzdEVsZW1lbnQuY29tbWVudFRleHQ7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRUZXh0O1xuICB9XG4gIHNldCBjb21tZW50KHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gdGhpcy5jb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50VGV4dCA9IHRoaXMuI2NvbW1lbnRUZXh0ID0gdGV4dDtcbiAgfVxuICBnZXQgcGFyZW50Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLiNmaXJzdEVsZW1lbnQubGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgc2V0Q29tbWVudEJ1dHRvblN0YXRlcyh7XG4gICAgc2VsZWN0ZWQsXG4gICAgaGFzUG9wdXBcbiAgfSkge1xuICAgIGlmICghdGhpcy4jY29tbWVudEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCBzZWxlY3RlZCk7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbi5hcmlhRXhwYW5kZWQgPSBoYXNQb3B1cDtcbiAgfVxuICBzZXRTZWxlY3RlZENvbW1lbnRCdXR0b24oc2VsZWN0ZWQpIHtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCBzZWxlY3RlZCk7XG4gIH1cbiAgZ2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jY29tbWVudEJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRoaXMuI2ZpcnN0RWxlbWVudC5sYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyh4IC0gcGFyZW50WCkgLyBwYXJlbnRXaWR0aCwgKHkgKyBoZWlnaHQgLSBwYXJlbnRZKSAvIHBhcmVudEhlaWdodF07XG4gIH1cbiAgc2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uKHBvcykge1xuICAgIHRoaXMuI3BvcHVwUG9zaXRpb24gPSBwb3M7XG4gIH1cbiAgaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvcHVwUG9zaXRpb24gPT09IG51bGw7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyB0aGlzLnBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgfVxuICBlZGl0Q29tbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgW3Bvc1gsIHBvc1ldID0gdGhpcy4jcG9wdXBQb3NpdGlvbiB8fCB0aGlzLmNvbW1lbnRCdXR0b25Qb3NpdGlvbi5tYXAoeCA9PiB4IC8gMTAwKTtcbiAgICBjb25zdCBwYXJlbnREaW1lbnNpb25zID0gdGhpcy5wYXJlbnRCb3VuZGluZ0NsaWVudFJlY3Q7XG4gICAgY29uc3Qge1xuICAgICAgeDogcGFyZW50WCxcbiAgICAgIHk6IHBhcmVudFksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSBwYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnNob3dEaWFsb2cobnVsbCwgdGhpcywgcGFyZW50WCArIHBvc1ggKiBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBwYXJlbnREaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgaWYgKHRoaXMuI2NvbG9yKSB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBwb3B1cC5zdHlsZS5vdXRsaW5lQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvcik7XG4gICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGhlYWRlci5jbGFzc05hbWUgPSBcImhlYWRlclwiO1xuICAgIGlmICh0aGlzLiN0aXRsZU9iaj8uc3RyKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdGl0bGUuY2xhc3NOYW1lID0gXCJ0aXRsZVwiO1xuICAgICAgaGVhZGVyLmFwcGVuZCh0aXRsZSk7XG4gICAgICAoe1xuICAgICAgICBkaXI6IHRpdGxlLmRpcixcbiAgICAgICAgc3RyOiB0aXRsZS50ZXh0Q29udGVudFxuICAgICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICB9XG4gICAgcG9wdXAuYXBwZW5kKGhlYWRlcik7XG4gICAgaWYgKHRoaXMuI2RhdGVPYmopIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGltZVwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NOYW1lID0gXCJwb3B1cERhdGVcIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtYW5ub3RhdGlvbi1kYXRlLXRpbWUtc3RyaW5nXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGVPYmo6IHRoaXMuI2RhdGVPYmoudmFsdWVPZigpXG4gICAgICB9KSk7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmRhdGVUaW1lID0gdGhpcy4jZGF0ZU9iai50b0lTT1N0cmluZygpO1xuICAgICAgaGVhZGVyLmFwcGVuZChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB9XG4gICAgcmVuZGVyUmljaFRleHQoe1xuICAgICAgaHRtbDogdGhpcy4jaHRtbCB8fCB0aGlzLiNjb250ZW50c09iai5zdHIsXG4gICAgICBkaXI6IHRoaXMuI2NvbnRlbnRzT2JqPy5kaXIsXG4gICAgICBjbGFzc05hbWU6IFwicG9wdXBDb250ZW50XCJcbiAgICB9LCBwb3B1cCk7XG4gICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChwb3B1cCk7XG4gIH1cbiAgZ2V0ICNodG1sKCkge1xuICAgIGNvbnN0IHJpY2hUZXh0ID0gdGhpcy4jcmljaFRleHQ7XG4gICAgY29uc3QgY29udGVudHNPYmogPSB0aGlzLiNjb250ZW50c09iajtcbiAgICBpZiAocmljaFRleHQ/LnN0ciAmJiAoIWNvbnRlbnRzT2JqPy5zdHIgfHwgY29udGVudHNPYmouc3RyID09PSByaWNoVGV4dC5zdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jcmljaFRleHQuaHRtbCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgI2ZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNodG1sPy5hdHRyaWJ1dGVzPy5zdHlsZT8uZm9udFNpemUgfHwgMDtcbiAgfVxuICBnZXQgI2ZvbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmNvbG9yIHx8IG51bGw7XG4gIH1cbiAgI21ha2VQb3B1cENvbnRlbnQodGV4dCkge1xuICAgIGNvbnN0IHBvcHVwTGluZXMgPSBbXTtcbiAgICBjb25zdCBwb3B1cENvbnRlbnQgPSB7XG4gICAgICBzdHI6IHRleHQsXG4gICAgICBodG1sOiB7XG4gICAgICAgIG5hbWU6IFwiZGl2XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBkaXI6IFwiYXV0b1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBwb3B1cExpbmVzXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaW5lQXR0cmlidXRlcyA9IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiB0aGlzLiNmb250Q29sb3IsXG4gICAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSA/IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWAgOiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGV4dC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgcG9wdXBMaW5lcy5wdXNoKHtcbiAgICAgICAgbmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHZhbHVlOiBsaW5lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBsaW5lQXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1cENvbnRlbnQ7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRlZCh7XG4gICAgcmVjdCxcbiAgICBwb3B1cCxcbiAgICBkZWxldGVkXG4gIH0pIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRUZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocG9wdXApIHtcbiAgICAgICAgaWYgKHBvcHVwLmRlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKCk7XG4gICAgICAgICAgdGhpcy4jY29tbWVudFRleHQgPSBwb3B1cC50ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVjdCkge1xuICAgICAgICB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLiNzZXRDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29tbWVudEJ1dHRvblBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWxldGVkIHx8IHBvcHVwPy5kZWxldGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH07XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcHVwICYmIHBvcHVwLnRleHQpIHtcbiAgICAgIHRoaXMuI3JpY2hUZXh0ID0gdGhpcy4jbWFrZVBvcHVwQ29udGVudChwb3B1cC50ZXh0KTtcbiAgICAgIHRoaXMuI2RhdGVPYmogPSBQREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChwb3B1cC5kYXRlKTtcbiAgICAgIHRoaXMuI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgfVxuICByZXNldEVkaXRlZCgpIHtcbiAgICBpZiAoIXRoaXMuI3VwZGF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH0gPSB0aGlzLiN1cGRhdGVzKTtcbiAgICB0aGlzLiN1cGRhdGVzID0gbnVsbDtcbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI3Bpbm5lZCA9IGZhbHNlO1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24gPSBudWxsO1xuICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3NldFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgdGhpcy4jcG9zaXRpb24gPSBbMTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCwgMTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHt0aGlzLiNwb3NpdGlvblswXX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHt0aGlzLiNwb3NpdGlvblsxXX0lYDtcbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50TWFuYWdlcikge1xuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXIudG9nZ2xlQ29tbWVudFBvcHVwKHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcGlubmVkID0gIXRoaXMuI3Bpbm5lZDtcbiAgICBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoaWRlKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgfVxuICAjc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICB0aGlzLiNzZXRQb3NpdGlvbigpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpICsgMTAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmb2N1c2VkXCIpO1xuICAgIH1cbiAgfVxuICAjaGlkZSgpIHtcbiAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzZWRcIik7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCB8fCAhdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpIC0gMTAwMDtcbiAgfVxuICBmb3JjZUhpZGUoKSB7XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuICBtYXliZVNob3coKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICB9XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50TWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9PT0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gcGFyYW1ldGVycy5kYXRhLnRleHRDb250ZW50O1xuICAgIHRoaXMudGV4dFBvc2l0aW9uID0gcGFyYW1ldGVycy5kYXRhLnRleHRQb3NpdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFNxdWFyZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjc3F1YXJlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1YXJlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF2ZXJ0aWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdmVydGljZXNbaV0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IHJlY3RbM10gLSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XG4gICAgfVxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuI3BvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWdvbkFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWdvbkFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWdvblwiO1xuICB9XG59XG5jbGFzcyBDYXJldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjYXJldEFubm90YXRpb25cIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgSW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZXNHcm91cEVsZW1lbnQgPSBudWxsO1xuICAjcG9seWxpbmVzID0gW107XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSB0aGlzLmRhdGEuaXQgPT09IFwiSW5rSGlnaGxpZ2h0XCIgPyBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIH1cbiAgI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCkge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDkwKSB0cmFuc2xhdGUoJHstcmVjdFswXX0sJHtyZWN0WzFdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzNdIC0gcmVjdFsxXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbMl0gLSByZWN0WzBdXG4gICAgICAgIH07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoMTgwKSB0cmFuc2xhdGUoJHstcmVjdFsyXX0sJHtyZWN0WzFdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gICAgICAgIH07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoMjcwKSB0cmFuc2xhdGUoJHstcmVjdFsyXX0sJHtyZWN0WzNdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzNdIC0gcmVjdFsxXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbMl0gLSByZWN0WzBdXG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNnZXRUcmFuc2Zvcm0ocm90YXRpb24sIHJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgZyA9IHRoaXMuI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgc3ZnLmFwcGVuZChnKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1taXRlcmxpbWl0XCIsIDEwKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5rTGlzdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuI3BvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBpbmtMaXN0c1tpXS5qb2luKFwiLFwiKSk7XG4gICAgICBnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgfVxuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHVwZGF0ZUVkaXRlZChwYXJhbXMpIHtcbiAgICBzdXBlci51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICBjb25zdCB7XG4gICAgICB0aGlja25lc3MsXG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50O1xuICAgIGlmICh0aGlja25lc3MgPj0gMCkge1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpY2tuZXNzIHx8IDEpO1xuICAgIH1cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNwb2x5bGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB0aGlzLiNwb2x5bGluZXNbaV0uc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50c1tpXS5qb2luKFwiLFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybSh0aGlzLmRhdGEucm90YXRpb24sIHJlY3QpO1xuICAgICAgY29uc3Qgcm9vdCA9IGcucGFyZW50RWxlbWVudDtcbiAgICAgIHJvb3Quc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWFya1wiKTtcbiAgICAgIG1hcmsuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIG1hcmsudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobWFyayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCB1bmRlcmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidVwiKTtcbiAgICAgIHVuZGVybGluZS5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgdW5kZXJsaW5lLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHVuZGVybGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgdW5kZXJsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVcIik7XG4gICAgICB1bmRlcmxpbmUuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHVuZGVybGluZS50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh1bmRlcmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3Qgc3RyaWtlb3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNcIik7XG4gICAgICBzdHJpa2VvdXQuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHN0cmlrZW91dC50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdHJpa2VvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdGFtcEFubm90YXRpb25cIik7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN0cmlnZ2VyID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lO1xuICAgIHRoaXMuY29udGVudCA9IGZpbGUuY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5maWxlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChkYXRhLmhhc0FwcGVhcmFuY2UgfHwgZGF0YS5maWxsQWxwaGEgPT09IDApIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIHRyaWdnZXIuc3JjID0gYCR7dGhpcy5pbWFnZVJlc291cmNlc1BhdGh9YW5ub3RhdGlvbi0key9wYXBlcmNsaXAvaS50ZXN0KGRhdGEubmFtZSkgPyBcInBhcGVyY2xpcFwiIDogXCJwdXNocGluXCJ9LnN2Z2A7XG4gICAgICBpZiAoZGF0YS5maWxsQWxwaGEgJiYgZGF0YS5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUgPSBgZmlsdGVyOiBvcGFjaXR5KCR7TWF0aC5yb3VuZChkYXRhLmZpbGxBbHBoYSAqIDEwMCl9JSk7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy4jZG93bmxvYWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy4jdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI3N0cnVjdFRyZWVMYXllciA9IG51bGw7XG4gICNsaW5rU2VydmljZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnQsXG4gICAgc3RydWN0VHJlZUxheWVyLFxuICAgIGNvbW1lbnRNYW5hZ2VyLFxuICAgIGxpbmtTZXJ2aWNlLFxuICAgIGFubm90YXRpb25TdG9yYWdlXG4gIH0pIHtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMuI3N0cnVjdFRyZWVMYXllciA9IHN0cnVjdFRyZWVMYXllciB8fCBudWxsO1xuICAgIHRoaXMuI2xpbmtTZXJ2aWNlID0gbGlua1NlcnZpY2UgfHwgbnVsbDtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IGFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpO1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgICB0aGlzLl9jb21tZW50TWFuYWdlciA9IGNvbW1lbnRNYW5hZ2VyIHx8IG51bGw7XG4gIH1cbiAgaGFzRWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zaXplID4gMDtcbiAgfVxuICBhc3luYyAjYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCwgcG9wdXBFbGVtZW50cykge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgY29uc3QgYW5ub3RhdGlvbklkID0gY29udGVudEVsZW1lbnQuaWQgPSBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICBjb25zdCBhcmlhQXR0cmlidXRlcyA9IGF3YWl0IHRoaXMuI3N0cnVjdFRyZWVMYXllcj8uZ2V0QXJpYUF0dHJpYnV0ZXMoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvcHVwRWxlbWVudHMpIHtcbiAgICAgIHBvcHVwRWxlbWVudHMuYXQoLTEpLmNvbnRhaW5lci5hZnRlcihlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICBlbmFibGVDb21tZW50OiBwYXJhbXMuZW5hYmxlQ29tbWVudCA9PT0gdHJ1ZSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmIChkYXRhLnJlY3RbMl0gPT09IGRhdGEucmVjdFswXSB8fCBkYXRhLnJlY3RbM10gPT09IGRhdGEucmVjdFsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkLCBlbGVtZW50UGFyYW1zLmVsZW1lbnRzKTtcbiAgICAgIGVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQ/LnBvcHVwPy5yZW5kZXJDb21tZW50QnV0dG9uKCk7XG4gICAgICBpZiAoZWxlbWVudC5faXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIGFzeW5jIGFkZExpbmtBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXI6IHRoaXMuZGl2LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBkYXRhLmJvcmRlclN0eWxlIHx8PSBBbm5vdGF0aW9uTGF5ZXIuX2RlZmF1bHRCb3JkZXJTdHlsZTtcbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkLCBudWxsKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmFmdGVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZUFubm90YXRpb24gPSB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gICAgICBpZiAoIWVkaXRhYmxlQW5ub3RhdGlvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0YWJsZUFubm90YXRpb24uX2hhc05vQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnNldE1pc3NpbmdDYW52YXMoaWQsIGVsZW1lbnQuaWQsIGNhbnZhcyk7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbiAgYWRkRmFrZUFubm90YXRpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBFZGl0b3JBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZWN0OiBlZGl0b3IuZ2V0UERGUmVjdCgpLFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIGVkaXRvcixcbiAgICAgIGxheWVyOiBkaXYsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbmFibGVDb21tZW50OiAhIXRoaXMuX2NvbW1lbnRNYW5hZ2VyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlXG4gICAgfSk7XG4gICAgY29uc3QgaHRtbEVsZW1lbnQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgIGRpdi5hcHBlbmQoaHRtbEVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKGRpdiwgaHRtbEVsZW1lbnQsIGh0bWxFbGVtZW50LCBmYWxzZSk7XG4gICAgZWxlbWVudC5jcmVhdGVPclVwZGF0ZVBvcHVwKCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdEJvcmRlclN0eWxlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdEJvcmRlclN0eWxlXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgd2lkdGg6IDEsXG4gICAgICByYXdXaWR0aDogMSxcbiAgICAgIHN0eWxlOiBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElELFxuICAgICAgZGFzaEFycmF5OiBbM10sXG4gICAgICBob3Jpem9udGFsQ29ybmVyUmFkaXVzOiAwLFxuICAgICAgdmVydGljYWxDb3JuZXJSYWRpdXM6IDBcbiAgICB9KSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2ZyZWV0ZXh0LmpzXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBFT0xfUEFUVEVSTiA9IC9cXHJcXG4/fFxcbi9nO1xuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZWRpdE1vZGVBQyA9IG51bGw7XG4gICNmb250U2l6ZTtcbiAgX2NvbG9yUGlja2VyID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1mcmVldGV4dC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCB0aGlzLiNmb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy5jb2xvcl1dO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlciB8fD0gbmV3IEJhc2ljQ29sb3JQaWNrZXIodGhpcyk7XG4gICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCB0aGlzLl9jb2xvclBpY2tlcl1dO1xuICB9XG4gIGdldCBjb2xvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIGZvbnRTaXplKSxcbiAgICAgIHVuZG86IHNldEZvbnRzaXplLmJpbmQodGhpcywgc2F2ZWRGb250c2l6ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuX2NvbG9yUGlja2VyPy51cGRhdGUodGhpcy5jb2xvcik7XG4gICAgc3VwZXIub25VcGRhdGVkQ29sb3IoKTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzZXRDb2xvciA9IGNvbCA9PiB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sO1xuICAgICAgdGhpcy5vblVwZGF0ZWRDb2xvcigpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yLmJpbmQodGhpcywgY29sb3IpLFxuICAgICAgdW5kbzogc2V0Q29sb3IuYmluZCh0aGlzLCBzYXZlZENvbG9yKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXN1cGVyLmVuYWJsZUVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZWRpdE1vZGVBQyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5lZGl0b3JEaXZQYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCFzdXBlci5kaXNhYmxlRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy4jZWRpdE1vZGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbnVsbDtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBsZXQgcHJldkNoaWxkID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChwcmV2Q2hpbGQ/Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICBwcmV2Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGNvbnN0IHNhdmVkVmlzaWJpbGl0eSA9IGRpdi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIHNhdmVkVmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICBnZXQgY2FuQ2hhbmdlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dDJcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWF0dHJzXCIsIFwiZGVmYXVsdC1jb250ZW50XCIpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5lZGl0b3JEaXYpO1xuICAgIHRoaXMub3ZlcmxheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5XCIsIFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5vdmVybGF5RGl2KTtcbiAgICBpZiAodGhpcy5faXNDb3B5IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzdGF0aWMgI2dldE5vZGVDb250ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbm9kZS5ub2RlVmFsdWUgOiBub2RlLmlubmVyVGV4dCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIik7XG4gIH1cbiAgZWRpdG9yRGl2UGFzdGUoZXZlbnQpIHtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSBjbGlwYm9hcmREYXRhO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcGFzdGUgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIikgfHwgXCJcIikucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcXG5cIik7XG4gICAgaWYgKCFwYXN0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBzZWxlY3Rpb24uZGVsZXRlRnJvbURvY3VtZW50KCk7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICBpZiAoIXBhc3RlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhc3RlKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICAgIHNlbGVjdGlvbi5jb2xsYXBzZVRvU3RhcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCBidWZmZXJCZWZvcmUgPSBbXTtcbiAgICBjb25zdCBidWZmZXJBZnRlciA9IFtdO1xuICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICBidWZmZXJBZnRlci5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZShzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXJCZWZvcmUucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoaSsrID09PSBzdGFydE9mZnNldCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb250ZW50ID0gYCR7YnVmZmVyQmVmb3JlLmpvaW4oXCJcXG5cIil9JHtwYXN0ZX0ke2J1ZmZlckFmdGVyLmpvaW4oXCJcXG5cIil9YDtcbiAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICBsZXQgYmVmb3JlTGVuZ3RoID0gTWF0aC5zdW1QcmVjaXNlKGJ1ZmZlckJlZm9yZS5tYXAobGluZSA9PiBsaW5lLmxlbmd0aCkpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZm9yZUxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlbmd0aCAtPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGVudC5yZXBsYWNlQWxsKFwiXFx4YTBcIiwgXCIgXCIpO1xuICB9XG4gIHN0YXRpYyAjZGVzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKFwiIFwiLCBcIlxceGEwXCIpO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBnZXRQREZSZWN0KCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkZWZhdWx0QXBwZWFyYW5jZURhdGE6IHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgZm9udENvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIHJpY2hUZXh0LFxuICAgICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCB0ZXh0Q29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oZm9udENvbG9yKSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHZhbHVlOiB0ZXh0Q29udGVudC5qb2luKFwiXFxuXCIpLFxuICAgICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci4jY29udGVudCA9IEZyZWVUZXh0RWRpdG9yLiNkZXNlcmlhbGl6ZUNvbnRlbnQoZGF0YS52YWx1ZSk7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5pc0F0dGFjaGVkVG9ET00gPyBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWRpdG9yRGl2KS5jb2xvciA6IHRoaXMuY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBPYmplY3QuYXNzaWduKHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpLCB7XG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNzZXJpYWxpemVDb250ZW50KClcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9udFNpemUsXG4gICAgICBjb2xvcixcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5oYXNFZGl0ZWRDb21tZW50IHx8IHRoaXMuX2hhc0JlZW5Nb3ZlZCB8fCBzZXJpYWxpemVkLnZhbHVlICE9PSB2YWx1ZSB8fCBzZXJpYWxpemVkLmZvbnRTaXplICE9PSBmb250U2l6ZSB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKSB8fCBzZXJpYWxpemVkLnBhZ2VJbmRleCAhPT0gcGFnZUluZGV4O1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBjb250ZW50ID0gc3VwZXIucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGVudDtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBjb250ZW50LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHBvcHVwOiB0aGlzLl91aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSB8fCB0aGlzLmhhc0VkaXRlZENvbW1lbnQgPyB0aGlzLmNvbW1lbnQgOiB7XG4gICAgICAgIHRleHQ6IHRoaXMuI2NvbnRlbnRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBzdXBlci5yZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGFubm90YXRpb24ucmVzZXRFZGl0ZWQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9vdXRsaW5lLmpzXG5cblxuXG5cblxuY2xhc3MgT3V0bGluZSB7XG4gIHN0YXRpYyBQUkVDSVNJT04gPSAxZS00O1xuICB0b1NWR1BhdGgoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHRvU1ZHUGF0aGAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IGdldHRlciBgYm94YCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzZXJpYWxpemUoX2Jib3gsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBzZXJpYWxpemVgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZShzcmMsIHR4LCB0eSwgc3gsIHN5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBzdGF0aWMgX3Jlc2NhbGVBbmRTd2FwKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaSArIDFdICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2ldICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfdHJhbnNsYXRlKHNyYywgdHgsIHR5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldO1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBzdmdSb3VuZCh4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDEwMDAwKTtcbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBvaW50KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAvIHBhcmVudFdpZHRoLCB4IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC8gcGFyZW50V2lkdGgsIDEgLSB5IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3kgLyBwYXJlbnRXaWR0aCwgMSAtIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4IC8gcGFyZW50V2lkdGgsIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBhZ2VQb2ludCh4LCB5LCByb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHJldHVybiBbKHgxICsgNSAqIHgyKSAvIDYsICh5MSArIDUgKiB5MikgLyA2LCAoNSAqIHgyICsgeDMpIC8gNiwgKDUgKiB5MiArIHkzKSAvIDYsICh4MiArIHgzKSAvIDIsICh5MiArIHkzKSAvIDJdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2ZyZWVkcmF3LmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEZyZWVEcmF3T3V0bGluZXIge1xuICAjYm94O1xuICAjYm90dG9tID0gW107XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjdG9wID0gW107XG4gICNsYXN0ID0gbmV3IEZsb2F0MzJBcnJheSgxOCk7XG4gICNsYXN0WDtcbiAgI2xhc3RZO1xuICAjbWluO1xuICAjbWluX2Rpc3Q7XG4gICNzY2FsZUZhY3RvcjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cyA9IFtdO1xuICBzdGF0aWMgI01JTl9ESVNUID0gODtcbiAgc3RhdGljICNNSU5fRElGRiA9IDI7XG4gIHN0YXRpYyAjTUlOID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKyBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElGRjtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHgsXG4gICAgeVxuICB9LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLiNsYXN0LnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XSwgNik7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNtaW5fZGlzdCA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jbWluID0gRnJlZURyYXdPdXRsaW5lci4jTUlOICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNwb2ludHMucHVzaCh4LCB5KTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc05hTih0aGlzLiNsYXN0WzhdKTtcbiAgfVxuICAjZ2V0TGFzdENvb3JkcygpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICByZXR1cm4gWyh0aGlzLiNsYXN0WCArIChsYXN0VG9wWzBdIC0gbGFzdEJvdHRvbVswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RUb3BbMV0gLSBsYXN0Qm90dG9tWzFdKSAvIDIgLSB5KSAvIGhlaWdodCwgKHRoaXMuI2xhc3RYICsgKGxhc3RCb3R0b21bMF0gLSBsYXN0VG9wWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdEJvdHRvbVsxXSAtIGxhc3RUb3BbMV0pIC8gMiAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBhZGQoe1xuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgdGhpcy4jbGFzdFggPSB4O1xuICAgIHRoaXMuI2xhc3RZID0geTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoOCwgMTIpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KGRpZmZYLCBkaWZmWSk7XG4gICAgaWYgKGQgPCB0aGlzLiNtaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGlmZkQgPSBkIC0gdGhpcy4jbWluX2Rpc3Q7XG4gICAgY29uc3QgSyA9IGRpZmZEIC8gZDtcbiAgICBjb25zdCBzaGlmdFggPSBLICogZGlmZlg7XG4gICAgY29uc3Qgc2hpZnRZID0gSyAqIGRpZmZZO1xuICAgIGxldCB4MCA9IHgxO1xuICAgIGxldCB5MCA9IHkxO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiArPSBzaGlmdFg7XG4gICAgeTIgKz0gc2hpZnRZO1xuICAgIHRoaXMuI3BvaW50cz8ucHVzaCh4LCB5KTtcbiAgICBjb25zdCBuWCA9IC1zaGlmdFkgLyBkaWZmRDtcbiAgICBjb25zdCBuWSA9IHNoaWZ0WCAvIGRpZmZEO1xuICAgIGNvbnN0IHRoWCA9IG5YICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHRoWSA9IG5ZICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgOCksIDApO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiArIHRoWCwgeTIgKyB0aFldLCA0KTtcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCksIDEyKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgLSB0aFgsIHkyIC0gdGhZXSwgMTYpO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSkge1xuICAgICAgaWYgKHRoaXMuI3RvcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxICsgdGhYLCB5MSArIHRoWV0sIDIpO1xuICAgICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSArIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgKyB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgLSB0aFgsIHkxIC0gdGhZXSwgMTQpO1xuICAgICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSAtIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgLSB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHkwIC0geTEsIHgwIC0geDEpIC0gTWF0aC5hdGFuMihzaGlmdFksIHNoaWZ0WCkpO1xuICAgIGlmIChhbmdsZSA8IE1hdGguUEkgLyAyKSB7XG4gICAgICBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgW3gxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KTtcbiAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MCArIHgxKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIHkxKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMCwgNik7XG4gICAgdGhpcy4jdG9wLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIFt4MiwgeTIsIHgxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTIsIDE4KTtcbiAgICB0aGlzLiNib3R0b20ucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RvU1ZHUGF0aFR3b1BvaW50cygpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBidWZmZXIucHVzaChgTSR7dG9wWzRdfSAke3RvcFs1XX1gKTtcbiAgICBmb3IgKGxldCBpID0gNjsgaSA8IHRvcC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0b3BbaV19ICR7dG9wW2kgKyAxXX0gJHt0b3BbaSArIDJdfSAke3RvcFtpICsgM119ICR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhFbmQoYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBpZiAoaXNOYU4oYm90dG9tW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2JvdHRvbVtpXX0gJHtib3R0b21baSArIDFdfSAke2JvdHRvbVtpICsgMl19ICR7Ym90dG9tW2kgKyAzXX0gJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICAjdG9TVkdQYXRoVHdvUG9pbnRzKCkge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIHJldHVybiBgTSR7KHRoaXMuI2xhc3RbMl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzNdIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFs1XSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyh0aGlzLiNsYXN0WzE2XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTddIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzE0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTVdIC0geSkgLyBoZWlnaHR9IFpgO1xuICB9XG4gICN0b1NWR1BhdGhTdGFydChidWZmZXIpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVs0XX0gJHtib3R0b21bNV19IFpgKTtcbiAgfVxuICAjdG9TVkdQYXRoRW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgYnVmZmVyLnB1c2goYEwkeyhsYXN0VG9wWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdFRvcFsxXSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyhsYXN0Qm90dG9tWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdEJvdHRvbVsxXSAtIHkpIC8gaGVpZ2h0fWApO1xuICB9XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKTtcbiAgfVxuICBnZXRPdXRsaW5lcygpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoKHRoaXMuI3BvaW50cz8ubGVuZ3RoID8/IDApICsgMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aCAtIDI7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAodGhpcy4jcG9pbnRzW2ldIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHRoaXMuI3BvaW50c1tpICsgMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgfVxuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gPSAodGhpcy4jbGFzdFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0gKHRoaXMuI2xhc3RZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIGlmIChpc05hTihsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuI3RvcC5sZW5ndGggKyAyNCArIHRoaXMuI2JvdHRvbS5sZW5ndGgpO1xuICAgIGxldCBOID0gdG9wLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkgKz0gMikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgb3V0bGluZVtpXSA9IG91dGxpbmVbaSArIDFdID0gTmFOO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVbaV0gPSB0b3BbaV07XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IHRvcFtpICsgMV07XG4gICAgfVxuICAgIE4gPSB0aGlzLiNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIE4pO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG4gICAgICAgIGlmIChpc05hTihib3R0b21baSArIGpdKSkge1xuICAgICAgICAgIG91dGxpbmVbTl0gPSBvdXRsaW5lW04gKyAxXSA9IE5hTjtcbiAgICAgICAgICBOICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0bGluZVtOXSA9IGJvdHRvbVtpICsgal07XG4gICAgICAgIG91dGxpbmVbTiArIDFdID0gYm90dG9tW2kgKyBqICsgMV07XG4gICAgICAgIE4gKz0gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIE4pO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzNik7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbM10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTddIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCAwKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIGJvdHRvbVs0XSwgYm90dG9tWzVdXSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDY7XG4gIH1cbiAgI2dldE91dGxpbmVFbmQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0VG9wWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0VG9wWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RCb3R0b21bMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RCb3R0b21bMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gMjQ7XG4gIH1cbn1cbmNsYXNzIEZyZWVEcmF3T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjYmJveCA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjcG9pbnRzO1xuICAjc2NhbGVGYWN0b3I7XG4gICNvdXRsaW5lO1xuICBjb25zdHJ1Y3RvcihvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZSA9IG91dGxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLmZpcnN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIHRoaXMubGFzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB0aGlzLiNjb21wdXRlTWluTWF4KGlzTFRSKTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgb3V0bGluZVtpXSA9IChvdXRsaW5lW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gKG91dGxpbmVbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAocG9pbnRzW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAocG9pbnRzW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW2BNJHt0aGlzLiNvdXRsaW5lWzRdfSAke3RoaXMuI291dGxpbmVbNV19YF07XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gdGhpcy4jb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy4jb3V0bGluZVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0aGlzLiNvdXRsaW5lW2ldfSAke3RoaXMuI291dGxpbmVbaSArIDFdfSAke3RoaXMuI291dGxpbmVbaSArIDJdfSAke3RoaXMuI291dGxpbmVbaSArIDNdfSAke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgIH1cbiAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIHJvdGF0aW9uKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGxldCBvdXRsaW5lO1xuICAgIGxldCBwb2ludHM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lOiBBcnJheS5mcm9tKG91dGxpbmUpLFxuICAgICAgcG9pbnRzOiBbQXJyYXkuZnJvbShwb2ludHMpXVxuICAgIH07XG4gIH1cbiAgI2NvbXB1dGVNaW5NYXgoaXNMVFIpIHtcbiAgICBjb25zdCBvdXRsaW5lID0gdGhpcy4jb3V0bGluZTtcbiAgICBsZXQgbGFzdFggPSBvdXRsaW5lWzRdO1xuICAgIGxldCBsYXN0WSA9IG91dGxpbmVbNV07XG4gICAgY29uc3QgbWluTWF4ID0gW2xhc3RYLCBsYXN0WSwgbGFzdFgsIGxhc3RZXTtcbiAgICBsZXQgZmlyc3RQb2ludFggPSBsYXN0WDtcbiAgICBsZXQgZmlyc3RQb2ludFkgPSBsYXN0WTtcbiAgICBsZXQgbGFzdFBvaW50WCA9IGxhc3RYO1xuICAgIGxldCBsYXN0UG9pbnRZID0gbGFzdFk7XG4gICAgY29uc3QgbHRyQ2FsbGJhY2sgPSBpc0xUUiA/IE1hdGgubWF4IDogTWF0aC5taW47XG4gICAgY29uc3QgYmV6aWVyQmJveCA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCB4ID0gb3V0bGluZVtpICsgNF0sXG4gICAgICAgIHkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3goeCwgeSwgbWluTWF4KTtcbiAgICAgICAgaWYgKGZpcnN0UG9pbnRZID4geSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0geDtcbiAgICAgICAgICBmaXJzdFBvaW50WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RQb2ludFkgPT09IHkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IGx0ckNhbGxiYWNrKGZpcnN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvaW50WSA8IHkpIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgICBsYXN0UG9pbnRZID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UG9pbnRZID09PSB5KSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGx0ckNhbGxiYWNrKGxhc3RQb2ludFgsIHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXppZXJCYm94WzBdID0gYmV6aWVyQmJveFsxXSA9IEluZmluaXR5O1xuICAgICAgICBiZXppZXJCYm94WzJdID0gYmV6aWVyQmJveFszXSA9IC1JbmZpbml0eTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIC4uLm91dGxpbmUuc2xpY2UoaSwgaSArIDYpLCBiZXppZXJCYm94KTtcbiAgICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goYmV6aWVyQmJveFswXSwgYmV6aWVyQmJveFsxXSwgYmV6aWVyQmJveFsyXSwgYmV6aWVyQmJveFszXSwgbWluTWF4KTtcbiAgICAgICAgaWYgKGZpcnN0UG9pbnRZID4gYmV6aWVyQmJveFsxXSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gYmV6aWVyQmJveFswXTtcbiAgICAgICAgICBmaXJzdFBvaW50WSA9IGJlemllckJib3hbMV07XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RQb2ludFkgPT09IGJlemllckJib3hbMV0pIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IGx0ckNhbGxiYWNrKGZpcnN0UG9pbnRYLCBiZXppZXJCYm94WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvaW50WSA8IGJlemllckJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gYmV6aWVyQmJveFsyXTtcbiAgICAgICAgICBsYXN0UG9pbnRZID0gYmV6aWVyQmJveFszXTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UG9pbnRZID09PSBiZXppZXJCYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGx0ckNhbGxiYWNrKGxhc3RQb2ludFgsIGJlemllckJib3hbMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0WCA9IHg7XG4gICAgICBsYXN0WSA9IHk7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gPSBtaW5NYXhbMF0gLSB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICBiYm94WzFdID0gbWluTWF4WzFdIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsyXSA9IG1pbk1heFsyXSAtIG1pbk1heFswXSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICBiYm94WzNdID0gbWluTWF4WzNdIC0gbWluTWF4WzFdICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIHRoaXMuZmlyc3RQb2ludCA9IFtmaXJzdFBvaW50WCwgZmlyc3RQb2ludFldO1xuICAgIHRoaXMubGFzdFBvaW50ID0gW2xhc3RQb2ludFgsIGxhc3RQb2ludFldO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3g7XG4gIH1cbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZURyYXdPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4pO1xuICB9XG4gIGdldE5ld091dGxpbmUodGhpY2tuZXNzLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3Qgc3ggPSB3aWR0aCAqIGxheWVyV2lkdGg7XG4gICAgY29uc3Qgc3kgPSBoZWlnaHQgKiBsYXllckhlaWdodDtcbiAgICBjb25zdCB0eCA9IHggKiBsYXllcldpZHRoICsgbGF5ZXJYO1xuICAgIGNvbnN0IHR5ID0geSAqIGxheWVySGVpZ2h0ICsgbGF5ZXJZO1xuICAgIGNvbnN0IG91dGxpbmVyID0gdGhpcy5uZXdPdXRsaW5lcih7XG4gICAgICB4OiB0aGlzLiNwb2ludHNbMF0gKiBzeCArIHR4LFxuICAgICAgeTogdGhpcy4jcG9pbnRzWzFdICogc3kgKyB0eVxuICAgIH0sIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgdGhpcy4jaXNMVFIsIGlubmVyTWFyZ2luID8/IHRoaXMuI2lubmVyTWFyZ2luKTtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRoaXMuI3BvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgb3V0bGluZXIuYWRkKHtcbiAgICAgICAgeDogdGhpcy4jcG9pbnRzW2ldICogc3ggKyB0eCxcbiAgICAgICAgeTogdGhpcy4jcG9pbnRzW2kgKyAxXSAqIHN5ICsgdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIEhpZ2hsaWdodE91dGxpbmVyIHtcbiAgI2JveDtcbiAgI2ZpcnN0UG9pbnQ7XG4gICNsYXN0UG9pbnQ7XG4gICN2ZXJ0aWNhbEVkZ2VzID0gW107XG4gICNpbnRlcnZhbHMgPSBbXTtcbiAgY29uc3RydWN0b3IoYm94ZXMsIGJvcmRlcldpZHRoID0gMCwgaW5uZXJNYXJnaW4gPSAwLCBpc0xUUiA9IHRydWUpIHtcbiAgICBjb25zdCBtaW5NYXggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgY29uc3QgTlVNQkVSX09GX0RJR0lUUyA9IDQ7XG4gICAgY29uc3QgRVBTSUxPTiA9IDEwICoqIC1OVU1CRVJfT0ZfRElHSVRTO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHgxID0gTWF0aC5mbG9vcigoeCAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh4ICsgd2lkdGggKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MSA9IE1hdGguZmxvb3IoKHkgLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgoeSArIGhlaWdodCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IGxlZnQgPSBbeDEsIHkxLCB5MiwgdHJ1ZV07XG4gICAgICBjb25zdCByaWdodCA9IFt4MiwgeTEsIHkyLCBmYWxzZV07XG4gICAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnB1c2gobGVmdCwgcmlnaHQpO1xuICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goeDEsIHkxLCB4MiwgeTIsIG1pbk1heCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1pbk1heFsyXSAtIG1pbk1heFswXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0gbWluTWF4WzNdIC0gbWluTWF4WzFdICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5YID0gbWluTWF4WzBdIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblkgPSBtaW5NYXhbMV0gLSBpbm5lck1hcmdpbjtcbiAgICBsZXQgZmlyc3RQb2ludFggPSBpc0xUUiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgIGxldCBmaXJzdFBvaW50WSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGxhc3RFZGdlID0gdGhpcy4jdmVydGljYWxFZGdlcy5hdChpc0xUUiA/IC0xIDogLTIpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IFtsYXN0RWRnZVswXSwgbGFzdEVkZ2VbMl1dO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLiN2ZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBjb25zdCBbeCwgeTEsIHkyLCBsZWZ0XSA9IGVkZ2U7XG4gICAgICBpZiAoIWxlZnQgJiYgaXNMVFIpIHtcbiAgICAgICAgaWYgKHkxIDwgZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WSA9IHkxO1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh5MSA9PT0gZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IE1hdGgubWF4KGZpcnN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZWZ0ICYmICFpc0xUUikge1xuICAgICAgICBpZiAoeTEgPCBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRZID0geTE7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKHkxID09PSBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gTWF0aC5taW4oZmlyc3RQb2ludFgsIHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlZGdlWzBdID0gKHggLSBzaGlmdGVkTWluWCkgLyBiYm94V2lkdGg7XG4gICAgICBlZGdlWzFdID0gKHkxIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICAgIGVkZ2VbMl0gPSAoeTIgLSBzaGlmdGVkTWluWSkgLyBiYm94SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLiNib3ggPSBuZXcgRmxvYXQzMkFycmF5KFtzaGlmdGVkTWluWCwgc2hpZnRlZE1pblksIGJib3hXaWR0aCwgYmJveEhlaWdodF0pO1xuICAgIHRoaXMuI2ZpcnN0UG9pbnQgPSBbZmlyc3RQb2ludFgsIGZpcnN0UG9pbnRZXTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZXMucHVzaChbeCwgeTEsIGVkZ2VdLCBbeCwgeTIsIGVkZ2VdKTtcbiAgICB9XG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0gfHwgYVswXSAtIGJbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVkZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGVkZ2UxID0gZWRnZXNbaV1bMl07XG4gICAgICBjb25zdCBlZGdlMiA9IGVkZ2VzW2kgKyAxXVsyXTtcbiAgICAgIGVkZ2UxLnB1c2goZWRnZTIpO1xuICAgICAgZWRnZTIucHVzaChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UyKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICB3aGlsZSAoYWxsRWRnZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSBhbGxFZGdlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBsZXQgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGVkZ2U7XG4gICAgICBhbGxFZGdlcy5kZWxldGUoZWRnZSk7XG4gICAgICBsZXQgbGFzdFBvaW50WCA9IHg7XG4gICAgICBsZXQgbGFzdFBvaW50WSA9IHkxO1xuICAgICAgb3V0bGluZSA9IFt4LCB5Ml07XG4gICAgICBvdXRsaW5lcy5wdXNoKG91dGxpbmUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmIChhbGxFZGdlcy5oYXMoZWRnZTEpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UxO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMikpIHtcbiAgICAgICAgICBlID0gZWRnZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRWRnZXMuZGVsZXRlKGUpO1xuICAgICAgICBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFggIT09IHgpIHtcbiAgICAgICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSwgeCwgbGFzdFBvaW50WSA9PT0geTEgPyB5MSA6IHkyKTtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gbGFzdFBvaW50WSA9PT0geTEgPyB5MiA6IHkxO1xuICAgICAgfVxuICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhpZ2hsaWdodE91dGxpbmUob3V0bGluZXMsIHRoaXMuI2JveCwgdGhpcy4jZmlyc3RQb2ludCwgdGhpcy4jbGFzdFBvaW50KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLmZpcnN0UG9pbnQgPSBmaXJzdFBvaW50O1xuICAgIHRoaXMubGFzdFBvaW50ID0gbGFzdFBvaW50O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgdGhpcy4jb3V0bGluZXMpIHtcbiAgICAgIGxldCBbcHJldlgsIHByZXZZXSA9IHBvbHlnb247XG4gICAgICBidWZmZXIucHVzaChgTSR7cHJldlh9ICR7cHJldll9YCk7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeCA9IHBvbHlnb25baV07XG4gICAgICAgIGNvbnN0IHkgPSBwb2x5Z29uW2kgKyAxXTtcbiAgICAgICAgaWYgKHggPT09IHByZXZYKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goYFYke3l9YCk7XG4gICAgICAgICAgcHJldlkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKHkgPT09IHByZXZZKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goYEgke3h9YCk7XG4gICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtibFgsIGJsWSwgdHJYLCB0clldLCBfcm90YXRpb24pIHtcbiAgICBjb25zdCBvdXRsaW5lcyA9IFtdO1xuICAgIGNvbnN0IHdpZHRoID0gdHJYIC0gYmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyWSAtIGJsWTtcbiAgICBmb3IgKGNvbnN0IG91dGxpbmUgb2YgdGhpcy4jb3V0bGluZXMpIHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBBcnJheShvdXRsaW5lLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxpbmUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnRzW2ldID0gYmxYICsgb3V0bGluZVtpXSAqIHdpZHRoO1xuICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gb3V0bGluZVtpICsgMV0gKiBoZWlnaHQ7XG4gICAgICB9XG4gICAgICBvdXRsaW5lcy5wdXNoKHBvaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNib3g7XG4gIH1cbiAgZ2V0IGNsYXNzTmFtZXNGb3JPdXRsaW5pbmcoKSB7XG4gICAgcmV0dXJuIFtcImhpZ2hsaWdodE91dGxpbmVcIl07XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lciBleHRlbmRzIEZyZWVEcmF3T3V0bGluZXIge1xuICBuZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICByZXR1cm4gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKTtcbiAgfVxufVxuY2xhc3MgRnJlZUhpZ2hsaWdodE91dGxpbmUgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmUge1xuICBuZXdPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvaGlnaGxpZ2h0LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjZmlyc3RQb2ludCA9IG51bGw7XG4gICNsYXN0UG9pbnQgPSBudWxsO1xuICAjb3V0bGluZUlkID0gbnVsbDtcbiAgI3RleHQgPSBcIlwiO1xuICAjdGhpY2tuZXNzO1xuICAjbWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCI7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfZGVmYXVsdFRoaWNrbmVzcyA9IDEyO1xuICBzdGF0aWMgX3R5cGUgPSBcImhpZ2hsaWdodFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEhpZ2hsaWdodEVkaXRvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFswXVxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMV1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzJdXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbM11cbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImhpZ2hsaWdodEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSBwYXJhbXMudGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICB0aGlzLm9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1oaWdobGlnaHQtZWRpdG9yXCI7XG4gICAgaWYgKHBhcmFtcy5oaWdobGlnaHRJZCA+IC0xKSB7XG4gICAgICB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jYm94ZXMpIHtcbiAgICAgIHRoaXMuI2FuY2hvck5vZGUgPSBwYXJhbXMuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMuI2FuY2hvck9mZnNldCA9IHBhcmFtcy5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLiNmb2N1c05vZGUgPSBwYXJhbXMuZm9jdXNOb2RlO1xuICAgICAgdGhpcy4jZm9jdXNPZmZzZXQgPSBwYXJhbXMuZm9jdXNPZmZzZXQ7XG4gICAgICB0aGlzLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIHRoaXMucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1oaWdobGlnaHQtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCIsXG4gICAgICB0eXBlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyBcImZyZWVfaGlnaGxpZ2h0XCIgOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUodGhpcy5jb2xvciksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIG1ldGhvZE9mQ3JlYXRpb246IHRoaXMuI21ldGhvZE9mQ3JlYXRpb25cbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZSh0aGlzLmNvbG9yKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXJPZkNvbG9yczogZGF0YS5nZXQoXCJjb2xvclwiKS5zaXplXG4gICAgfTtcbiAgfVxuICAjY3JlYXRlT3V0bGluZXMoKSB7XG4gICAgY29uc3Qgb3V0bGluZXIgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAxKTtcbiAgICB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcyA9IG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gICAgW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0gPSB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgY29uc3Qgb3V0bGluZXJGb3JPdXRsaW5lID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMjUsIDAuMDAxLCB0aGlzLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgICB0aGlzLiNmb2N1c091dGxpbmVzID0gb3V0bGluZXJGb3JPdXRsaW5lLmdldE91dGxpbmVzKCk7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RQb2ludFxuICAgIH0gPSB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcztcbiAgICB0aGlzLiNmaXJzdFBvaW50ID0gWyhmaXJzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChmaXJzdFBvaW50WzFdIC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHRoaXMueCkgLyB0aGlzLndpZHRoLCAobGFzdFBvaW50WzFdIC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0XTtcbiAgfVxuICAjY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICBoaWdobGlnaHRPdXRsaW5lcyxcbiAgICBoaWdobGlnaHRJZCxcbiAgICBjbGlwUGF0aElkXG4gIH0pIHtcbiAgICB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzO1xuICAgIGNvbnN0IGV4dHJhVGhpY2tuZXNzID0gMS41O1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaXMuI3RoaWNrbmVzcyAvIDIgKyBleHRyYVRoaWNrbmVzcywgMC4wMDI1KTtcbiAgICBpZiAoaGlnaGxpZ2h0SWQgPj0gMCkge1xuICAgICAgdGhpcy4jaWQgPSBoaWdobGlnaHRJZDtcbiAgICAgIHRoaXMuI2NsaXBQYXRoSWQgPSBjbGlwUGF0aElkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhoaWdobGlnaHRJZCwge1xuICAgICAgICBiYm94OiBoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBoaWdobGlnaHRPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI291dGxpbmVJZCA9IHRoaXMucGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuI2ZvY3VzT3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSB5O1xuICAgICAgICAgIHRoaXMueSA9IDEgLSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ID0gMSAtIHg7XG4gICAgICAgIHRoaXMueSA9IDEgLSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy54ID0gMSAtIHk7XG4gICAgICAgICAgdGhpcy55ID0geDtcbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGFnZVdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmaXJzdFBvaW50XG4gICAgfSA9IGhpZ2hsaWdodE91dGxpbmVzO1xuICAgIHRoaXMuI2ZpcnN0UG9pbnQgPSBbKGZpcnN0UG9pbnRbMF0gLSB4KSAvIHdpZHRoLCAoZmlyc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChsYXN0UG9pbnRbMV0gLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHw9IHVpTWFuYWdlci5oaWdobGlnaHRDb2xvcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNmZmYwNjZcIjtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7fVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jZmlyc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIHRoaXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgdGhpcy4jdGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XV07XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICByb290OiB7XG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMub3BhY2l0eVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy51cGRhdGVDb2xvcih0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yQW5kT3BhY2l0eSA9IChjb2wsIG9wYSkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMub3BhY2l0eSA9IG9wYTtcbiAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgY29sb3IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHkpLFxuICAgICAgdW5kbzogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgc2F2ZWRDb2xvciwgc2F2ZWRPcGFjaXR5KSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiY29sb3JfY2hhbmdlZFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvck5hbWUoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB0aDtcbiAgICAgIHRoaXMuI2NoYW5nZVRoaWNrbmVzcyh0aCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgdGhpY2tuZXNzKSxcbiAgICAgIHVuZG86IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHNhdmVkVGhpY2tuZXNzKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInRoaWNrbmVzc19jaGFuZ2VkXCIsXG4gICAgICB0aGlja25lc3NcbiAgICB9LCB0cnVlKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGNvbG9yUGlja2VyID0gdGhpcy4jY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIoe1xuICAgICAgICBlZGl0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtbXCJjb2xvclBpY2tlclwiLCBjb2xvclBpY2tlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudG9vbGJhckJ1dHRvbnM7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gc3VwZXIuZml4QW5kU2V0UG9zaXRpb24odGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0UmVjdCh0eCwgdHksIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImRlbGV0ZWRcIlxuICAgIH0pO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIHRoaXMuc2hvdyh0aGlzLl9pc1Zpc2libGUpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NoYW5nZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBpZiAoIXRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpY2tuZXNzIC8gMilcbiAgICB9KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICAjY2xlYW5EcmF3TGF5ZXIoKSB7XG4gICAgaWYgKHRoaXMuI2lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI2lkKTtcbiAgICB0aGlzLiNpZCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNvdXRsaW5lSWQpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IG51bGw7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuI2lkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBpZDogdGhpcy4jaWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLiNjbGlwUGF0aElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0aGlzLm9wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgZmFsc2UsIHRydWUpKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBwYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lOiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCk7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodERpdikge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNyb3RhdGVCYm94KFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYXdMYXllclxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBsZXQgYm94O1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGFuZ2xlID0gKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjA7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveChbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSwgYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgYmJveDogYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICBcImRhdGEtbWFpbi1yb3RhdGlvblwiOiBhbmdsZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy4jdGV4dCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jdGV4dCk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1hcmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGhpZ2hsaWdodERpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy4jaGlnaGxpZ2h0RGl2LCBbXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJsZWF2ZVwiXSk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBwb2ludGVyb3ZlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwb2ludGVybGVhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaG92ZXJlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNrZXlkb3duKGV2ZW50KSB7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgX21vdmVDYXJldChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnBhcmVudC51bnNlbGVjdCh0aGlzKTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLiNzZXRDYXJldCh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNzZXRDYXJldChzdGFydCkge1xuICAgIGlmICghdGhpcy4jYW5jaG9yTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jYW5jaG9yTm9kZSwgdGhpcy4jYW5jaG9yT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2ZvY3VzTm9kZSwgdGhpcy4jZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgc3VwZXIuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBzZWxlY3RlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHN1cGVyLnVuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy4jaXNGcmVlSGlnaGxpZ2h0O1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHN1cGVyLnNob3codmlzaWJsZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWRkZW46ICF2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gdGhpcy5yb3RhdGlvbiA6IDA7XG4gIH1cbiAgI3NlcmlhbGl6ZUJveGVzKCkge1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuI2JveGVzO1xuICAgIGNvbnN0IHF1YWRQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGJveGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCBzeCA9IHggKiBwYWdlV2lkdGggKyBwYWdlWDtcbiAgICAgIGNvbnN0IHN5ID0gKDEgLSB5KSAqIHBhZ2VIZWlnaHQgKyBwYWdlWTtcbiAgICAgIHF1YWRQb2ludHNbaV0gPSBxdWFkUG9pbnRzW2kgKyA0XSA9IHN4O1xuICAgICAgcXVhZFBvaW50c1tpICsgMV0gPSBxdWFkUG9pbnRzW2kgKyAzXSA9IHN5O1xuICAgICAgcXVhZFBvaW50c1tpICsgMl0gPSBxdWFkUG9pbnRzW2kgKyA2XSA9IHN4ICsgd2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBxdWFkUG9pbnRzW2kgKyA1XSA9IHF1YWRQb2ludHNbaSArIDddID0gc3kgLSBoZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgICAgaSArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplT3V0bGluZXMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5zZXJpYWxpemUocmVjdCwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgc3RhdGljIHN0YXJ0SGlnaGxpZ2h0aW5nKHBhcmVudCwgaXNMVFIsIHtcbiAgICB0YXJnZXQ6IHRleHRMYXllcixcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBwYXJlbnQuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy4jZW5kSGlnaGxpZ2h0KHBhcmVudCwgZSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0ZXh0TGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2hpZ2hsaWdodE1vdmUuYmluZCh0aGlzLCBwYXJlbnQpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcih7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0sIFtsYXllclgsIGxheWVyWSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0sIHBhcmVudC5zY2FsZSwgdGhpcy5fZGVmYXVsdFRoaWNrbmVzcyAvIDIsIGlzTFRSLCAwLjAwMSk7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV0sXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLl9kZWZhdWx0Q29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuX2RlZmF1bHRPcGFjaXR5XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRydWUsIHRydWUpKTtcbiAgfVxuICBzdGF0aWMgI2hpZ2hsaWdodE1vdmUocGFyZW50LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9mcmVlSGlnaGxpZ2h0LmFkZChldmVudCkpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZW5kSGlnaGxpZ2h0KHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZyZWVIaWdobGlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBoaWdobGlnaHRJZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy5fZnJlZUhpZ2hsaWdodC5nZXRPdXRsaW5lcygpLFxuICAgICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkLFxuICAgICAgICBtZXRob2RPZkNyZWF0aW9uOiBcIm1haW5fdG9vbGJhclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZnJlZUhpZ2hsaWdodElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgICBjb250ZW50c09iaixcbiAgICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsLFxuICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIHJpY2hUZXh0LFxuICAgICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGwsXG4gICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICBvcGFjaXR5XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICBlZGl0b3Iub3BhY2l0eSA9IG9wYWNpdHkgfHwgMTtcbiAgICBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jdGhpY2tuZXNzID0gZGF0YS50aGlja25lc3M7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gZWRpdG9yLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBpZiAocXVhZFBvaW50cykge1xuICAgICAgY29uc3QgYm94ZXMgPSBlZGl0b3IuI2JveGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRQb2ludHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgYm94ZXMucHVzaCh7XG4gICAgICAgICAgeDogKHF1YWRQb2ludHNbaV0gLSBwYWdlWCkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgeTogMSAtIChxdWFkUG9pbnRzW2kgKyAxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IChxdWFkUG9pbnRzW2kgKyAyXSAtIHF1YWRQb2ludHNbaV0pIC8gcGFnZVdpZHRoLFxuICAgICAgICAgIGhlaWdodDogKHF1YWRQb2ludHNbaSArIDFdIC0gcXVhZFBvaW50c1tpICsgNV0pIC8gcGFnZUhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci4jY3JlYXRlT3V0bGluZXMoKTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIGVkaXRvci5yb3RhdGUoZWRpdG9yLnJvdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICBjb25zdCBwb2ludHMgPSBpbmtMaXN0c1swXTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludHNbMF0gLSBwYWdlWCxcbiAgICAgICAgeTogcGFnZUhlaWdodCAtIChwb2ludHNbMV0gLSBwYWdlWSlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIocG9pbnQsIFswLCAwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCAxLCBlZGl0b3IuI3RoaWNrbmVzcyAvIDIsIHRydWUsIDAuMDAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50LnggPSBwb2ludHNbaV0gLSBwYWdlWDtcbiAgICAgICAgcG9pbnQueSA9IHBhZ2VIZWlnaHQgLSAocG9pbnRzW2kgKyAxXSAtIHBhZ2VZKTtcbiAgICAgICAgb3V0bGluZXIuYWRkKHBvaW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNsaXBQYXRoSWRcbiAgICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoe1xuICAgICAgICBiYm94OiBbMCwgMCwgMSwgMV0sXG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAxIDFcIixcbiAgICAgICAgICBmaWxsOiBlZGl0b3IuY29sb3IsXG4gICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogZWRpdG9yLl9kZWZhdWx0T3BhY2l0eVxuICAgICAgICB9LFxuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogb3V0bGluZXIudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBlZGl0b3IuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiBvdXRsaW5lci5nZXRPdXRsaW5lcygpLFxuICAgICAgICBoaWdobGlnaHRJZDogaWQsXG4gICAgICAgIGNsaXBQYXRoSWRcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3IucGFyZW50Um90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSB8fCBpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yKHRoaXMuY29sb3IpKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyk7XG4gICAgT2JqZWN0LmFzc2lnbihzZXJpYWxpemVkLCB7XG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgcXVhZFBvaW50czogdGhpcy4jc2VyaWFsaXplQm94ZXMoKSxcbiAgICAgIG91dGxpbmVzOiB0aGlzLiNzZXJpYWxpemVPdXRsaW5lcyhzZXJpYWxpemVkLnJlY3QpXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yXG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcG9wdXA6IHRoaXMuY29tbWVudFxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXcuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBEcmF3aW5nT3B0aW9ucyB7XG4gICNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgaWYgKCFuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICB0b1NWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI3N2Z1Byb3BlcnRpZXM7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RcbiAgICB9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHVwZGF0ZUFsbChvcHRpb25zID0gdGhpcykge1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufVxuY2xhc3MgRHJhd2luZ0VkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjZHJhd091dGxpbmVzID0gbnVsbDtcbiAgI211c3RCZUNvbW1pdHRlZDtcbiAgX2NvbG9yUGlja2VyID0gbnVsbDtcbiAgX2RyYXdJZCA9IG51bGw7XG4gIHN0YXRpYyBfY3VycmVudERyYXdJZCA9IC0xO1xuICBzdGF0aWMgX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3ID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ0FDID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWQgPSBOYU47XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlcklkcyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudE1vdmVUaW1lc3RhbXAgPSBOYU47XG4gIHN0YXRpYyBfSU5ORVJfTUFSR0lOID0gMztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLiNtdXN0QmVDb21taXR0ZWQgPSBwYXJhbXMubXVzdEJlQ29tbWl0dGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuX2FkZE91dGxpbmVzKHBhcmFtcyk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXI/LnVwZGF0ZSh0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gIF9hZGRPdXRsaW5lcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmRyYXdPdXRsaW5lcykge1xuICAgICAgdGhpcy4jY3JlYXRlRHJhd091dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH1cbiAgfVxuICAjY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICBkcmF3T3V0bGluZXMsXG4gICAgZHJhd0lkLFxuICAgIGRyYXdpbmdPcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLiNkcmF3T3V0bGluZXMgPSBkcmF3T3V0bGluZXM7XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgfHw9IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KGBwZGZqcy1lZGl0b3ItJHt0aGlzLmVkaXRvclR5cGV9LWFkZGVkLWFsZXJ0YCk7XG4gICAgfVxuICAgIGlmIChkcmF3SWQgPj0gMCkge1xuICAgICAgdGhpcy5fZHJhd0lkID0gZHJhd0lkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhkcmF3SWQsIGRyYXdPdXRsaW5lcy5kZWZhdWx0UHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3goZHJhd091dGxpbmVzLmJveCk7XG4gIH1cbiAgI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBkcmF3T3V0bGluZXMuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBzdGF0aWMgX21lcmdlU1ZHUHJvcGVydGllcyhwMSwgcDIpIHtcbiAgICBjb25zdCBwMUtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHAxKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocDIpKSB7XG4gICAgICBpZiAocDFLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocDFba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDE7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhfb3B0aW9ucykge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0eSh0eXBlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgb3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIF9kcmF3aW5nT3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBfdXBkYXRlUHJvcGVydHkodHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZHJhd2luZ09wdGlvbnM7XG4gICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IG9wdGlvbnNbbmFtZV07XG4gICAgY29uc3Qgc2V0dGVyID0gdmFsID0+IHtcbiAgICAgIG9wdGlvbnMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHRoaXMuI3VwZGF0ZUJib3goYmJveCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBvcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgICAgIGlmICh0eXBlID09PSB0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlZENvbG9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0dGVyLmJpbmQodGhpcywgdmFsdWUpLFxuICAgICAgdW5kbzogc2V0dGVyLmJpbmQodGhpcywgc2F2ZWRWYWx1ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKF94LCBfeSkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSwgdGhpcy5wYXJlbnREaW1lbnNpb25zKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgbW92aW5nOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX29uU3RvcERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKGZvY3VzICYmIHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgdGhpcy5zZXREaW1zKCk7XG4gICAgfVxuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gICNyb3RhdGVCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyZW50Um90YXRpb24sXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAoKHJvdGF0aW9uICogNCArIHBhcmVudFJvdGF0aW9uKSAvIDkwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIFt4LCB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIGhlaWdodCAqIChwSCAvIHBXKSwgMSAtIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gW3kgLSB3aWR0aCAqIChwVyAvIHBIKSwgMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gW3ggLSB3aWR0aCwgeSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDk6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDExOlxuICAgICAgICByZXR1cm4gW3kgLSBoZWlnaHQsIDEgLSB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHJldHVybiBbeCAtIGhlaWdodCAqIChwSCAvIHBXKSwgeSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gIHJvdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSwgdGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVJvdGF0aW9uKCh0aGlzLnBhcmVudFJvdGF0aW9uIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApKSk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUGFyZW50RGltZW5zaW9ucyh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHRoaXMucGFyZW50LnNjYWxlKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge31cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcbiAgICBjb25zdCBkcmF3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGRyYXdEaXYpO1xuICAgIGRyYXdEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGRyYXdEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZShfeCwgX3ksIF9wYXJlbnRXaWR0aCwgX3BhcmVudEhlaWdodCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIHN0YXJ0RHJhd2luZyhwYXJlbnQsIHVpTWFuYWdlciwgX2lzTFRSLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9mZnNldFg6IHgsXG4gICAgICBvZmZzZXRZOiB5LFxuICAgICAgcG9pbnRlcklkLFxuICAgICAgcG9pbnRlclR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAmJiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgIT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCB8fD0gcG9pbnRlcklkO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA/Pz0gcG9pbnRlclR5cGU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgdGhpcy5fZW5kRHJhdyhlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmVuZERyYXdpbmdTZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgfHw9IG5ldyBTZXQoKSkuYWRkKGUucG9pbnRlcklkKTtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzRW1wdHkoKSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW5kRHJhdyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9kcmF3TW92ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBlID0+IHtcbiAgICAgIGlmIChlLnRpbWVTdGFtcCA9PT0gRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXApIHtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKCk7XG4gICAgdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdWlNYW5hZ2VyLnVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXModGhpcyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSB0aGlzLmNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSB0aGlzLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9jdXJyZW50RHJhd0lkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh0aGlzLl9tZXJnZVNWR1Byb3BlcnRpZXMoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIHRydWUsIGZhbHNlKSk7XG4gIH1cbiAgc3RhdGljIF9kcmF3TW92ZShldmVudCkge1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gLTE7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBvaW50ZXJJZFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCAhPT0gcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uc2l6ZSA+PSAxKSB7XG4gICAgICB0aGlzLl9lbmREcmF3KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5hZGQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gIH1cbiAgc3RhdGljIF9jbGVhbnVwKGFsbCkge1xuICAgIGlmIChhbGwpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMuYWJvcnQoKTtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9lbmREcmF3KGV2ZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAoZXZlbnQ/LnRhcmdldCA9PT0gcGFyZW50LmRpdikge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICBjb25zdCBkcmF3ID0gRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXc7XG4gICAgICBjb25zdCBkcmF3SWQgPSB0aGlzLl9jdXJyZW50RHJhd0lkO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkcmF3LmdldExhc3RFbGVtZW50KCk7XG4gICAgICBwYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnNldExhc3RFbGVtZW50KGxhc3RFbGVtZW50KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnJlbW92ZUxhc3RFbGVtZW50KCkpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5kRHJhd2luZyhmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGVuZERyYXdpbmcoaXNBYm9ydGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHBhcmVudC5jbGVhblVuZG9TdGFjayhBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5EUkFXX1NURVApO1xuICAgIGlmICghRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSxcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBwYXJlbnQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgZHJhd0lkOiB0aGlzLl9jdXJyZW50RHJhd0lkLFxuICAgICAgICBkcmF3T3V0bGluZXM6IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmdldE91dGxpbmVzKHBhZ2VXaWR0aCAqIHNjYWxlLCBwYWdlSGVpZ2h0ICogc2NhbGUsIHNjYWxlLCB0aGlzLl9JTk5FUl9NQVJHSU4pLFxuICAgICAgICBkcmF3aW5nT3B0aW9uczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLFxuICAgICAgICBtdXN0QmVDb21taXR0ZWQ6ICFpc0Fib3J0ZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2N1cnJlbnREcmF3SWQpO1xuICAgIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoX2RhdGEpIHt9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcoX3BhZ2VYLCBfcGFnZVksIF9wYWdlV2lkdGgsIF9wYWdlSGVpZ2h0LCBfaW5uZXJXaWR0aCwgX2RhdGEpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHBhcmVudC52aWV3cG9ydDtcbiAgICBjb25zdCBkcmF3T3V0bGluZXMgPSB0aGlzLmRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgdGhpcy5fSU5ORVJfTUFSR0lOLCBkYXRhKTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNyZWF0ZURyYXdpbmdPcHRpb25zKGRhdGEpO1xuICAgIGVkaXRvci4jY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICAgIGRyYXdPdXRsaW5lc1xuICAgIH0pO1xuICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgZWRpdG9yLnJvdGF0ZSgpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpIHtcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICByZXR1cm4gdGhpcy4jZHJhd091dGxpbmVzLnNlcmlhbGl6ZShbcGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCBpc0ZvckNvcHlpbmcpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaW5rZHJhdy5qc1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgSW5rRHJhd091dGxpbmVyIHtcbiAgI2xhc3QgPSBuZXcgRmxvYXQ2NEFycmF5KDYpO1xuICAjbGluZTtcbiAgI2xpbmVzO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gICNwb2ludHM7XG4gICNsYXN0U1ZHUGF0aCA9IFwiXCI7XG4gICNsYXN0SW5kZXggPSAwO1xuICAjb3V0bGluZXMgPSBuZXcgSW5rRHJhd091dGxpbmUoKTtcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICBjb25zdHJ1Y3Rvcih4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbiwgdGhpY2tuZXNzKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgdGhpcy4jbGluZXMgPSBbe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfV07XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdGhpcy4jdGhpY2tuZXNzID0gdmFsdWU7XG4gICAgfVxuICB9XG4gICNub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIE91dGxpbmUuX25vcm1hbGl6ZVBvaW50KHgsIHksIHRoaXMuI3BhcmVudFdpZHRoLCB0aGlzLiNwYXJlbnRIZWlnaHQsIHRoaXMuI3JvdGF0aW9uKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy4jbGluZXMgfHwgdGhpcy4jbGluZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGlzQ2FuY2VsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvaW50cy5sZW5ndGggPD0gMTA7XG4gIH1cbiAgYWRkKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdCh0aGlzLiNwYXJlbnRXaWR0aCAqIGRpZmZYLCB0aGlzLiNwYXJlbnRIZWlnaHQgKiBkaWZmWSk7XG4gICAgaWYgKGQgPD0gMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICAgIGlmIChpc05hTih4MSkpIHtcbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MiwgeTIsIHgsIHldLCAyKTtcbiAgICAgIHRoaXMuI2xpbmUucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbMF0pKSB7XG4gICAgICB0aGlzLiNsaW5lLnNwbGljZSg2LCA2KTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSwgMCk7XG4gICAgdGhpcy4jbGluZS5wdXNoKC4uLk91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZW5kKHgsIHkpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLmFkZCh4LCB5KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfSk7XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldExhc3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5zZXRMYXN0RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaChlbGVtZW50KTtcbiAgICB0aGlzLiNsaW5lID0gZWxlbWVudC5saW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IGVsZW1lbnQucG9pbnRzO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IHRoaXMuI2xpbmVzW2ldO1xuICAgICAgdGhpcy4jbGluZSA9IGxpbmU7XG4gICAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jbGFzdFNWR1BhdGhcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBmaXJzdFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNF0pO1xuICAgIGNvbnN0IGZpcnN0WSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs1XSk7XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfSBaYDtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPD0gNikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuI2xhc3RTVkdQYXRoLmxhc3RJbmRleE9mKFwiTVwiKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGguc2xpY2UoMCwgaSl9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgc2Vjb25kWCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMF0pO1xuICAgICAgY29uc3Qgc2Vjb25kWSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMV0pO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTCAke3NlY29uZFh9ICR7c2Vjb25kWX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMTI7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGlmICh0aGlzLiNsYXN0SW5kZXggPT09IDApIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gKTtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNsYXN0SW5kZXgsIGlpID0gdGhpcy4jbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IHRoaXMuI2xpbmUuc2xpY2UoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCArPSBidWZmZXIuam9pbihcIiBcIik7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gdGhpcy4jbGluZS5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICB9XG4gIGdldE91dGxpbmVzKHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgdGhpcy4jb3V0bGluZXMuYnVpbGQodGhpcy4jbGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCB0aGlzLiNyb3RhdGlvbiwgdGhpcy4jdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgdGhpcy4jbGFzdCA9IG51bGw7XG4gICAgdGhpcy4jbGluZSA9IG51bGw7XG4gICAgdGhpcy4jbGluZXMgPSBudWxsO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEwMDAwIDEwMDAwXCJcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElua0RyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNiYm94O1xuICAjY3VycmVudFJvdGF0aW9uID0gMDtcbiAgI2lubmVyTWFyZ2luO1xuICAjbGluZXM7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgI3BhcmVudFNjYWxlO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gIGJ1aWxkKGxpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBwYXJlbnRTY2FsZSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHBhcmVudFNjYWxlO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW4gPz8gMDtcbiAgICB0aGlzLiNsaW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuI2NvbXB1dGVCYm94KCk7XG4gIH1cbiAgZ2V0IHRoaWNrbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGhpY2tuZXNzO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmVcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBidWZmZXIucHVzaChgTSR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzRdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNV0pfWApO1xuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDEyICYmIGlzTmFOKGxpbmVbNl0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTFdKX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQb2ludHMgPSBbXTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRCQm94V2l0aE5vTWFyZ2luKCk7XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MiwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAodGhpcy4jcm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeCAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHggKyB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoMSAtIHkpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArIHkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB4ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICh5ICsgaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh4ICsgd2lkdGgpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB5ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICgxIC0geCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoeSArIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLXBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB5KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgc2VyaWFsaXplZExpbmVzLnB1c2gocmVzY2FsZUZuKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkobGluZS5sZW5ndGgpIDogbnVsbCkpO1xuICAgICAgc2VyaWFsaXplZFBvaW50cy5wdXNoKHJlc2NhbGVGbihwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogc2VyaWFsaXplZExpbmVzLFxuICAgICAgcG9pbnRzOiBzZXJpYWxpemVkUG9pbnRzLFxuICAgICAgcmVjdDogW3gxLCB5MSwgeDIsIHkyXVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwge1xuICAgIHBhdGhzOiB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50c1xuICAgIH0sXG4gICAgcm90YXRpb24sXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBjb25zdCBuZXdMaW5lcyA9IFtdO1xuICAgIGxldCB0eCwgdHksIHN4LCBzeSwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSAtcGFnZVggLyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVkgLyBwYWdlSGVpZ2h0ICsgMTtcbiAgICAgICAgc3ggPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICB0eSA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3ggPSAxIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgdHkgPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IC0xIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICB0eSA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgc3ggPSAtMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIWxpbmVzKSB7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFsyXSwgcG9pbnRbM11dKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gLSAyKSk7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gcG9pbnQuc3ViYXJyYXkoMCwgNCk7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50W2ldO1xuICAgICAgICAgIGNvbnN0IHkgPSBwb2ludFtpICsgMV07XG4gICAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG5ld0xpbmVzLnB1c2goe1xuICAgICAgICBsaW5lOiByZXNjYWxlRm4obGluZXNbaV0ubWFwKHggPT4geCA/PyBOYU4pLCB0eCwgdHksIHN4LCBzeSksXG4gICAgICAgIHBvaW50czogcmVzY2FsZUZuKHBvaW50c1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKCk7XG4gICAgb3V0bGluZXMuYnVpbGQobmV3TGluZXMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICAjZ2V0TWFyZ2luQ29tcG9uZW50cyh0aGlja25lc3MgPSB0aGlzLiN0aGlja25lc3MpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiNpbm5lck1hcmdpbiArIHRoaWNrbmVzcyAvIDIgKiB0aGlzLiNwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy4jcm90YXRpb24gJSAxODAgPT09IDAgPyBbbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGgsIG1hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodF0gOiBbbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0LCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aF07XG4gIH1cbiAgI2dldEJCb3hXaXRoTm9NYXJnaW4oKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKDApO1xuICAgIHJldHVybiBbeCArIG1hcmdpblgsIHkgKyBtYXJnaW5ZLCB3aWR0aCAtIDIgKiBtYXJnaW5YLCBoZWlnaHQgLSAyICogbWFyZ2luWV07XG4gIH1cbiAgI2NvbXB1dGVCYm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94ID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSAxMikge1xuICAgICAgICBmb3IgKGxldCBpID0gNCwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3gobGluZVtpXSwgbGluZVtpICsgMV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxhc3RYID0gbGluZVs0XSxcbiAgICAgICAgbGFzdFkgPSBsaW5lWzVdO1xuICAgICAgZm9yIChsZXQgaSA9IDYsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gbGluZS5zdWJhcnJheShpLCBpICsgNik7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHksIGJib3gpO1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGJib3hbMF0gPSBNYXRoQ2xhbXAoYmJveFswXSAtIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbMV0gPSBNYXRoQ2xhbXAoYmJveFsxXSAtIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gPSBNYXRoQ2xhbXAoYmJveFsyXSArIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbM10gPSBNYXRoQ2xhbXAoYmJveFszXSArIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gLT0gYmJveFswXTtcbiAgICBiYm94WzNdIC09IGJib3hbMV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbZGlmZk1hcmdpblgsIGRpZmZNYXJnaW5ZXSA9IFtuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWCwgbmV3TWFyZ2luWSAtIG9sZE1hcmdpblldO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVQYXJlbnREaW1lbnNpb25zKFt3aWR0aCwgaGVpZ2h0XSwgc2NhbGUpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBzY2FsZTtcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgZGlmZk1hcmdpblggPSBuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWDtcbiAgICBjb25zdCBkaWZmTWFyZ2luWSA9IG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMuI2N1cnJlbnRSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHZpZXdCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3gubWFwKE91dGxpbmUuc3ZnUm91bmQpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGdldCBkZWZhdWx0UHJvcGVydGllcygpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgcm90YXRpb25UcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgWywsIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBsZXQgYSA9IDAsXG4gICAgICBiID0gMCxcbiAgICAgIGMgPSAwLFxuICAgICAgZCA9IDAsXG4gICAgICBlID0gMCxcbiAgICAgIGYgPSAwO1xuICAgIHN3aXRjaCAodGhpcy4jY3VycmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBiID0gaGVpZ2h0IC8gd2lkdGg7XG4gICAgICAgIGMgPSAtd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgYSA9IC0xO1xuICAgICAgICBkID0gLTE7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgZiA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgYiA9IC1oZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYG1hdHJpeCgke2F9ICR7Yn0gJHtjfSAke2R9ICR7T3V0bGluZS5zdmdSb3VuZChlKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGYpfSlgO1xuICB9XG4gIGdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGAke3RoaXMucm90YXRpb25UcmFuc2Zvcm19IHRyYW5zbGF0ZSgke3R4fSAke3R5fSlgXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCBzMnggPSB3aWR0aCAvIG5ld1dpZHRoO1xuICAgIGNvbnN0IHMyeSA9IGhlaWdodCAvIG5ld0hlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gc2NhbGUoJHtzMnh9ICR7czJ5fSkgYCArIGB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWSl9KSBzY2FsZSgke3MxeH0gJHtzMXl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblkpfSlgXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGJib3g7XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgYmJveFsyXSA9IG5ld1dpZHRoO1xuICAgIGJib3hbM10gPSBuZXdIZWlnaHQ7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHR4ID0gLXMxeCAqICh4ICsgbWFyZ2luWCkgKyBuZXdYICsgbWFyZ2luWDtcbiAgICBjb25zdCB0eSA9IC1zMXkgKiAoeSArIG1hcmdpblkpICsgbmV3WSArIG1hcmdpblk7XG4gICAgaWYgKHMxeCAhPT0gMSB8fCBzMXkgIT09IDEgfHwgdHggIT09IDAgfHwgdHkgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHMxeCwgczF5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgczF4LCBzMXksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZXSwgcGFyZW50RGltZW5zaW9ucykge1xuICAgIGNvbnN0IFtuZXdQYXJlbnRXaWR0aCwgbmV3UGFyZW50SGVpZ2h0XSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgdHggPSBuZXdYIC0gYmJveFswXTtcbiAgICBjb25zdCB0eSA9IG5ld1kgLSBiYm94WzFdO1xuICAgIGlmICh0aGlzLiNwYXJlbnRXaWR0aCA9PT0gbmV3UGFyZW50V2lkdGggJiYgdGhpcy4jcGFyZW50SGVpZ2h0ID09PSBuZXdQYXJlbnRIZWlnaHQpIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKGxpbmUsIHR4LCB0eSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShwb2ludHMsIHR4LCB0eSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3ggPSB0aGlzLiNwYXJlbnRXaWR0aCAvIG5ld1BhcmVudFdpZHRoO1xuICAgICAgY29uc3Qgc3kgPSB0aGlzLiNwYXJlbnRIZWlnaHQgLyBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IG5ld1BhcmVudFdpZHRoO1xuICAgICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgYmJveFsyXSAqPSBzeDtcbiAgICAgIGJib3hbM10gKj0gc3k7XG4gICAgfVxuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGRyYXc6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMF0pfSAke091dGxpbmUuc3ZnUm91bmQoYmJveFsxXSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGxcbiAgICAgIH0sXG4gICAgICBiYm94XG4gICAgfTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvaW5rLmpzXG5cblxuXG5cblxuXG5cblxuY2xhc3MgSW5rRHJhd2luZ09wdGlvbnMgZXh0ZW5kcyBEcmF3aW5nT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKHZpZXdlclBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZpZXdQYXJhbWV0ZXJzID0gdmlld2VyUGFyYW1ldGVycztcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiAxLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiAxMFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHZhbHVlID8/PSB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdO1xuICAgICAgdmFsdWUgKj0gdGhpcy5fdmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModGhpcy5fdmlld1BhcmFtZXRlcnMpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIERyYXdpbmdFZGl0b3Ige1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLWluay1lZGl0b3JcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidHlwZXNNYXBcIiwgbmV3IE1hcChbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIFwic3Ryb2tlLXdpZHRoXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBcInN0cm9rZVwiXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBcInN0cm9rZS1vcGFjaXR5XCJdXSkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHJldHVybiBuZXcgSW5rRHJhd091dGxpbmVyKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnNbXCJzdHJva2Utd2lkdGhcIl0pO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIHJpY2hUZXh0LFxuICAgICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICBwb2ludHM6IGlua0xpc3RzXG4gICAgICAgIH0sXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGwsXG4gICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHRoaXMuX2NvbG9yUGlja2VyIHx8PSBuZXcgQmFzaWNDb2xvclBpY2tlcih0aGlzKTtcbiAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIHRoaXMuX2NvbG9yUGlja2VyXV07XG4gIH1cbiAgZ2V0IGNvbG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SO1xuICB9XG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhd2luZ09wdGlvbnMuc3Ryb2tlO1xuICB9XG4gIGdldCBvcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS1vcGFjaXR5XCJdO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3SWQsXG4gICAgICBfZHJhd2luZ09wdGlvbnMsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBfZHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKF9kcmF3SWQsIF9kcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2N1cnJlbnRQYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudXBkYXRlU1ZHUHJvcGVydHkoXCJzdHJva2Utd2lkdGhcIik7XG4gICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoe1xuICAgIGNvbG9yLFxuICAgIHRoaWNrbmVzcyxcbiAgICBvcGFjaXR5XG4gIH0pIHtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IElua0VkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoe1xuICAgICAgc3Ryb2tlOiBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvciksXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3MsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IG9wYWNpdHlcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uczoge1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eSxcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyksIHtcbiAgICAgIGNvbG9yOiBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydChzdHJva2UpLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBhdGhzOiB7XG4gICAgICAgIGxpbmVzLFxuICAgICAgICBwb2ludHNcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5oYXNFZGl0ZWRDb21tZW50IHx8IHRoaXMuX2hhc0JlZW5Nb3ZlZCB8fCB0aGlzLl9oYXNCZWVuUmVzaXplZCB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKSB8fCBzZXJpYWxpemVkLnRoaWNrbmVzcyAhPT0gdGhpY2tuZXNzIHx8IHNlcmlhbGl6ZWQub3BhY2l0eSAhPT0gb3BhY2l0eSB8fCBzZXJpYWxpemVkLnBhZ2VJbmRleCAhPT0gcGFnZUluZGV4O1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICBhbm5vdGF0aW9uLmhpZGUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhmYWxzZSk7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdCxcbiAgICAgIHRoaWNrbmVzczogdGhpcy5fZHJhd2luZ09wdGlvbnNbXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvY29udG91ci5qc1xuXG5jbGFzcyBDb250b3VyRHJhd091dGxpbmUgZXh0ZW5kcyBJbmtEcmF3T3V0bGluZSB7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IHN1cGVyLnRvU1ZHUGF0aCgpO1xuICAgIGlmICghcGF0aC5lbmRzV2l0aChcIlpcIikpIHtcbiAgICAgIHBhdGggKz0gXCJaXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL3NpZ25hdHVyZWRyYXcuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IEJBU0VfSEVBREVSX0xFTkdUSCA9IDg7XG5jb25zdCBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgPSAzO1xuY2xhc3MgU2lnbmF0dXJlRXh0cmFjdG9yIHtcbiAgc3RhdGljICNQQVJBTUVURVJTID0ge1xuICAgIG1heERpbTogNTEyLFxuICAgIHNpZ21hU0ZhY3RvcjogMC4wMixcbiAgICBzaWdtYVI6IDI1LFxuICAgIGtlcm5lbFNpemU6IDE2XG4gIH07XG4gIHN0YXRpYyAjbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKSB7XG4gICAgaSAtPSBpMDtcbiAgICBqIC09IGowO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXR1cm4gaiA+IDAgPyAwIDogNDtcbiAgICB9XG4gICAgaWYgKGkgPT09IDEpIHtcbiAgICAgIHJldHVybiBqICsgNjtcbiAgICB9XG4gICAgcmV0dXJuIDIgLSBqO1xuICB9XG4gIHN0YXRpYyAjbmVpZ2hib3JJZFRvSW5kZXggPSBuZXcgSW50MzJBcnJheShbMCwgMSwgLTEsIDEsIC0xLCAwLCAtMSwgLTEsIDAsIC0xLCAxLCAtMSwgMSwgMCwgMSwgMV0pO1xuICBzdGF0aWMgI2Nsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKC1rICsgaWQgLSBvZmZzZXQgKyAxNikgJSA4O1xuICAgICAgY29uc3Qgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgIGNvbnN0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrayArIDFdO1xuICAgICAgaWYgKGJ1ZlsoaTAgKyBzaGlmdEkpICogd2lkdGggKyAoajAgKyBzaGlmdEopXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4ga2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgI2NvdW50ZXJDbG9ja3dpc2VOb25aZXJvKGJ1Ziwgd2lkdGgsIGkwLCBqMCwgaSwgaiwgb2Zmc2V0KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLiNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjb25zdCBrayA9IChrICsgaWQgKyBvZmZzZXQgKyAxNikgJSA4O1xuICAgICAgY29uc3Qgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgIGNvbnN0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrayArIDFdO1xuICAgICAgaWYgKGJ1ZlsoaTAgKyBzaGlmdEkpICogd2lkdGggKyAoajAgKyBzaGlmdEopXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4ga2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgI2ZpbmRDb250b3VycyhidWYsIHdpZHRoLCBoZWlnaHQsIHRocmVzaG9sZCkge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IHR5cGVzID0gbmV3IEludDMyQXJyYXkoTik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gYnVmW2ldIDw9IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgdHlwZXNbaSAqIHdpZHRoXSA9IHR5cGVzW2kgKiB3aWR0aCArIHdpZHRoIC0gMV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gdHlwZXNbd2lkdGggKiBoZWlnaHQgLSAxIC0gaV0gPSAwO1xuICAgIH1cbiAgICBsZXQgbmJkID0gMTtcbiAgICBsZXQgbG5iZDtcbiAgICBjb25zdCBjb250b3VycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICBsbmJkID0gMTtcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgd2lkdGggLSAxOyBqKyspIHtcbiAgICAgICAgY29uc3QgaWogPSBpICogd2lkdGggKyBqO1xuICAgICAgICBjb25zdCBwaXggPSB0eXBlc1tpal07XG4gICAgICAgIGlmIChwaXggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaTIgPSBpO1xuICAgICAgICBsZXQgajIgPSBqO1xuICAgICAgICBpZiAocGl4ID09PSAxICYmIHR5cGVzW2lqIC0gMV0gPT09IDApIHtcbiAgICAgICAgICBuYmQgKz0gMTtcbiAgICAgICAgICBqMiAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBpeCA+PSAxICYmIHR5cGVzW2lqICsgMV0gPT09IDApIHtcbiAgICAgICAgICBuYmQgKz0gMTtcbiAgICAgICAgICBqMiArPSAxO1xuICAgICAgICAgIGlmIChwaXggPiAxKSB7XG4gICAgICAgICAgICBsbmJkID0gcGl4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGl4ICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnMocGl4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzID0gW2osIGldO1xuICAgICAgICBjb25zdCBpc0hvbGUgPSBqMiA9PT0gaiArIDE7XG4gICAgICAgIGNvbnN0IGNvbnRvdXIgPSB7XG4gICAgICAgICAgaXNIb2xlLFxuICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICBpZDogbmJkLFxuICAgICAgICAgIHBhcmVudDogMFxuICAgICAgICB9O1xuICAgICAgICBjb250b3Vycy5wdXNoKGNvbnRvdXIpO1xuICAgICAgICBsZXQgY29udG91cjA7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb250b3Vycykge1xuICAgICAgICAgIGlmIChjLmlkID09PSBsbmJkKSB7XG4gICAgICAgICAgICBjb250b3VyMCA9IGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250b3VyMCkge1xuICAgICAgICAgIGNvbnRvdXIucGFyZW50ID0gaXNIb2xlID8gbG5iZCA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udG91cjAuaXNIb2xlKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBjb250b3VyMC5wYXJlbnQgOiBsbmJkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRvdXIucGFyZW50ID0gaXNIb2xlID8gbG5iZCA6IGNvbnRvdXIwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrID0gdGhpcy4jY2xvY2t3aXNlTm9uWmVybyh0eXBlcywgd2lkdGgsIGksIGosIGkyLCBqMiwgMCk7XG4gICAgICAgIGlmIChrID09PSAtMSkge1xuICAgICAgICAgIHR5cGVzW2lqXSA9IC1uYmQ7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqXSAhPT0gMSkge1xuICAgICAgICAgICAgbG5iZCA9IE1hdGguYWJzKHR5cGVzW2lqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga107XG4gICAgICAgIGxldCBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICogayArIDFdO1xuICAgICAgICBjb25zdCBpMSA9IGkgKyBzaGlmdEk7XG4gICAgICAgIGNvbnN0IGoxID0gaiArIHNoaWZ0SjtcbiAgICAgICAgaTIgPSBpMTtcbiAgICAgICAgajIgPSBqMTtcbiAgICAgICAgbGV0IGkzID0gaTtcbiAgICAgICAgbGV0IGozID0gajtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBrayA9IHRoaXMuI2NvdW50ZXJDbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaTMsIGozLCBpMiwgajIsIDEpO1xuICAgICAgICAgIHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBra107XG4gICAgICAgICAgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICAgICAgY29uc3QgaTQgPSBpMyArIHNoaWZ0STtcbiAgICAgICAgICBjb25zdCBqNCA9IGozICsgc2hpZnRKO1xuICAgICAgICAgIHBvaW50cy5wdXNoKGo0LCBpNCk7XG4gICAgICAgICAgY29uc3QgaWozID0gaTMgKiB3aWR0aCArIGozO1xuICAgICAgICAgIGlmICh0eXBlc1tpajMgKyAxXSA9PT0gMCkge1xuICAgICAgICAgICAgdHlwZXNbaWozXSA9IC1uYmQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlc1tpajNdID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gbmJkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaTQgPT09IGkgJiYgajQgPT09IGogJiYgaTMgPT09IGkxICYmIGozID09PSBqMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVzW2lqXSAhPT0gMSkge1xuICAgICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpMiA9IGkzO1xuICAgICAgICAgICAgajIgPSBqMztcbiAgICAgICAgICAgIGkzID0gaTQ7XG4gICAgICAgICAgICBqMyA9IGo0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udG91cnM7XG4gIH1cbiAgc3RhdGljICNkb3VnbGFzUGV1Y2tlckhlbHBlcihwb2ludHMsIHN0YXJ0LCBlbmQsIG91dHB1dCkge1xuICAgIGlmIChlbmQgLSBzdGFydCA8PSA0KSB7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQgLSAyOyBpICs9IDIpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXggPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGF5ID0gcG9pbnRzW3N0YXJ0ICsgMV07XG4gICAgY29uc3QgYWJ4ID0gcG9pbnRzW2VuZCAtIDRdIC0gYXg7XG4gICAgY29uc3QgYWJ5ID0gcG9pbnRzW2VuZCAtIDNdIC0gYXk7XG4gICAgY29uc3QgZGlzdCA9IE1hdGguaHlwb3QoYWJ4LCBhYnkpO1xuICAgIGNvbnN0IG5hYnggPSBhYnggLyBkaXN0O1xuICAgIGNvbnN0IG5hYnkgPSBhYnkgLyBkaXN0O1xuICAgIGNvbnN0IGFhID0gbmFieCAqIGF5IC0gbmFieSAqIGF4O1xuICAgIGNvbnN0IG0gPSBhYnkgLyBhYng7XG4gICAgY29uc3QgaW52UyA9IDEgLyBkaXN0O1xuICAgIGNvbnN0IHBoaSA9IE1hdGguYXRhbihtKTtcbiAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbnN0IHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgY29uc3QgdG1heCA9IGludlMgKiAoTWF0aC5hYnMoY29zUGhpKSArIE1hdGguYWJzKHNpblBoaSkpO1xuICAgIGNvbnN0IHBvbHkgPSBpbnZTICogKDEgLSB0bWF4ICsgdG1heCAqKiAyKTtcbiAgICBjb25zdCBwYXJ0aWFsUGhpID0gTWF0aC5tYXgoTWF0aC5hdGFuKE1hdGguYWJzKHNpblBoaSArIGNvc1BoaSkgKiBwb2x5KSwgTWF0aC5hdGFuKE1hdGguYWJzKHNpblBoaSAtIGNvc1BoaSkgKiBwb2x5KSk7XG4gICAgbGV0IGRtYXggPSAwO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDI7IGkgPCBlbmQgLSAyOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGQgPSBNYXRoLmFicyhhYSAtIG5hYnggKiBwb2ludHNbaSArIDFdICsgbmFieSAqIHBvaW50c1tpXSk7XG4gICAgICBpZiAoZCA+IGRtYXgpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBkbWF4ID0gZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRtYXggPiAoZGlzdCAqIHBhcnRpYWxQaGkpICoqIDIpIHtcbiAgICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGluZGV4ICsgMiwgb3V0cHV0KTtcbiAgICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgaW5kZXgsIGVuZCwgb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goYXgsIGF5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHRoaXMuI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgMCwgbGVuLCBvdXRwdXQpO1xuICAgIG91dHB1dC5wdXNoKHBvaW50c1tsZW4gLSAyXSwgcG9pbnRzW2xlbiAtIDFdKTtcbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA8PSA0ID8gbnVsbCA6IG91dHB1dDtcbiAgfVxuICBzdGF0aWMgI2JpbGF0ZXJhbEZpbHRlcihidWYsIHdpZHRoLCBoZWlnaHQsIHNpZ21hUywgc2lnbWFSLCBrZXJuZWxTaXplKSB7XG4gICAgY29uc3Qga2VybmVsID0gbmV3IEZsb2F0MzJBcnJheShrZXJuZWxTaXplICoqIDIpO1xuICAgIGNvbnN0IHNpZ21hUzIgPSAtMiAqIHNpZ21hUyAqKiAyO1xuICAgIGNvbnN0IGhhbGZTaXplID0ga2VybmVsU2l6ZSA+PiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gKGkgLSBoYWxmU2l6ZSkgKiogMjtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaisrKSB7XG4gICAgICAgIGtlcm5lbFtpICoga2VybmVsU2l6ZSArIGpdID0gTWF0aC5leHAoKHggKyAoaiAtIGhhbGZTaXplKSAqKiAyKSAvIHNpZ21hUzIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByYW5nZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMjU2KTtcbiAgICBjb25zdCBzaWdtYVIyID0gLTIgKiBzaWdtYVIgKiogMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICByYW5nZVZhbHVlc1tpXSA9IE1hdGguZXhwKGkgKiogMiAvIHNpZ21hUjIpO1xuICAgIH1cbiAgICBjb25zdCBOID0gYnVmLmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShOKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgaWogPSBpICogd2lkdGggKyBqO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBidWZbaWpdO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG5vcm0gPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtlcm5lbFNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IHkgPSBpICsgayAtIGhhbGZTaXplO1xuICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID49IGhlaWdodCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwga2VybmVsU2l6ZTsgbCsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gaiArIGwgLSBoYWxmU2l6ZTtcbiAgICAgICAgICAgIGlmICh4IDwgMCB8fCB4ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3VyID0gYnVmW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgY29uc3QgdyA9IGtlcm5lbFtrICoga2VybmVsU2l6ZSArIGxdICogcmFuZ2VWYWx1ZXNbTWF0aC5hYnMobmVpZ2hib3VyIC0gY2VudGVyKV07XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3VyICogdztcbiAgICAgICAgICAgIG5vcm0gKz0gdztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGl4ID0gb3V0W2lqXSA9IE1hdGgucm91bmQoc3VtIC8gbm9ybSk7XG4gICAgICAgIGhpc3RvZ3JhbVtwaXhdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb3V0LCBoaXN0b2dyYW1dO1xuICB9XG4gIHN0YXRpYyAjZ2V0SGlzdG9ncmFtKGJ1Zikge1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAoY29uc3QgZyBvZiBidWYpIHtcbiAgICAgIGhpc3RvZ3JhbVtnXSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9XG4gIHN0YXRpYyAjdG9VaW50OChidWYpIHtcbiAgICBjb25zdCBOID0gYnVmLmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoTiA+PiAyKTtcbiAgICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcGl4ID0gb3V0W2ldID0gYnVmW2kgPDwgMl07XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIHBpeCk7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHBpeCk7XG4gICAgfVxuICAgIGNvbnN0IHJhdGlvID0gMjU1IC8gKG1heCAtIG1pbik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IChvdXRbaV0gLSBtaW4pICogcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgc3RhdGljICNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgTSA9IC1JbmZpbml0eTtcbiAgICBsZXQgTCA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBtaW4gPSBoaXN0b2dyYW0uZmluZEluZGV4KHYgPT4gdiAhPT0gMCk7XG4gICAgbGV0IHBvcyA9IG1pbjtcbiAgICBsZXQgc3BvcyA9IG1pbjtcbiAgICBmb3IgKGkgPSBtaW47IGkgPCAyNTY7IGkrKykge1xuICAgICAgY29uc3QgdiA9IGhpc3RvZ3JhbVtpXTtcbiAgICAgIGlmICh2ID4gTSkge1xuICAgICAgICBpZiAoaSAtIHBvcyA+IEwpIHtcbiAgICAgICAgICBMID0gaSAtIHBvcztcbiAgICAgICAgICBzcG9zID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgTSA9IHY7XG4gICAgICAgIHBvcyA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IHNwb3MgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGhpc3RvZ3JhbVtpXSA+IGhpc3RvZ3JhbVtpICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHN0YXRpYyAjZ2V0R3JheVBpeGVscyhiaXRtYXApIHtcbiAgICBjb25zdCBvcmlnaW5hbEJpdG1hcCA9IGJpdG1hcDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBiaXRtYXA7XG4gICAgY29uc3Qge1xuICAgICAgbWF4RGltXG4gICAgfSA9IHRoaXMuI1BBUkFNRVRFUlM7XG4gICAgbGV0IG5ld1dpZHRoID0gd2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodDtcbiAgICBpZiAod2lkdGggPiBtYXhEaW0gfHwgaGVpZ2h0ID4gbWF4RGltKSB7XG4gICAgICBsZXQgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICBsZXQgcHJldkhlaWdodCA9IGhlaWdodDtcbiAgICAgIGxldCBzdGVwcyA9IE1hdGgubG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIG1heERpbSk7XG4gICAgICBjb25zdCBpc3RlcHMgPSBNYXRoLmZsb29yKHN0ZXBzKTtcbiAgICAgIHN0ZXBzID0gc3RlcHMgPT09IGlzdGVwcyA/IGlzdGVwcyAtIDEgOiBpc3RlcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwocHJldldpZHRoIC8gMik7XG4gICAgICAgIG5ld0hlaWdodCA9IE1hdGguY2VpbChwcmV2SGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgaWYgKGJpdG1hcCAhPT0gb3JpZ2luYWxCaXRtYXApIHtcbiAgICAgICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERpbSAvIG5ld1dpZHRoLCBtYXhEaW0gLyBuZXdIZWlnaHQpO1xuICAgICAgbmV3V2lkdGggPSBNYXRoLnJvdW5kKG5ld1dpZHRoICogcmF0aW8pO1xuICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdIZWlnaHQgKiByYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBncmF5SW1hZ2UgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgdWludDhCdWYgPSB0aGlzLiN0b1VpbnQ4KGdyYXlJbWFnZSk7XG4gICAgcmV0dXJuIFt1aW50OEJ1ZiwgbmV3V2lkdGgsIG5ld0hlaWdodF07XG4gIH1cbiAgc3RhdGljIGV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIHtcbiAgICBmb250RmFtaWx5LFxuICAgIGZvbnRTdHlsZSxcbiAgICBmb250V2VpZ2h0XG4gIH0sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgbGV0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZm9udFNpemUgPSAyMDA7XG4gICAgY29uc3QgZm9udCA9IGN0eC5mb250ID0gYCR7Zm9udFN0eWxlfSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgY29uc3Qge1xuICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICBjb25zdCBTQ0FMRSA9IDEuNTtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveExlZnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgfHwgMCwgd2lkdGgpICogU0NBTEUpO1xuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpIHx8IGZvbnRTaXplLCBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUpICogU0NBTEUpO1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBjYW52YXNXaWR0aCAqIChTQ0FMRSAtIDEpIC8gMiwgY2FudmFzSGVpZ2h0ICogKDMgLSBTQ0FMRSkgLyAyKTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KS5kYXRhKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSB0aGlzLiNnZXRIaXN0b2dyYW0odWludDhCdWYpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnModWludDhCdWYsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIHRocmVzaG9sZCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBjb250b3VyTGlzdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luLFxuICAgICAgbXVzdFNtb290aDogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IFt1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRHcmF5UGl4ZWxzKGJpdG1hcCk7XG4gICAgY29uc3QgW2J1ZmZlciwgaGlzdG9ncmFtXSA9IHRoaXMuI2JpbGF0ZXJhbEZpbHRlcih1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodCwgTWF0aC5oeXBvdCh3aWR0aCwgaGVpZ2h0KSAqIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFTRmFjdG9yLCB0aGlzLiNQQVJBTUVURVJTLnNpZ21hUiwgdGhpcy4jUEFSQU1FVEVSUy5rZXJuZWxTaXplKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLiNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pO1xuICAgIGNvbnN0IGNvbnRvdXJMaXN0ID0gdGhpcy4jZmluZENvbnRvdXJzKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2Vzc0RyYXduTGluZXMoe1xuICAgIGxpbmVzLFxuICAgIHBhZ2VXaWR0aCxcbiAgICBwYWdlSGVpZ2h0LFxuICAgIHJvdGF0aW9uLFxuICAgIGlubmVyTWFyZ2luLFxuICAgIG11c3RTbW9vdGgsXG4gICAgYXJlQ29udG91cnNcbiAgfSkge1xuICAgIGlmIChyb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBbcGFnZUhlaWdodCwgcGFnZVdpZHRoXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VydmVzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gbGluZXM7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gbGluZXMudGhpY2tuZXNzID8/IDA7XG4gICAgY29uc3QgbGluZXNBbmRQb2ludHMgPSBbXTtcbiAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKHBhZ2VXaWR0aCAvIHdpZHRoLCBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICBjb25zdCB4U2NhbGUgPSByYXRpbyAvIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSByYXRpbyAvIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgbmV3Q3VydmVzID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBwb2ludHNcbiAgICB9IG9mIGN1cnZlcykge1xuICAgICAgY29uc3QgcmVkdWNlZFBvaW50cyA9IG11c3RTbW9vdGggPyB0aGlzLiNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIDogcG9pbnRzO1xuICAgICAgaWYgKCFyZWR1Y2VkUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV3Q3VydmVzLnB1c2gocmVkdWNlZFBvaW50cyk7XG4gICAgICBjb25zdCBsZW4gPSByZWR1Y2VkUG9pbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiAobGVuID09PSAyID8gMiA6IGxlbiAtIDIpKTtcbiAgICAgIGxpbmVzQW5kUG9pbnRzLnB1c2goe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHM6IG5ld1BvaW50c1xuICAgICAgfSk7XG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIG5ld1BvaW50c1swXSA9IHJlZHVjZWRQb2ludHNbMF0gKiB4U2NhbGU7XG4gICAgICAgIG5ld1BvaW50c1sxXSA9IHJlZHVjZWRQb2ludHNbMV0gKiB5U2NhbGU7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIG5ld1BvaW50c1swXSwgbmV3UG9pbnRzWzFdXSwgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWR1Y2VkUG9pbnRzO1xuICAgICAgeDEgKj0geFNjYWxlO1xuICAgICAgeTEgKj0geVNjYWxlO1xuICAgICAgeDIgKj0geFNjYWxlO1xuICAgICAgeTIgKj0geVNjYWxlO1xuICAgICAgbmV3UG9pbnRzLnNldChbeDEsIHkxLCB4MiwgeTJdLCAwKTtcbiAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gbmV3UG9pbnRzW2ldID0gcmVkdWNlZFBvaW50c1tpXSAqIHhTY2FsZTtcbiAgICAgICAgY29uc3QgeSA9IG5ld1BvaW50c1tpICsgMV0gPSByZWR1Y2VkUG9pbnRzW2kgKyAxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSBbeDIsIHkyLCB4LCB5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpbmVzQW5kUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBhcmVDb250b3VycyA/IG5ldyBDb250b3VyRHJhd091dGxpbmUoKSA6IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAgIG91dGxpbmUuYnVpbGQobGluZXNBbmRQb2ludHMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIGFyZUNvbnRvdXJzID8gMCA6IHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lLFxuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbXByZXNzU2lnbmF0dXJlKHtcbiAgICBvdXRsaW5lcyxcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3MsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0pIHtcbiAgICBsZXQgbWluRGlmZiA9IEluZmluaXR5O1xuICAgIGxldCBtYXhEaWZmID0gLUluZmluaXR5O1xuICAgIGxldCBvdXRsaW5lc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIG91dGxpbmVzTGVuZ3RoICs9IHBvaW50cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBkeCA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICAgIG1pbkRpZmYgPSBNYXRoLm1pbihtaW5EaWZmLCBkeCk7XG4gICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBidWZmZXJUeXBlO1xuICAgIGlmIChtaW5EaWZmID49IC0xMjggJiYgbWF4RGlmZiA8PSAxMjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQ4QXJyYXk7XG4gICAgfSBlbHNlIGlmIChtaW5EaWZmID49IC0zMjc2OCAmJiBtYXhEaWZmIDw9IDMyNzY3KSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDMyQXJyYXk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG91dGxpbmVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBsZW47XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGhlYWRlckxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGhlYWRlckxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICsgKG91dGxpbmVzTGVuZ3RoIC0gMiAqIGxlbikgKiBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSAwO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSB3aWR0aDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVpZ2h0O1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBhcmVDb250b3VycyA/IDAgOiAxO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHRoaWNrbmVzcyA/PyAwKSk7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGxlbjtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gYnVmZmVyVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1swXTtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgY29uc3Qgd3JpdGVyID0gY3Mud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIHdyaXRlci53cml0ZShoZWFkZXIpO1xuICAgIGNvbnN0IEJ1ZmZlckN0b3IgPSBidWZmZXJUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgY29uc3QgZGlmZnMgPSBuZXcgQnVmZmVyQ3Rvcihwb2ludHMubGVuZ3RoIC0gMik7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBkaWZmc1tpIC0gMl0gPSBwb2ludHNbaV0gLSBwb2ludHNbaSAtIDJdO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlKGRpZmZzKTtcbiAgICB9XG4gICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgbmV3IFJlc3BvbnNlKGNzLnJlYWRhYmxlKS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICByZXR1cm4gdG9CYXNlNjRVdGlsKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVjb21wcmVzc1NpZ25hdHVyZShzaWduYXR1cmVEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZnJvbUJhc2U2NFV0aWwoc2lnbmF0dXJlRGF0YSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlYWRhYmxlLFxuICAgICAgICB3cml0YWJsZVxuICAgICAgfSA9IG5ldyBEZWNvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIHdyaXRlci53cml0ZShieXRlcykudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZGFibGUpIHtcbiAgICAgICAgZGF0YSB8fD0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KGNodW5rLmJ1ZmZlciwgMCwgNClbMF0pO1xuICAgICAgICBkYXRhLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgZGF0YS5sZW5ndGggPj4gMik7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gaGVhZGVyWzFdO1xuICAgICAgaWYgKHZlcnNpb24gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gaGVhZGVyWzJdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaGVhZGVyWzNdO1xuICAgICAgY29uc3QgYXJlQ29udG91cnMgPSBoZWFkZXJbNF0gPT09IDA7XG4gICAgICBjb25zdCB0aGlja25lc3MgPSBoZWFkZXJbNV07XG4gICAgICBjb25zdCBudW1iZXJPZkRyYXdpbmdzID0gaGVhZGVyWzZdO1xuICAgICAgY29uc3QgYnVmZmVyVHlwZSA9IGhlYWRlcls3XTtcbiAgICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgICBjb25zdCBkaWZmc09mZnNldCA9IChCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBudW1iZXJPZkRyYXdpbmdzKSAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgbGV0IGRpZmZzO1xuICAgICAgc3dpdGNoIChidWZmZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgSW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOlxuICAgICAgICAgIGRpZmZzID0gbmV3IEludDhBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MTZBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MzJBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEcmF3aW5nczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIXTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4gKyAyKTtcbiAgICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAtIDE7IGorKykge1xuICAgICAgICAgIHBvaW50c1tqXSA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIICsgaiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBwb2ludHNbaiArIDJdID0gcG9pbnRzW2pdICsgZGlmZnNbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvdXRsaW5lcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBkZWNvbXByZXNzU2lnbmF0dXJlOiAke2V9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3NpZ25hdHVyZS5qc1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAwXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIERyYXduU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIElua0RyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKHZpZXdlclBhcmFtZXRlcnMpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMVxuICAgIH0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IERyYXduU2lnbmF0dXJlT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gICNpc0V4dHJhY3RlZCA9IGZhbHNlO1xuICAjZGVzY3JpcHRpb24gPSBudWxsO1xuICAjc2lnbmF0dXJlRGF0YSA9IG51bGw7XG4gICNzaWduYXR1cmVVVUlEID0gbnVsbDtcbiAgc3RhdGljIF90eXBlID0gXCJzaWduYXR1cmVcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFO1xuICBzdGF0aWMgX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG11c3RCZUNvbW1pdHRlZDogdHJ1ZSxcbiAgICAgIG5hbWU6IFwic2lnbmF0dXJlRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLiNzaWduYXR1cmVEYXRhID0gcGFyYW1zLnNpZ25hdHVyZURhdGEgfHwgbnVsbDtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc2lnbmF0dXJlLWVkaXRvcjFcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHVpTWFuYWdlci52aWV3UGFyYW1ldGVycyk7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMuY2xvbmUoKTtcbiAgICBjbG9uZS51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICBoYXNEZXNjcmlwdGlvbjogISF0aGlzLiNkZXNjcmlwdGlvblxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0Rlc2NyaXB0aW9uU3RhdHMgPSBkYXRhLmdldChcImhhc0Rlc2NyaXB0aW9uXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNEZXNjcmlwdGlvblN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNEZXNjcmlwdGlvblN0YXRzLmdldChmYWxzZSkgPz8gMFxuICAgIH07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZygpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBjb25zdCB7XG4gICAgICBfaXNDb3B5XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKF9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX2lzQ29weSA9IGZhbHNlO1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuI3NpZ25hdHVyZURhdGEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgIG11c3RTbW9vdGgsXG4gICAgICAgICAgYXJlQ29udG91cnMsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgdXVpZCxcbiAgICAgICAgICBoZWlnaHRJblBhZ2VcbiAgICAgICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICByb3RhdGlvblxuICAgICAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlubmVyTWFyZ2luOiBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTixcbiAgICAgICAgICBtdXN0U21vb3RoLFxuICAgICAgICAgIGFyZUNvbnRvdXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZFNpZ25hdHVyZShvdXRsaW5lLCBoZWlnaHRJblBhZ2UsIGRlc2NyaXB0aW9uLCB1dWlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJcIlxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5nZXRTaWduYXR1cmUodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuI2Rlc2NyaXB0aW9uIHx8IFwiXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKF9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX2lzQ29weSA9IHRydWU7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0VXVpZCh1dWlkKSB7XG4gICAgdGhpcy4jc2lnbmF0dXJlVVVJRCA9IHV1aWQ7XG4gICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldFV1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hdHVyZVVVSUQ7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNkZXNjcmlwdGlvbjtcbiAgfVxuICBzZXQgZGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGlmICghdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KSk7XG4gICAgc3VwZXIuYWRkRWRpdFRvb2xiYXIoKS50aGVuKHRvb2xiYXIgPT4ge1xuICAgICAgdG9vbGJhcj8udXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbihkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlUHJldmlldygpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXdDdXJ2ZXMsXG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGE7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb3V0bGluZURhdGEgPSBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBuZXdDdXJ2ZXMubWFwKHBvaW50cyA9PiAoe1xuICAgICAgICAgIHBvaW50c1xuICAgICAgICB9KSksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aDogbWF4RGltLFxuICAgICAgcGFnZUhlaWdodDogbWF4RGltLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBpbm5lck1hcmdpbjogMCxcbiAgICAgIG11c3RTbW9vdGg6IGZhbHNlLFxuICAgICAgYXJlQ29udG91cnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYXJlQ29udG91cnMsXG4gICAgICBvdXRsaW5lOiBvdXRsaW5lRGF0YS5vdXRsaW5lXG4gICAgfTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5zaWduYXR1cmVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gW1tcImVkaXRTaWduYXR1cmVcIiwgdGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnRvb2xiYXJCdXR0b25zO1xuICB9XG4gIGFkZFNpZ25hdHVyZShkYXRhLCBoZWlnaHRJblBhZ2UsIGRlc2NyaXB0aW9uLCB1dWlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogc2F2ZWRYLFxuICAgICAgeTogc2F2ZWRZXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb3V0bGluZVxuICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhID0gZGF0YTtcbiAgICB0aGlzLiNpc0V4dHJhY3RlZCA9IG91dGxpbmUgaW5zdGFuY2VvZiBDb250b3VyRHJhd091dGxpbmU7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGxldCBkcmF3aW5nT3B0aW9ucztcbiAgICBpZiAodGhpcy4jaXNFeHRyYWN0ZWQpIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucy5jbG9uZSgpO1xuICAgICAgZHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG91dGxpbmUudGhpY2tuZXNzXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fYWRkT3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzOiBvdXRsaW5lLFxuICAgICAgZHJhd2luZ09wdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBbLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodEluUGFnZSAvIHBhZ2VIZWlnaHQ7XG4gICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDEgPyAwLjUgOiBuZXdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCAqPSBuZXdIZWlnaHQgLyB0aGlzLmhlaWdodDtcbiAgICBpZiAodGhpcy53aWR0aCA+PSAxKSB7XG4gICAgICBuZXdIZWlnaHQgKj0gMC45IC8gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMud2lkdGggPSAwLjk7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMueCA9IHNhdmVkWDtcbiAgICB0aGlzLnkgPSBzYXZlZFk7XG4gICAgdGhpcy5jZW50ZXIoKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgICB0aGlzLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIHRoaXMucm90YXRlKCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gICAgdGhpcy5zZXRVdWlkKHV1aWQpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuc2lnbmF0dXJlLmluc2VydGVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhhc0JlZW5TYXZlZDogISF1dWlkLFxuICAgICAgICBoYXNEZXNjcmlwdGlvbjogISFkZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldEZyb21JbWFnZShiaXRtYXApIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2VzcyhiaXRtYXAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOKTtcbiAgfVxuICBnZXRGcm9tVGV4dCh0ZXh0LCBmb250SW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5leHRyYWN0Q29udG91cnNGcm9tVGV4dCh0ZXh0LCBmb250SW5mbywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4pO1xuICB9XG4gIGdldERyYXduU2lnbmF0dXJlKGN1cnZlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczogY3VydmVzLFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3VyczogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgYXJlQ29udG91cnMsXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBpZiAoYXJlQ29udG91cnMpIHtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucy5jbG9uZSgpO1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uczoge1xuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgaXNTaWduYXR1cmU6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdGhpcy4jaXNFeHRyYWN0ZWQsXG4gICAgICBjb2xvcjogWzAsIDAsIDBdLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiNpc0V4dHJhY3RlZCA/IDAgOiB0aGlja25lc3NcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5wYXRocyA9IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfTtcbiAgICAgIHNlcmlhbGl6ZWQudXVpZCA9IHRoaXMuI3NpZ25hdHVyZVVVSUQ7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQubGluZXMgPSBsaW5lcztcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Rlc2NyaXB0aW9uKSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IHRoaXMuI2Rlc2NyaXB0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSkge1xuICAgIGlmIChkYXRhLmFyZUNvbnRvdXJzKSB7XG4gICAgICByZXR1cm4gQ29udG91ckRyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBJbmtEcmF3T3V0bGluZS5kZXNlcmlhbGl6ZShwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2lzRXh0cmFjdGVkID0gZGF0YS5hcmVDb250b3VycztcbiAgICBlZGl0b3IuZGVzY3JpcHRpb24gPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhPy5hbHQgfHwgXCJcIjtcbiAgICBlZGl0b3IuI3NpZ25hdHVyZVVVSUQgPSBkYXRhLnV1aWQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3Ivc3RhbXAuanNcblxuXG5cblxuXG5cblxuY2xhc3MgU3RhbXBFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JpdG1hcCA9IG51bGw7XG4gICNiaXRtYXBJZCA9IG51bGw7XG4gICNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgI2JpdG1hcFVybCA9IG51bGw7XG4gICNiaXRtYXBGaWxlID0gbnVsbDtcbiAgI2JpdG1hcEZpbGVOYW1lID0gXCJcIjtcbiAgI2NhbnZhcyA9IG51bGw7XG4gICNtaXNzaW5nQ2FudmFzID0gZmFsc2U7XG4gICNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAjaXNTdmcgPSBmYWxzZTtcbiAgI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gIHN0YXRpYyBfdHlwZSA9IFwic3RhbXBcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwic3RhbXBFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2JpdG1hcFVybCA9IHBhcmFtcy5iaXRtYXBVcmw7XG4gICAgdGhpcy4jYml0bWFwRmlsZSA9IHBhcmFtcy5iaXRtYXBGaWxlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLXN0YW1wLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKHtcbiAgICAgIG1vZGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QXG4gICAgfSwge1xuICAgICAgYml0bWFwRmlsZTogaXRlbS5nZXRBc0ZpbGUoKVxuICAgIH0pO1xuICB9XG4gIGFsdFRleHRGaW5pc2goKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHN1cGVyLmFsdFRleHRGaW5pc2goKTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0YW1wXCIsXG4gICAgICBoYXNBbHRUZXh0OiAhIXRoaXMuYWx0VGV4dERhdGE/LmFsdFRleHRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBoYXNBbHRUZXh0U3RhdHMgPSBkYXRhLmdldChcImhhc0FsdFRleHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQodHJ1ZSkgPz8gMCxcbiAgICAgIGhhc05vQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldChmYWxzZSkgPz8gMFxuICAgIH07XG4gIH1cbiAgI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgZnJvbUlkID0gZmFsc2UpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2JpdG1hcCA9IGRhdGEuYml0bWFwO1xuICAgIGlmICghZnJvbUlkKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLiNpc1N2ZyA9IGRhdGEuaXNTdmc7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGVOYW1lID0gZGF0YS5maWxlLm5hbWU7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICB9XG4gICNnZXRCaXRtYXBEb25lKCkge1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBpZiAoIXRoaXMuI2NhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9lZGl0VG9vbGJhci5oaWRlKCk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9hZGRlZFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWx0X3RleHRfbW9kYWw6IGZhbHNlLFxuICAgICAgICAgIGFsdF90ZXh0X3R5cGU6IFwiZW1wdHlcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWxHdWVzc0FsdFRleHQoKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBhc3luYyBtbEd1ZXNzQWx0VGV4dChpbWFnZURhdGEgPSBudWxsLCB1cGRhdGVBbHRUZXh0RGF0YSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWxNYW5hZ2VyXG4gICAgfSA9IHRoaXMuX3VpTWFuYWdlcjtcbiAgICBpZiAoIW1sTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTUwuXCIpO1xuICAgIH1cbiAgICBpZiAoIShhd2FpdCBtbE1hbmFnZXIuaXNFbmFibGVkRm9yKFwiYWx0VGV4dFwiKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1MIGlzbid0IGVuYWJsZWQgZm9yIGFsdCB0ZXh0LlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltYWdlRGF0YSB8fCB0aGlzLmNvcHlDYW52YXMobnVsbCwgbnVsbCwgdHJ1ZSkuaW1hZ2VEYXRhO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWxNYW5hZ2VyLmd1ZXNzKHtcbiAgICAgIG5hbWU6IFwiYWx0VGV4dFwiLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBjaGFubmVsczogZGF0YS5sZW5ndGggLyAod2lkdGggKiBoZWlnaHQpXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5jYW5jZWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgcmVzcG9uc2UgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFsdFRleHQgPSByZXNwb25zZS5vdXRwdXQ7XG4gICAgYXdhaXQgdGhpcy5zZXRHdWVzc2VkQWx0VGV4dChhbHRUZXh0KTtcbiAgICBpZiAodXBkYXRlQWx0VGV4dERhdGEgJiYgIXRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgdGhpcy5hbHRUZXh0RGF0YSA9IHtcbiAgICAgICAgYWx0OiBhbHRUZXh0LFxuICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgI2dldEJpdG1hcCgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tSWQodGhpcy4jYml0bWFwSWQpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIHRydWUpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBVcmwpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2JpdG1hcFVybDtcbiAgICAgIHRoaXMuI2JpdG1hcFVybCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21VcmwodXJsKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZSkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuI2JpdG1hcEZpbGU7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoZmlsZSkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0LmFjY2VwdCA9IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIWlucHV0LmZpbGVzIHx8IGlucHV0LmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoaW5wdXQuZmlsZXNbMF0pO1xuICAgICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2Vfc2VsZWN0ZWRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgYWx0X3RleHRfbW9kYWw6IHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0Rmxvd1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNiaXRtYXAgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5kZWxldGVJZCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICB0aGlzLiNjYW52YXM/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jY2FudmFzID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCAmJiB0aGlzLiNjYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUgfHwgdGhpcy4jYml0bWFwSWQgfHwgdGhpcy4jbWlzc2luZ0NhbnZhcyk7XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHJldHVybiBbW1wiYWx0VGV4dFwiLCB0aGlzLmNyZWF0ZUFsdFRleHQoKV1dO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLmNyZWF0ZUFsdFRleHQoKTtcbiAgICBpZiAoIXRoaXMuI21pc3NpbmdDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXApIHtcbiAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogYml0bWFwSWQsXG4gICAgICBiaXRtYXBcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcyk7XG4gICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIGlmIChiaXRtYXBJZCAmJiB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIHRoaXMuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHRoaXMuYWRkQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgfHwgIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jZHJhd0JpdG1hcCgpO1xuICAgIGlmICghdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgICAgdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpcHRpb25cIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1zdGFtcC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgY29weUNhbnZhcyhtYXhEYXRhRGltZW5zaW9uLCBtYXhQcmV2aWV3RGltZW5zaW9uLCBjcmVhdGVJbWFnZURhdGEgPSBmYWxzZSkge1xuICAgIGlmICghbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgbWF4RGF0YURpbWVuc2lvbiA9IDIyNDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgd2lkdGggPSBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBpZiAobWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4UHJldmlld0RpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICAgIGxldCB3aGl0ZSA9IFwid2hpdGVcIixcbiAgICAgICAgYmxhY2sgPSBcIiNjZmNmZDhcIjtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyICE9PSBcIm5vbmVcIikge1xuICAgICAgICBibGFjayA9IFwiYmxhY2tcIjtcbiAgICAgIH0gZWxzZSBpZiAoQ29sb3JTY2hlbWUuaXNEYXJrTW9kZSkge1xuICAgICAgICB3aGl0ZSA9IFwiIzhmOGY5ZFwiO1xuICAgICAgICBibGFjayA9IFwiIzQyNDE0ZFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgYm94RGltID0gMTU7XG4gICAgICBjb25zdCBib3hEaW1XaWR0aCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN4O1xuICAgICAgY29uc3QgYm94RGltSGVpZ2h0ID0gYm94RGltICogb3V0cHV0U2NhbGUuc3k7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gYmxhY2s7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdChib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0LCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBcInJlcGVhdFwiKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgaW1hZ2VEYXRhID0gbnVsbDtcbiAgICBpZiAoY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgICBsZXQgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0O1xuICAgICAgaWYgKG91dHB1dFNjYWxlLnN5bW1ldHJpYyAmJiBiaXRtYXAud2lkdGggPCBtYXhEYXRhRGltZW5zaW9uICYmIGJpdG1hcC5oZWlnaHQgPCBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgIGRhdGFXaWR0aCA9IGJpdG1hcC53aWR0aDtcbiAgICAgICAgZGF0YUhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heERhdGFEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgICBkYXRhV2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICAgIGRhdGFIZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuQ3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvZmZzY3JlZW5DdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgaW1hZ2VEYXRhID0ge1xuICAgICAgICB3aWR0aDogZGF0YVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdGFIZWlnaHQsXG4gICAgICAgIGRhdGE6IG9mZnNjcmVlbkN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KS5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpbWFnZURhdGFcbiAgICB9O1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHBhcmVudFdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBwYXJlbnRIZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gc2NhbGVkV2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gc2NhbGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBsZXQgbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW52YXNcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IGJpdG1hcElkLCBiaXRtYXA7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmNhbnZhcztcbiAgICAgICAgKHtcbiAgICAgICAgICBpZDogYml0bWFwSWQsXG4gICAgICAgICAgYml0bWFwXG4gICAgICAgIH0gPSB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoY29udGFpbmVyLmlkLCBjYW52YXMpKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgICAgIGRhdGEuX2hhc05vQ2FudmFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsdFRleHQgPSAoYXdhaXQgcGFyZW50Ll9zdHJ1Y3RUcmVlLmdldEFyaWFBdHRyaWJ1dGVzKGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKSk/LmdldChcImFyaWEtbGFiZWxcIikgfHwgXCJcIjtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgICBiaXRtYXBJZCxcbiAgICAgICAgYml0bWFwLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIGJpdG1hcCxcbiAgICAgIGJpdG1hcFVybCxcbiAgICAgIGJpdG1hcElkLFxuICAgICAgaXNTdmcsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YVxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChtaXNzaW5nQ2FudmFzKSB7XG4gICAgICB1aU1hbmFnZXIuYWRkTWlzc2luZ0NhbnZhcyhkYXRhLmlkLCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLiNtaXNzaW5nQ2FudmFzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICBlZGl0b3IuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YSk7XG4gICAgfVxuICAgIGVkaXRvci4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSAhIWluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyksIHtcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIGlzU3ZnOiB0aGlzLiNpc1N2Z1xuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KGZhbHNlKTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCk7XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWVBbHRUZXh0KSB7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQgPSB0aGlzLl9pbml0aWFsRGF0YS5zdHJ1Y3RQYXJlbnQgPz8gLTE7XG4gICAgICB9XG4gICAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYml0bWFwSWQ7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgIGFsdFRleHRcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgY29uc3QgaXNTYW1lUGFnZUluZGV4ID0gc2VyaWFsaXplZC5wYWdlSW5kZXggPT09IHBhZ2VJbmRleDtcbiAgICBjb25zdCBpc1NhbWVBbHRUZXh0ID0gKHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiKSA9PT0gYWx0VGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTYW1lOiAhdGhpcy5oYXNFZGl0ZWRDb21tZW50ICYmICF0aGlzLl9oYXNCZWVuTW92ZWQgJiYgIXRoaXMuX2hhc0JlZW5SZXNpemVkICYmIGlzU2FtZVBhZ2VJbmRleCAmJiBpc1NhbWVBbHRUZXh0LFxuICAgICAgaXNTYW1lQWx0VGV4dFxuICAgIH07XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcG9wdXA6IHRoaXMuY29tbWVudFxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvckxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAjYWxsb3dDbGljayA9IGZhbHNlO1xuICAjYW5ub3RhdGlvbkxheWVyID0gbnVsbDtcbiAgI2NsaWNrQUMgPSBudWxsO1xuICAjZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICAjaXNFbmFibGluZyA9IGZhbHNlO1xuICAjZHJhd2luZ0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgI3RleHRMYXllciA9IG51bGw7XG4gICN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAjdGV4dExheWVyRGJsQ2xpY2tBQyA9IG51bGw7XG4gICNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSAtMTtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBzdGF0aWMgI2VkaXRvclR5cGVzID0gbmV3IE1hcChbRnJlZVRleHRFZGl0b3IsIElua0VkaXRvciwgU3RhbXBFZGl0b3IsIEhpZ2hsaWdodEVkaXRvciwgU2lnbmF0dXJlRWRpdG9yXS5tYXAodHlwZSA9PiBbdHlwZS5fZWRpdG9yVHlwZSwgdHlwZV0pKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIHN0cnVjdFRyZWVMYXllcixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uTGF5ZXIsXG4gICAgZHJhd0xheWVyLFxuICAgIHRleHRMYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFsuLi5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpXTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIGVkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN0ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgdGhpcy5kcmF3TGF5ZXIgPSBkcmF3TGF5ZXI7XG4gICAgdGhpcy5fc3RydWN0VHJlZSA9IHN0cnVjdFRyZWVMYXllcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgaXNJbnZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIob3B0aW9ucykge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG9wdGlvbnMpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU6XG4gICAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJub25FZGl0aW5nXCIsIHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGNsYXNzTGlzdC50b2dnbGUoXCJub25FZGl0aW5nXCIsIGZhbHNlKTtcbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuUE9QVVApIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJjb21tZW50RWRpdGluZ1wiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShcImNvbW1lbnRFZGl0aW5nXCIsIGZhbHNlKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCwgbW9kZSA9PT0gZWRpdG9yVHlwZS5fZWRpdG9yVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGhhc1RleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICByZXR1cm4gdGV4dExheWVyID09PSB0aGlzLiN0ZXh0TGF5ZXI/LmRpdjtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY2xlYW5VbmRvU3RhY2sodHlwZSk7XG4gIH1cbiAgdG9nZ2xlRHJhd2luZyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhd2luZ1wiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBnZXQgI2FsbEVkaXRvcnNJdGVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplICE9PSAwID8gdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSA6IHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy4jaXNFbmFibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbnVsbDtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzSXRlcmF0b3IpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBlZGl0b3Iuc2hvdyh0cnVlKTtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXIgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI7XG4gICAgaWYgKGFubm90YXRpb25MYXllcikge1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpKSB7XG4gICAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcImVkaXRvcnNyZW5kZXJlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBwYWdlTnVtYmVyOiB0aGlzLnBhZ2VJbmRleCArIDFcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIm5vbkVkaXRpbmdcIiwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllciAmJiAhdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQykge1xuICAgICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBjb25zdCBEQkxfQ0xJQ0tfVEhSRVNIT0xEID0gNTAwO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZLFxuICAgICAgICAgIHRpbWVTdGFtcFxuICAgICAgICB9ID0gZTtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wO1xuICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID4gREJMX0NMSUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgIHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IHRpbWVTdGFtcDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gLTE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGFzc0xpc3RcbiAgICAgICAgfSA9IHRoaXMuZGl2O1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiZ2V0RWxlbWVudHNcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5kaXYuY29udGFpbnMoZWxlbWVudHNbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fVswLTldKyRgKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoZWxlbWVudC5pZCkpIHtcbiAgICAgICAgICAgIGlkID0gZWxlbWVudC5pZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2VkaXRvcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcj8uYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGVkaXRvci5kYmxjbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXIgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI7XG4gICAgaWYgKGFubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgY2hhbmdlZEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVzZXRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnNJdGVyYXRvcikge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICAgIGVkaXRvci51cGRhdGVGYWtlQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkxheWVyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hhbmdlZEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdGFibGVzID0gYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChpZCkpIHtcbiAgICAgICAgICBlZGl0YWJsZS51cGRhdGVFZGl0ZWQoe1xuICAgICAgICAgICAgZGVsZXRlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlZGl0b3IgPSByZXNldEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICBlZGl0b3IucmVzZXRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSk7XG4gICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBjaGFuZ2VkQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgICAgaWYgKGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgIXRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRTZWxlY3Rpb25BQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiN0ZXh0TGF5ZXJQb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gICN0ZXh0TGF5ZXJQb2ludGVyRG93bihldmVudCkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiN0ZXh0TGF5ZXIuZGl2IHx8ICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJpbWdcIiB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW5kT2ZDb250ZW50XCIpKSAmJiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNNYWNcbiAgICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgICB0aGlzLnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIEhpZ2hsaWdodEVkaXRvci5zdGFydEhpZ2hsaWdodGluZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4jdGV4dExheWVyLmRpdixcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJmcmVlXCIpO1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuI2NsaWNrQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jY2xpY2tBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy4jY2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjbGlja0FDID0gbnVsbDtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuICAgIGVkaXRvci5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGVkaXRvci5vbmNlQWRkZWQoIXRoaXMuI2lzRW5hYmxpbmcpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoZWRpdG9yLnRlbGVtZXRyeUluaXRpYWxEYXRhKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgJiYgIXRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBpZiAoIWVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBlZGl0b3IuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucGFyZW50IHx8PSB0aGlzO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFkZFVuZG9hYmxlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IGVkaXRvci5fdWlNYW5hZ2VyLnJlYnVpbGQoZWRpdG9yKTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0RWRpdG9yQnlVSUQodWlkKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci51aWQgPT09IHVpZCkge1xuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gIGdldCAjY3VycmVudEVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpO1xuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlID0gdGhpcy4jY3VycmVudEVkaXRvclR5cGU7XG4gICAgcmV0dXJuIGVkaXRvclR5cGUgPyBuZXcgZWRpdG9yVHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IocGFyYW1zKSA6IG51bGw7XG4gIH1cbiAgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpO1xuICB9XG4gIGFzeW5jIHBhc3RlRWRpdG9yKG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHRoaXMudXBkYXRlVG9vbGJhcihvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLiN1aU1hbmFnZXIudXBkYXRlTW9kZShvcHRpb25zLm1vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfSA9IHRoaXMuI2dldENlbnRlclBvaW50KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IG9mZnNldFgsXG4gICAgICB5OiBvZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgIHJldHVybiAoYXdhaXQgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQoZGF0YS5hbm5vdGF0aW9uVHlwZSA/PyBkYXRhLmFubm90YXRpb25FZGl0b3JUeXBlKT8uZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKSkgfHwgbnVsbDtcbiAgfVxuICBjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZCxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBib3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuYm91bmRpbmdDbGllbnRSZWN0O1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcihkYXRhID0ge30pIHtcbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlLCBkYXRhKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBwb2ludGVydXAoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlciAmJiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdXBwb3J0TXVsdGlwbGVEcmF3aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCk7XG4gICAgaWYgKGN1cnJlbnRNb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCB8fCBjdXJyZW50TW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyKSB7XG4gICAgICB0aGlzLnN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgdGhpcy4jYWxsb3dDbGljayA9ICFlZGl0b3IgfHwgZWRpdG9yLmlzRW1wdHkoKTtcbiAgfVxuICBzdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KSB7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24odGhpcyk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNkcmF3aW5nQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICh7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gIH1cbiAgcGF1c2Uob24pIHtcbiAgICBpZiAob24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IGRvY3VtZW50O1xuICAgICAgaWYgKHRoaXMuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQ/LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nU2Vzc2lvbihpc0Fib3J0ZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbihudWxsKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMuYWJvcnQoKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBudWxsO1xuICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGUuZW5kRHJhd2luZyhpc0Fib3J0ZWQpO1xuICB9XG4gIGZpbmROZXdQYXJlbnQoZWRpdG9yLCB4LCB5KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiN1aU1hbmFnZXIuZmluZFBhcmVudCh4LCB5KTtcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGF5ZXIuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgdGhpcy5lbmREcmF3aW5nU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcodGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKT8ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgICBlZGl0b3Iuc2V0UGFyZW50KG51bGwpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuI2VkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIH1cbiAgI2NsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGNvbnN0IG9sZFJvdGF0aW9uID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSk7XG4gICAgaWYgKG9sZFJvdGF0aW9uICE9PSByb3RhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3Iucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZHJhd19sYXllci5qc1xuXG5cbmNsYXNzIERyYXdMYXllciB7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjbWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgI3RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhZ2VJbmRleFxuICB9KSB7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy4jcGFyZW50KSB7XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNwYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI21hcHBpbmcuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc3ZnRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IERPTVNWR0ZhY3RvcnkoKSk7XG4gIH1cbiAgc3RhdGljICNzZXRCb3goZWxlbWVudCwgW3gsIHksIHdpZHRoLCBoZWlnaHRdKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoKSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkge1xuICAgIGNvbnN0IGNsaXBQYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGBjbGlwXyR7cGF0aElkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGNvbnN0IGNsaXBQYXRoVXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgY2xpcFBhdGguYXBwZW5kKGNsaXBQYXRoVXNlKTtcbiAgICBjbGlwUGF0aFVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgY2xpcFBhdGhVc2UuY2xhc3NMaXN0LmFkZChcImNsaXBcIik7XG4gICAgcmV0dXJuIGNsaXBQYXRoSWQ7XG4gIH1cbiAgI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KHByb3BlcnRpZXMsIGlzUGF0aFVwZGF0YWJsZSA9IGZhbHNlLCBoYXNDbGlwID0gZmFsc2UpIHtcbiAgICBjb25zdCBpZCA9IERyYXdMYXllci4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBpZiAoaXNQYXRoVXBkYXRhYmxlKSB7XG4gICAgICB0aGlzLiN0b1VwZGF0ZS5zZXQoaWQsIHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBjbGlwUGF0aElkID0gaGFzQ2xpcCA/IHRoaXMuI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkgOiBudWxsO1xuICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZSk7XG4gICAgdXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMocm9vdCwgcHJvcGVydGllcyk7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IGB1cmwoIyR7Y2xpcFBhdGhJZH0pYFxuICAgIH07XG4gIH1cbiAgZHJhd091dGxpbmUocHJvcGVydGllcywgbXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3QgaWQgPSBEcmF3TGF5ZXIuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgbGV0IG1hc2tJZDtcbiAgICBpZiAobXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgICBjb25zdCBtYXNrID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJtYXNrXCIpO1xuICAgICAgZGVmcy5hcHBlbmQobWFzayk7XG4gICAgICBtYXNrSWQgPSBgbWFza19wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtYXNrSWQpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJtYXNrVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBtYXNrLmFwcGVuZChyZWN0KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwid2hpdGVcIik7XG4gICAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHVzZSk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcImJsYWNrXCIpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImZpbGwtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgICB1c2UuY2xhc3NMaXN0LmFkZChcIm1hc2tcIik7XG4gICAgfVxuICAgIGNvbnN0IHVzZTEgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UxKTtcbiAgICB1c2UxLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBpZiAobWFza0lkKSB7XG4gICAgICB1c2UxLnNldEF0dHJpYnV0ZShcIm1hc2tcIiwgYHVybCgjJHttYXNrSWR9KWApO1xuICAgIH1cbiAgICBjb25zdCB1c2UyID0gdXNlMS5jbG9uZU5vZGUoKTtcbiAgICByb290LmFwcGVuZCh1c2UyKTtcbiAgICB1c2UxLmNsYXNzTGlzdC5hZGQoXCJtYWluT3V0bGluZVwiKTtcbiAgICB1c2UyLmNsYXNzTGlzdC5hZGQoXCJzZWNvbmRhcnlPdXRsaW5lXCIpO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhyb290LCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZpbmFsaXplRHJhdyhpZCwgcHJvcGVydGllcykge1xuICAgIHRoaXMuI3RvVXBkYXRlLmRlbGV0ZShpZCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKGlkLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnRPcklkLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBiYm94LFxuICAgICAgcm9vdENsYXNzLFxuICAgICAgcGF0aFxuICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9ySWQgPT09IFwibnVtYmVyXCIgPyB0aGlzLiNtYXBwaW5nLmdldChlbGVtZW50T3JJZCkgOiBlbGVtZW50T3JJZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcm9vdCk7XG4gICAgfVxuICAgIGlmIChiYm94KSB7XG4gICAgICBEcmF3TGF5ZXIuI3NldEJveChlbGVtZW50LCBiYm94KTtcbiAgICB9XG4gICAgaWYgKHJvb3RDbGFzcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0xpc3RcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgZm9yIChjb25zdCBbY2xhc3NOYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocm9vdENsYXNzKSkge1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aCkge1xuICAgICAgY29uc3QgZGVmcyA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgIGNvbnN0IHBhdGhFbGVtZW50ID0gZGVmcy5maXJzdENoaWxkO1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhwYXRoRWxlbWVudCwgcGF0aCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmVudChpZCwgbGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI21hcHBpbmcuZ2V0KGlkKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5ZXIuI3BhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgdGhpcy4jbWFwcGluZy5kZWxldGUoaWQpO1xuICAgIGxheWVyLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gIH1cbiAgcmVtb3ZlKGlkKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5yZW1vdmUoKTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICByb290LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmNsZWFyKCk7XG4gICAgdGhpcy4jdG9VcGRhdGUuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvcGRmLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbntcbiAgZ2xvYmFsVGhpcy5fcGRmanNUZXN0aW5nVXRpbHMgPSB7XG4gICAgSGlnaGxpZ2h0T3V0bGluZXI6IEhpZ2hsaWdodE91dGxpbmVyXG4gIH07XG59XG5nbG9iYWxUaGlzLnBkZmpzTGliID0ge1xuICBBYm9ydEV4Y2VwdGlvbjogQWJvcnRFeGNlcHRpb24sXG4gIEFubm90YXRpb25FZGl0b3JMYXllcjogQW5ub3RhdGlvbkVkaXRvckxheWVyLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsXG4gIEFubm90YXRpb25FZGl0b3JUeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZSxcbiAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjogQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgQW5ub3RhdGlvbkxheWVyOiBBbm5vdGF0aW9uTGF5ZXIsXG4gIEFubm90YXRpb25Nb2RlOiBBbm5vdGF0aW9uTW9kZSxcbiAgQW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25UeXBlLFxuICBhcHBseU9wYWNpdHk6IGFwcGx5T3BhY2l0eSxcbiAgYnVpbGQ6IGJ1aWxkLFxuICBDb2xvclBpY2tlcjogQ29sb3JQaWNrZXIsXG4gIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw6IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsXG4gIENTU0NvbnN0YW50czogQ1NTQ29uc3RhbnRzLFxuICBET01TVkdGYWN0b3J5OiBET01TVkdGYWN0b3J5LFxuICBEcmF3TGF5ZXI6IERyYXdMYXllcixcbiAgRmVhdHVyZVRlc3Q6IHV0aWxfRmVhdHVyZVRlc3QsXG4gIGZldGNoRGF0YTogZmV0Y2hEYXRhLFxuICBmaW5kQ29udHJhc3RDb2xvcjogZmluZENvbnRyYXN0Q29sb3IsXG4gIGdldERvY3VtZW50OiBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiBnZXRGaWxlbmFtZUZyb21VcmwsXG4gIGdldFBkZkZpbGVuYW1lRnJvbVVybDogZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLFxuICBnZXRSR0I6IGdldFJHQixcbiAgZ2V0VXVpZDogZ2V0VXVpZCxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiBnZXRYZmFQYWdlVmlld3BvcnQsXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6IEdsb2JhbFdvcmtlck9wdGlvbnMsXG4gIEltYWdlS2luZDogdXRpbF9JbWFnZUtpbmQsXG4gIEludmFsaWRQREZFeGNlcHRpb246IEludmFsaWRQREZFeGNlcHRpb24sXG4gIGlzRGF0YVNjaGVtZTogaXNEYXRhU2NoZW1lLFxuICBpc1BkZkZpbGU6IGlzUGRmRmlsZSxcbiAgaXNWYWxpZEV4cGxpY2l0RGVzdDogaXNWYWxpZEV4cGxpY2l0RGVzdCxcbiAgTWF0aENsYW1wOiBNYXRoQ2xhbXAsXG4gIG5vQ29udGV4dE1lbnU6IG5vQ29udGV4dE1lbnUsXG4gIG5vcm1hbGl6ZVVuaWNvZGU6IG5vcm1hbGl6ZVVuaWNvZGUsXG4gIE9QUzogT1BTLFxuICBPdXRwdXRTY2FsZTogT3V0cHV0U2NhbGUsXG4gIFBhc3N3b3JkUmVzcG9uc2VzOiBQYXNzd29yZFJlc3BvbnNlcyxcbiAgUERGRGF0YVJhbmdlVHJhbnNwb3J0OiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsXG4gIFBERkRhdGVTdHJpbmc6IFBERkRhdGVTdHJpbmcsXG4gIFBERldvcmtlcjogUERGV29ya2VyLFxuICBQZXJtaXNzaW9uRmxhZzogUGVybWlzc2lvbkZsYWcsXG4gIFBpeGVsc1BlckluY2g6IFBpeGVsc1BlckluY2gsXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLFxuICByZW5kZXJSaWNoVGV4dDogcmVuZGVyUmljaFRleHQsXG4gIFJlc3BvbnNlRXhjZXB0aW9uOiBSZXNwb25zZUV4Y2VwdGlvbixcbiAgc2V0TGF5ZXJEaW1lbnNpb25zOiBzZXRMYXllckRpbWVuc2lvbnMsXG4gIHNoYWRvdzogc2hhZG93LFxuICBTaWduYXR1cmVFeHRyYWN0b3I6IFNpZ25hdHVyZUV4dHJhY3RvcixcbiAgc3RvcEV2ZW50OiBzdG9wRXZlbnQsXG4gIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzOiBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyxcbiAgVGV4dExheWVyOiBUZXh0TGF5ZXIsXG4gIFRvdWNoTWFuYWdlcjogVG91Y2hNYW5hZ2VyLFxuICB1cGRhdGVVcmxIYXNoOiB1cGRhdGVVcmxIYXNoLFxuICBVdGlsOiBVdGlsLFxuICBWZXJib3NpdHlMZXZlbDogVmVyYm9zaXR5TGV2ZWwsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIFhmYUxheWVyOiBYZmFMYXllclxufTtcblxuZXhwb3J0IHsgQWJvcnRFeGNlcHRpb24sIEFubm90YXRpb25FZGl0b3JMYXllciwgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsIEFubm90YXRpb25FZGl0b3JUeXBlLCBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLCBBbm5vdGF0aW9uTGF5ZXIsIEFubm90YXRpb25Nb2RlLCBBbm5vdGF0aW9uVHlwZSwgQ1NTQ29uc3RhbnRzLCBDb2xvclBpY2tlciwgRE9NU1ZHRmFjdG9yeSwgRHJhd0xheWVyLCB1dGlsX0ZlYXR1cmVUZXN0IGFzIEZlYXR1cmVUZXN0LCBHbG9iYWxXb3JrZXJPcHRpb25zLCB1dGlsX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIEludmFsaWRQREZFeGNlcHRpb24sIE1hdGhDbGFtcCwgT1BTLCBPdXRwdXRTY2FsZSwgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBQREZEYXRlU3RyaW5nLCBQREZXb3JrZXIsIFBhc3N3b3JkUmVzcG9uc2VzLCBQZXJtaXNzaW9uRmxhZywgUGl4ZWxzUGVySW5jaCwgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBSZXNwb25zZUV4Y2VwdGlvbiwgU2lnbmF0dXJlRXh0cmFjdG9yLCBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcywgVGV4dExheWVyLCBUb3VjaE1hbmFnZXIsIFV0aWwsIFZlcmJvc2l0eUxldmVsLCBYZmFMYXllciwgYXBwbHlPcGFjaXR5LCBidWlsZCwgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCwgZmV0Y2hEYXRhLCBmaW5kQ29udHJhc3RDb2xvciwgZ2V0RG9jdW1lbnQsIGdldEZpbGVuYW1lRnJvbVVybCwgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLCBnZXRSR0IsIGdldFV1aWQsIGdldFhmYVBhZ2VWaWV3cG9ydCwgaXNEYXRhU2NoZW1lLCBpc1BkZkZpbGUsIGlzVmFsaWRFeHBsaWNpdERlc3QsIG5vQ29udGV4dE1lbnUsIG5vcm1hbGl6ZVVuaWNvZGUsIHJlbmRlclJpY2hUZXh0LCBzZXRMYXllckRpbWVuc2lvbnMsIHNoYWRvdywgc3RvcEV2ZW50LCB1cGRhdGVVcmxIYXNoLCB2ZXJzaW9uIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5tanMubWFwIl0sIm5hbWVzIjpbIl9fd2VicGFja19tb2R1bGVzX18iLCJtb2R1bGUiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiaXNDYWxsYWJsZSIsImV4cG9ydHMiLCJpdCIsImNhbGwiLCJhQ2FsbGFibGUiLCJhbk9iamVjdCIsInRyeVRvU3RyaW5nIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCIkVHlwZUVycm9yIiwiVHlwZUVycm9yIiwiYXJndW1lbnQiLCJ1c2luZ0l0ZXJhdG9yIiwiaXRlcmF0b3JNZXRob2QiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIiQiLCJpdGVyYXRlIiwiZ2V0SXRlcmF0b3JEaXJlY3QiLCJpdGVyYXRvckNsb3NlIiwiaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsImZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsInRhcmdldCIsInByb3RvIiwicmVhbCIsImZvcmNlZCIsImZpbmQiLCJwcmVkaWNhdGUiLCJlcnJvciIsInJlY29yZCIsImNvdW50ZXIiLCJ2YWx1ZSIsInN0b3AiLCJJU19SRUNPUkQiLCJJTlRFUlJVUFRFRCIsInJlc3VsdCIsInVuY3VycnlUaGlzIiwiZmFpbHMiLCJoYXNPd24iLCJERVNDUklQVE9SUyIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FIiwiQ09ORklHVVJBQkxFIiwiaW5zcGVjdFNvdXJjZSIsIkludGVybmFsU3RhdGVNb2R1bGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsImVuZm9yY2UiLCJnZXRJbnRlcm5hbFN0YXRlIiwiZ2V0IiwiJFN0cmluZyIsIlN0cmluZyIsImRlZmluZVByb3BlcnR5IiwiT2JqZWN0Iiwic3RyaW5nU2xpY2UiLCJzbGljZSIsInJlcGxhY2UiLCJqb2luIiwiQ09ORklHVVJBQkxFX0xFTkdUSCIsIlRFTVBMQVRFIiwic3BsaXQiLCJtYWtlQnVpbHRJbiIsIm5hbWUiLCJvcHRpb25zIiwiZ2V0dGVyIiwic2V0dGVyIiwiY29uZmlndXJhYmxlIiwiYXJpdHkiLCJjb25zdHJ1Y3RvciIsIndyaXRhYmxlIiwicHJvdG90eXBlIiwidW5kZWZpbmVkIiwic3RhdGUiLCJzb3VyY2UiLCJGdW5jdGlvbiIsInRvU3RyaW5nIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRVhJU1RTIiwiUFJPUEVSIiwic29tZXRoaW5nIiwiZ2V0QnVpbHRJbiIsImdsb2JhbFRoaXMiLCJhblVpbnQ4QXJyYXkiLCJub3REZXRhY2hlZCIsIm51bWJlclRvU3RyaW5nIiwiVWludDhBcnJheSIsIklOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTIiwidG9IZXgiLCJidWZmZXIiLCJpIiwiaGV4IiwiZm4iLCJJVEVSQVRPUl9JTlNURUFEX09GX1JFQ09SRCIsIml0ZXJhdG9yIiwibmV4dCIsInN0ZXAiLCJkb25lIiwiZ2V0SXRlcmF0b3JGbGF0dGVuYWJsZSIsImNyZWF0ZUl0ZXJhdG9yUHJveHkiLCJJU19QVVJFIiwiaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciIsIkZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiIsImZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsIkZPUkNFRCIsIkl0ZXJhdG9yUHJveHkiLCJtYXBwZXIiLCJpbm5lciIsImZsYXRNYXAiLCJ0ZXN0IiwiYmluZCIsImhhc093blByb3BlcnR5IiwiY2xhc3NvZiIsImlzUHJvdG90eXBlT2YiLCJQcm90b3R5cGUiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiSXRlcmF0b3IiLCJjZWlsIiwiTWF0aCIsImZsb29yIiwidHJ1bmMiLCJ4IiwibiIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiJE9iamVjdCIsIiRTeW1ib2wiLCJnZXRNZXRob2QiLCJpc051bGxPclVuZGVmaW5lZCIsIkl0ZXJhdG9ycyIsIndlbGxLbm93blN5bWJvbCIsIklURVJBVE9SIiwiYWxwaGFiZXQiLCJpbnRlcm5hbE9iamVjdEtleXMiLCJlbnVtQnVnS2V5cyIsImtleXMiLCJPIiwiZXhlYyIsImtsYXNzIiwiZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsImV2ZXJ5Iiwic3RvcHBlZCIsIk5BVElWRV9XRUFLX01BUCIsImlzT2JqZWN0IiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5Iiwic2hhcmVkIiwic2hhcmVkS2V5IiwiaGlkZGVuS2V5cyIsIk9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEIiwiV2Vha01hcCIsInNldCIsImhhcyIsImdldHRlckZvciIsIlRZUEUiLCJ0eXBlIiwic3RvcmUiLCJtZXRhZGF0YSIsImZhY2FkZSIsIlNUQVRFIiwibnVtYmVyIiwiaXRlcnMiLCJraW5kIiwiVjgiLCJFTlZJUk9OTUVOVCIsInN0cnVjdHVyZWRDbG9uZSIsIkFycmF5QnVmZmVyIiwiY2xvbmUiLCJ0cmFuc2ZlciIsImJ5dGVMZW5ndGgiLCJhcHBseSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlIiwicGVyZm9ybSIsIlByb21pc2UiLCJBQ0NFUFRfQVJHVU1FTlRTIiwic3RhdCIsImNhbGxiYWNrZm4iLCJhcmdzIiwicHJvbWlzZUNhcGFiaWxpdHkiLCJmIiwicmVqZWN0IiwicmVzb2x2ZSIsInByb21pc2UiLCJ1bmlvbiIsInNldE1ldGhvZEdldEtleXNCZWZvcmVDbG9uaW5nIiwic2V0TWV0aG9kQWNjZXB0U2V0TGlrZSIsImNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmciLCJNQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIiwibWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJtYXAiLCJvYmoiLCJ0b0luZGV4ZWRPYmplY3QiLCJpbmRleE9mIiwicHVzaCIsIm9iamVjdCIsIm5hbWVzIiwia2V5IiwiZGVzY3JpcHRvciIsIlRPX1NUUklOR19UQUciLCJGIiwiZ2V0UHJvdG90eXBlT2YiLCJTeW50YXhFcnJvciIsInBhcnNlSW50IiwibWluIiwiTk9UX0hFWCIsInN0cmluZyIsImludG8iLCJzdHJpbmdMZW5ndGgiLCJtYXhMZW5ndGgiLCJieXRlcyIsInJlYWQiLCJ3cml0dGVuIiwiaGV4aXRzIiwiZGVmaW5lUHJvcGVydGllc01vZHVsZSIsImh0bWwiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJHVCIsIkxUIiwiUFJPVE9UWVBFIiwiU0NSSVBUIiwiSUVfUFJPVE8iLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJkb2N1bWVudCIsIm9wZW4iLCJOdWxsUHJvdG9PYmplY3QiLCJBY3RpdmVYT2JqZWN0IiwiZG9tYWluIiwiY3JlYXRlIiwiUHJvcGVydGllcyIsImlzU3VwZXJzZXRPZiIsIklOQ09SUkVDVCIsIkZJTFRFUl9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IiLCJmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsImZpbHRlciIsIiRkZWZhdWx0IiwiaXNBcnJheUl0ZXJhdG9yTWV0aG9kIiwibGVuZ3RoT2ZBcnJheUxpa2UiLCJnZXRJdGVyYXRvciIsIlJlc3VsdCIsIlJlc3VsdFByb3RvdHlwZSIsIml0ZXJhYmxlIiwidW5ib3VuZEZ1bmN0aW9uIiwidGhhdCIsIkFTX0VOVFJJRVMiLCJJU19JVEVSQVRPUiIsIml0ZXJGbiIsImluZGV4IiwiY29uZGl0aW9uIiwiY2FsbEZuIiwiaXNTeW1ib2wiLCJvcmRpbmFyeVRvUHJpbWl0aXZlIiwiVE9fUFJJTUlUSVZFIiwiaW5wdXQiLCJwcmVmIiwiZXhvdGljVG9QcmltIiwidG9PYmplY3QiLCJDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIiLCJPYmplY3RQcm90b3R5cGUiLCJyZXBsYWNlbWVudCIsImlzRm9yY2VkIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInRvTG93ZXJDYXNlIiwiY29tbW9uQWxwaGFiZXQiLCJiYXNlNjRBbHBoYWJldCIsImJhc2U2NFVybEFscGhhYmV0IiwiaW52ZXJzZSIsImNoYXJhY3RlcnMiLCJjaGFyQXQiLCJpMmMiLCJjMmkiLCJpMmNVcmwiLCJjMmlVcmwiLCJwYXNzZWQiLCJyZXF1aXJlZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVuY3VycnlUaGlzQWNjZXNzb3IiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwiYVBvc3NpYmxlUHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsIkFycmF5IiwiX19wcm90b19fIiwiJFJhbmdlRXJyb3IiLCJSYW5nZUVycm9yIiwiJEluZmluaXR5IiwiSW5maW5pdHkiLCIkTmFOIiwiTmFOIiwiYWJzIiwicG93IiwiUE9XXzJfMTAyMyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNQVhfRE9VQkxFIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiTUFYX1VMUCIsIk5PVF9BX05VTUJFUiIsIk1JTlVTX0lORklOSVRZIiwiUExVU19JTkZJTklUWSIsIk1JTlVTX1pFUk8iLCJGSU5JVEUiLCJ0d29zdW0iLCJ5IiwiaGkiLCJsbyIsInN1bVByZWNpc2UiLCJpdGVtcyIsIm51bWJlcnMiLCJjb3VudCIsInBhcnRpYWxzIiwib3ZlcmZsb3ciLCJzdW0iLCJ0bXAiLCJhY3R1YWxseVVzZWRQYXJ0aWFscyIsImoiLCJzaWduIiwiJHRoaXMiLCJkdW1teSIsIldyYXBwZXIiLCJOZXdUYXJnZXQiLCJOZXdUYXJnZXRQcm90b3R5cGUiLCJOQVRJVkVfQVJSQVlfQlVGRkVSIiwiYXJyYXlCdWZmZXJCeXRlTGVuZ3RoIiwiRGF0YVZpZXciLCJpZCIsInBvc3RmaXgiLCJyYW5kb20iLCJhU2V0IiwiU2V0SGVscGVycyIsInNpemUiLCJnZXRTZXRSZWNvcmQiLCJpdGVyYXRlU2V0IiwiaXRlcmF0ZVNpbXBsZSIsInJlbW92ZSIsImRpZmZlcmVuY2UiLCJvdGhlciIsIm90aGVyUmVjIiwiZSIsImluY2x1ZGVzIiwiaXNQb3NzaWJsZVByb3RvdHlwZSIsInNvbWVXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsInNvbWUiLCJhZGQiLCJzeW1tZXRyaWNEaWZmZXJlbmNlIiwia2V5c0l0ZXIiLCJmdW5jdGlvblRvU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwidG9JbnRlZ2VyT3JJbmZpbml0eSIsIklOVkFMSURfU0laRSIsIm1heCIsIlNldFJlY29yZCIsImludFNpemUiLCJudW1TaXplIiwiaXNTdWJzZXRPZiIsImlzRGlzam9pbnRGcm9tIiwiY3JlYXRlRWxlbWVudCIsInNldEFycmF5TGVuZ3RoIiwiZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyIiwiSU5DT1JSRUNUX1RPX0xFTkdUSCIsInByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCIsIml0ZW0iLCJsZW4iLCJhcmdDb3VudCIsIkFycmF5UHJvdG90eXBlIiwidXNlckFnZW50U3RhcnRzV2l0aCIsIkJ1biIsInZlcnNpb24iLCJEZW5vIiwicHJvY2VzcyIsIndpbmRvdyIsImFTdHJpbmciLCIkZnJvbUhleCIsInNldEZyb21IZXgiLCJ2YWwiLCJ2YWx1ZU9mIiwiaXNBcnJheSIsIlNldFByb3RvdHlwZSIsIlNldCIsImdldEJ1aWx0SW5Ob2RlTW9kdWxlIiwiUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIiLCIkQXJyYXlCdWZmZXIiLCIkTWVzc2FnZUNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsImRldGFjaCIsIldvcmtlclRocmVhZHMiLCJjaGFubmVsIiwiJGRldGFjaCIsInRyYW5zZmVyYWJsZSIsInBvcnQxIiwicG9zdE1lc3NhZ2UiLCJWOF9WRVJTSU9OIiwic3ltYm9sIiwiU3ltYm9sIiwic2hhbSIsIlNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCIsIk1FVEhPRF9OQU1FIiwiRXhwZWN0ZWRFcnJvciIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiQ0xPU0VEIiwiY2hlY2siLCJzZWxmIiwiZ2xvYmFsIiwiZGVmaW5lQnVpbHRJbiIsInZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoIiwiJFVSTFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSIsImFwcGVuZCIsIiRkZWxldGUiLCJmb3JFYWNoIiwicGFyYW1zIiwiJHZhbHVlIiwiZW50cmllcyIsInYiLCJrIiwiZGluZGV4IiwiZm91bmQiLCJlbnRyaWVzTGVuZ3RoIiwiZW50cnkiLCJlbnVtZXJhYmxlIiwidW5zYWZlIiwid2l0aFJlc29sdmVycyIsImRlZmluZUJ1aWx0SW5BY2Nlc3NvciIsInVpZCIsIkludDhBcnJheSIsIkludDhBcnJheVByb3RvdHlwZSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUiLCJUeXBlZEFycmF5IiwiVHlwZWRBcnJheVByb3RvdHlwZSIsIlRZUEVEX0FSUkFZX1RBRyIsIlRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SIiwiTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyIsIm9wZXJhIiwiVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEIiwiTkFNRSIsIkNvbnN0cnVjdG9yIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJpc1ZpZXciLCJnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJpc1R5cGVkQXJyYXkiLCJhVHlwZWRBcnJheSIsImFUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJDIiwiZXhwb3J0VHlwZWRBcnJheU1ldGhvZCIsIktFWSIsInByb3BlcnR5IiwiQVJSQVkiLCJUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJlcnJvcjIiLCJleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJkb2N1bWVudEFsbCIsImFsbCIsIklFOF9ET01fREVGSU5FIiwiVjhfUFJPVE9UWVBFX0RFRklORV9CVUciLCJ0b1Byb3BlcnR5S2V5IiwiJGRlZmluZVByb3BlcnR5IiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkVOVU1FUkFCTEUiLCJXUklUQUJMRSIsIlAiLCJBdHRyaWJ1dGVzIiwiY3VycmVudCIsImNyZWF0ZVNldExpa2UiLCJjcmVhdGVTZXRMaWtlV2l0aEluZmluaXR5U2l6ZSIsIkVycm9yIiwiY2FsbGJhY2siLCJub3RBTmFOIiwidG9Qb3NpdGl2ZUludGVnZXIiLCJ0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJyZW1haW5pbmciLCJ0YWtlIiwibGltaXQiLCJhbkluc3RhbmNlIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJub3JtYWxpemVTdHJpbmdBcmd1bWVudCIsIkRPTUV4Y2VwdGlvbkNvbnN0YW50cyIsImNsZWFyRXJyb3JTdGFjayIsIkRPTV9FWENFUFRJT04iLCJOYXRpdmVET01FeGNlcHRpb24iLCIkRE9NRXhjZXB0aW9uIiwiRE9NRXhjZXB0aW9uIiwiRE9NRXhjZXB0aW9uUHJvdG90eXBlIiwiYXJndW1lbnRzTGVuZ3RoIiwibWVzc2FnZSIsInN0YWNrIiwiRVJST1JfSEFTX1NUQUNLIiwiRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0siLCJCVUdHWV9ERVNDUklQVE9SIiwiRk9SQ0VEX0NPTlNUUlVDVE9SIiwiUG9seWZpbGxlZERPTUV4Y2VwdGlvbiIsIlBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUiLCJjb25zdGFudCIsImNvbnN0YW50TmFtZSIsInMiLCJjIiwiSW5kZXhTaXplRXJyb3IiLCJtIiwiRE9NU3RyaW5nU2l6ZUVycm9yIiwiSGllcmFyY2h5UmVxdWVzdEVycm9yIiwiV3JvbmdEb2N1bWVudEVycm9yIiwiSW52YWxpZENoYXJhY3RlckVycm9yIiwiTm9EYXRhQWxsb3dlZEVycm9yIiwiTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiTm90U3VwcG9ydGVkRXJyb3IiLCJJblVzZUF0dHJpYnV0ZUVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IiLCJOYW1lc3BhY2VFcnJvciIsIkludmFsaWRBY2Nlc3NFcnJvciIsIlZhbGlkYXRpb25FcnJvciIsIlR5cGVNaXNtYXRjaEVycm9yIiwiU2VjdXJpdHlFcnJvciIsIk5ldHdvcmtFcnJvciIsIkFib3J0RXJyb3IiLCJVUkxNaXNtYXRjaEVycm9yIiwiUXVvdGFFeGNlZWRlZEVycm9yIiwiVGltZW91dEVycm9yIiwiSW52YWxpZE5vZGVUeXBlRXJyb3IiLCJEYXRhQ2xvbmVFcnJvciIsImdldE93blByb3BlcnR5TmFtZXNNb2R1bGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJjb25jYXQiLCJvd25LZXlzIiwiaXNEZXRhY2hlZCIsImFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdCIsIiRmcm9tQmFzZTY0IiwiZnJvbUJhc2U2NCIsImxpc3QiLCIkbGVuZ3RoIiwiSW5kZXhlZE9iamVjdCIsImludGVnZXIiLCJ0b0luZGV4IiwiZGV0YWNoVHJhbnNmZXJhYmxlIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUiLCJEYXRhVmlld1Byb3RvdHlwZSIsImlzUmVzaXphYmxlIiwibWF4Qnl0ZUxlbmd0aCIsImdldEludDgiLCJzZXRJbnQ4IiwiYXJyYXlCdWZmZXIiLCJuZXdMZW5ndGgiLCJwcmVzZXJ2ZVJlc2l6YWJpbGl0eSIsIm5ld0J5dGVMZW5ndGgiLCJmaXhlZExlbmd0aCIsIm5ld0J1ZmZlciIsImEiLCJiIiwiY29weUxlbmd0aCIsIlVTRV9OQVRJVkVfVVJMIiwiVVJMIiwicGFyc2UiLCJ1cmwiLCJ1cmxTdHJpbmciLCJiYXNlIiwidG9QcmltaXRpdmUiLCJwcmltIiwiQmlnSW50IiwiViIsImZ1bmMiLCJQcm9taXNlQ2FwYWJpbGl0eSIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiTkFUSVZFX0JJTkQiLCJ0b0xlbmd0aCIsIkVOVFJJRVMiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJ0YXJnZXRQcm9wZXJ0eSIsInNvdXJjZVByb3BlcnR5IiwiZG9udENhbGxHZXRTZXQiLCJkZXRhY2hlZCIsInNldEZyb21CYXNlNjQiLCJvYmplY3RLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwic2ltcGxlIiwibm9uQ29uZmlndXJhYmxlIiwibm9uV3JpdGFibGUiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJjbGFzc29mUmF3IiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJ0YWciLCJjYWxsZWUiLCJiaXRtYXAiLCJOQVRJVkVfU1lNQk9MIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsInNlYXJjaFBhcmFtcyIsInBhcmFtczIiLCJwYXRobmFtZSIsInRvSlNPTiIsInNvcnQiLCJocmVmIiwidXNlcm5hbWUiLCJob3N0IiwiaGFzaCIsImdldEFsbCIsIiRoYXMiLCJ2YWx1ZXMiLCJmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJTSEFSRUQiLCJ2ZXJzaW9ucyIsIm1vZGUiLCJjb3B5cmlnaHQiLCJsaWNlbnNlIiwiU0VUX0xJS0VfSU5DT1JSRUNUX0JFSEFWSU9SIiwic2V0TGlrZSIsImJhc2VTZXQiLCJjbGVhciIsIkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMiLCJQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yIiwiTkVXX0lURVJBVE9SX1BST1RPVFlQRSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSIsImV4Y2VwdGlvbnMiLCJhRnVuY3Rpb24iLCJuYW1lc3BhY2UiLCIkdHJhbnNmZXIiLCJ0cmFuc2ZlclRvRml4ZWRMZW5ndGgiLCJpbnRlcnNlY3Rpb24iLCJmcm9tIiwiY3JlYXRlUHJvcGVydHkiLCJDT05TVFJVQ1RPUiIsIk5hdGl2ZUl0ZXJhdG9yIiwiSXRlcmF0b3JDb25zdHJ1Y3RvciIsImRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IiLCJXZWxsS25vd25TeW1ib2xzU3RvcmUiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwiJFN5bnRheEVycm9yIiwiJHBhcnNlSW50IiwiZnJvbUNoYXJDb2RlIiwiYXQiLCJjb2RlUG9pbnRzIiwiSVNfNF9IRVhfRElHSVRTIiwiSVNfQzBfQ09OVFJPTF9DT0RFIiwidW50ZXJtaW5hdGVkIiwiY2hyIiwidHdvQ2hhcnMiLCJmb3VySGV4RGlnaXRzIiwiZW5kIiwiRkFJTFNfT05fSU5JVElBTF9VTkRFRklORUQiLCJyZWR1Y2UiLCJyZWR1Y2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsInJlZHVjZXIiLCJub0luaXRpYWwiLCJhY2N1bXVsYXRvciIsInBhcnNlSlNPTlN0cmluZyIsIkpTT04iLCJuYXRpdmVQYXJzZSIsImVudW1lcmFibGVPd25Qcm9wZXJ0aWVzIiwiSVNfRElHSVQiLCJJU19OT05fWkVST19ESUdJVCIsIklTX05VTUJFUl9TVEFSVCIsIklTX1dISVRFU1BBQ0UiLCJQUklNSVRJVkUiLCJPQkpFQ1QiLCIkcGFyc2UiLCJyZXZpdmVyIiwiY29udGV4dCIsIkNvbnRleHQiLCJyb290IiwiZW5kSW5kZXgiLCJza2lwIiwiaW50ZXJuYWxpemUiLCJob2xkZXIiLCJub2RlIiwidW5tb2RpZmllZCIsImVsZW1lbnRSZWNvcmRzTGVuIiwibm9kZUlzQXJyYXkiLCJub2RlcyIsImludGVybmFsaXplUHJvcGVydHkiLCJOb2RlIiwiZm9yayIsIm5leHRJbmRleCIsImFycmF5Iiwia2V5d29yZCIsInN0YXJ0IiwiZXhwZWN0S2V5cGFpciIsInVudGlsIiwiZXhwZWN0RWxlbWVudCIsInBhcnNlZCIsInN0YXJ0SW5kZXgiLCJleHBvbmVudFN0YXJ0SW5kZXgiLCJyZWdleCIsIk5PX1NPVVJDRV9TVVBQT1JUIiwidW5zYWZlSW50IiwiUFJPUEVSX0JBU0VfUEFSU0UiLCJ0ZXh0IiwiaW50ZXJydXB0aWJsZSIsImdldE93blByb3BlcnR5TmFtZXMiLCIkRXJyb3IiLCJURVNUIiwiYXJnIiwiVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZIiwiSVNfVjhfT1JfQ0hBS1JBX1NUQUNLIiwiZHJvcEVudHJpZXMiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInN0cmluZ0hhbmRsaW5nIiwiUmVmbGVjdCIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIk5BU0hPUk5fQlVHIiwiYW5PYmplY3RPclVuZGVmaW5lZCIsImJhc2U2NE1hcCIsImdldEFscGhhYmV0T3B0aW9uIiwic2tpcEFzY2lpV2hpdGVzcGFjZSIsImRlY29kZUJhc2U2NENodW5rIiwiY2h1bmsiLCJ0aHJvd09uRXh0cmFCaXRzIiwiY2h1bmtMZW5ndGgiLCJ0cmlwbGV0IiwiY2h1bmtCeXRlcyIsIndyaXRlQnl0ZXMiLCJlbGVtZW50cyIsImVsZW1lbnRzTGVuZ3RoIiwibGFzdENodW5rSGFuZGxpbmciLCJyZW1haW5pbmdCeXRlcyIsIkRST1BfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIiwiZHJvcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZHJvcCIsIklTX05PREUiLCJnZXRCdWlsdGluTW9kdWxlIiwiZGVmaW5lQnVpbHRJbnMiLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0IiwiaXRlcmF0b3JDbG9zZUFsbCIsIklURVJBVE9SX0hFTFBFUiIsIldSQVBfRk9SX1ZBTElEX0lURVJBVE9SIiwiTk9STUFMIiwiVEhST1ciLCJzZXRJbnRlcm5hbFN0YXRlIiwiY3JlYXRlSXRlcmF0b3JQcm94eVByb3RvdHlwZSIsIm5leHRIYW5kbGVyIiwicmV0dXJuSGFuZGxlclJlc3VsdCIsInJldHVybk1ldGhvZCIsIm9wZW5JdGVycyIsIldyYXBGb3JWYWxpZEl0ZXJhdG9yUHJvdG90eXBlIiwiSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUiLCJSRVRVUk5fSEFORExFUl9SRVNVTFQiLCJ0b0Jhc2U2NCIsIm9taXRQYWRkaW5nIiwic2hpZnQiLCJ1bmN1cnJ5VGhpc1dpdGhCaW5kIiwidjgiLCJtYXRjaCIsImlubmVyUmVzdWx0IiwiaW5uZXJFcnJvciIsImFycmF5V2l0aCIsIkFycmF5QnVmZmVyVmlld0NvcmUiLCJpc0JpZ0ludEFycmF5IiwidG9CaWdJbnQiLCJQUk9QRVJfT1JERVIiLCJUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYIiwicmVsYXRpdmVJbmRleCIsImFjdHVhbFZhbHVlIiwidG9BYnNvbHV0ZUluZGV4IiwiY3JlYXRlTWV0aG9kIiwiSVNfSU5DTFVERVMiLCJlbCIsImZyb21JbmRleCIsImFjdHVhbEluZGV4IiwiQSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiZCIsImRlZmluaXRpb24iLCJvIiwicHJvcCIsIl9fd2VicGFja19leHBvcnRzX18iLCJlc19hcnJheV9wdXNoIiwiZXNfYXJyYXlfYnVmZmVyX2RldGFjaGVkIiwiZXNfYXJyYXlfYnVmZmVyX3RyYW5zZmVyIiwiZXNfYXJyYXlfYnVmZmVyX3RyYW5zZmVyX3RvX2ZpeGVkX2xlbmd0aCIsImVzX2l0ZXJhdG9yX2NvbnN0cnVjdG9yIiwiZXNfaXRlcmF0b3JfcmVkdWNlIiwiZXNfcHJvbWlzZV90cnkiLCJlc190eXBlZF9hcnJheV93aXRoIiwiZXNuZXh0X21hdGhfc3VtX3ByZWNpc2UiLCJlc25leHRfdWludDhfYXJyYXlfZnJvbV9iYXNlNjQiLCJlc25leHRfdWludDhfYXJyYXlfc2V0X2Zyb21fYmFzZTY0IiwiZXNuZXh0X3VpbnQ4X2FycmF5X3NldF9mcm9tX2hleCIsImVzbmV4dF91aW50OF9hcnJheV90b19iYXNlNjQiLCJlc25leHRfdWludDhfYXJyYXlfdG9faGV4Iiwid2ViX2RvbV9leGNlcHRpb25fc3RhY2siLCJ3ZWJfdXJsX3BhcnNlIiwiaXNOb2RlSlMiLCJudyIsImVsZWN0cm9uIiwiRk9OVF9JREVOVElUWV9NQVRSSVgiLCJMSU5FX0ZBQ1RPUiIsIkxJTkVfREVTQ0VOVF9GQUNUT1IiLCJCQVNFTElORV9GQUNUT1IiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJJU19FRElUSU5HIiwiT1BMSVNUIiwiQW5ub3RhdGlvbk1vZGUiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJBbm5vdGF0aW9uRWRpdG9yUHJlZml4IiwiQW5ub3RhdGlvbkVkaXRvclR5cGUiLCJOT05FIiwiRlJFRVRFWFQiLCJISUdITElHSFQiLCJTVEFNUCIsIklOSyIsIlBPUFVQIiwiU0lHTkFUVVJFIiwiQ09NTUVOVCIsIkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiUkVTSVpFIiwiQ1JFQVRFIiwiRlJFRVRFWFRfU0laRSIsIkZSRUVURVhUX0NPTE9SIiwiRlJFRVRFWFRfT1BBQ0lUWSIsIklOS19DT0xPUiIsIklOS19USElDS05FU1MiLCJJTktfT1BBQ0lUWSIsIkhJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9USElDS05FU1MiLCJISUdITElHSFRfRlJFRSIsIkhJR0hMSUdIVF9TSE9XX0FMTCIsIkRSQVdfU1RFUCIsIlBlcm1pc3Npb25GbGFnIiwiTU9ESUZZX0NPTlRFTlRTIiwiQ09QWSIsIk1PRElGWV9BTk5PVEFUSU9OUyIsIkZJTExfSU5URVJBQ1RJVkVfRk9STVMiLCJDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZIiwiQVNTRU1CTEUiLCJQUklOVF9ISUdIX1FVQUxJVFkiLCJUZXh0UmVuZGVyaW5nTW9kZSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfTUFTSyIsIkFERF9UT19QQVRIX0ZMQUciLCJ1dGlsX0ltYWdlS2luZCIsIkdSQVlTQ0FMRV8xQlBQIiwiUkdCXzI0QlBQIiwiUkdCQV8zMkJQUCIsIkFubm90YXRpb25UeXBlIiwiVEVYVCIsIkxJTksiLCJMSU5FIiwiU1FVQVJFIiwiQ0lSQ0xFIiwiUE9MWUdPTiIsIlBPTFlMSU5FIiwiVU5ERVJMSU5FIiwiU1FVSUdHTFkiLCJTVFJJS0VPVVQiLCJDQVJFVCIsIkZJTEVBVFRBQ0hNRU5UIiwiU09VTkQiLCJNT1ZJRSIsIldJREdFVCIsIlNDUkVFTiIsIlBSSU5URVJNQVJLIiwiVFJBUE5FVCIsIldBVEVSTUFSSyIsIlRIUkVFRCIsIlJFREFDVCIsIkFubm90YXRpb25SZXBseVR5cGUiLCJHUk9VUCIsIlJFUExZIiwiQW5ub3RhdGlvbkZsYWciLCJISURERU4iLCJOT1pPT00iLCJOT1JPVEFURSIsIk5PVklFVyIsIlJFQURPTkxZIiwiTE9DS0VEIiwiVE9HR0xFTk9WSUVXIiwiTE9DS0VEQ09OVEVOVFMiLCJBbm5vdGF0aW9uRmllbGRGbGFnIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIiwiU09MSUQiLCJEQVNIRUQiLCJCRVZFTEVEIiwiSU5TRVQiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiRSIsIlgiLCJEIiwiVSIsIkZvIiwiQmwiLCJQTyIsIlBDIiwiUFYiLCJQSSIsIksiLCJEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSIsIldDIiwiV1MiLCJEUyIsIldQIiwiRFAiLCJQYWdlQWN0aW9uRXZlbnRUeXBlIiwiVmVyYm9zaXR5TGV2ZWwiLCJFUlJPUlMiLCJXQVJOSU5HUyIsIklORk9TIiwiT1BTIiwiZGVwZW5kZW5jeSIsInNldExpbmVXaWR0aCIsInNldExpbmVDYXAiLCJzZXRMaW5lSm9pbiIsInNldE1pdGVyTGltaXQiLCJzZXREYXNoIiwic2V0UmVuZGVyaW5nSW50ZW50Iiwic2V0RmxhdG5lc3MiLCJzZXRHU3RhdGUiLCJzYXZlIiwicmVzdG9yZSIsInRyYW5zZm9ybSIsIm1vdmVUbyIsImxpbmVUbyIsImN1cnZlVG8iLCJjdXJ2ZVRvMiIsImN1cnZlVG8zIiwiY2xvc2VQYXRoIiwicmVjdGFuZ2xlIiwic3Ryb2tlIiwiY2xvc2VTdHJva2UiLCJmaWxsIiwiZW9GaWxsIiwiZmlsbFN0cm9rZSIsImVvRmlsbFN0cm9rZSIsImNsb3NlRmlsbFN0cm9rZSIsImNsb3NlRU9GaWxsU3Ryb2tlIiwiZW5kUGF0aCIsImNsaXAiLCJlb0NsaXAiLCJiZWdpblRleHQiLCJlbmRUZXh0Iiwic2V0Q2hhclNwYWNpbmciLCJzZXRXb3JkU3BhY2luZyIsInNldEhTY2FsZSIsInNldExlYWRpbmciLCJzZXRGb250Iiwic2V0VGV4dFJlbmRlcmluZ01vZGUiLCJzZXRUZXh0UmlzZSIsIm1vdmVUZXh0Iiwic2V0TGVhZGluZ01vdmVUZXh0Iiwic2V0VGV4dE1hdHJpeCIsIm5leHRMaW5lIiwic2hvd1RleHQiLCJzaG93U3BhY2VkVGV4dCIsIm5leHRMaW5lU2hvd1RleHQiLCJuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dCIsInNldENoYXJXaWR0aCIsInNldENoYXJXaWR0aEFuZEJvdW5kcyIsInNldFN0cm9rZUNvbG9yU3BhY2UiLCJzZXRGaWxsQ29sb3JTcGFjZSIsInNldFN0cm9rZUNvbG9yIiwic2V0U3Ryb2tlQ29sb3JOIiwic2V0RmlsbENvbG9yIiwic2V0RmlsbENvbG9yTiIsInNldFN0cm9rZUdyYXkiLCJzZXRGaWxsR3JheSIsInNldFN0cm9rZVJHQkNvbG9yIiwic2V0RmlsbFJHQkNvbG9yIiwic2V0U3Ryb2tlQ01ZS0NvbG9yIiwic2V0RmlsbENNWUtDb2xvciIsInNoYWRpbmdGaWxsIiwiYmVnaW5JbmxpbmVJbWFnZSIsImJlZ2luSW1hZ2VEYXRhIiwiZW5kSW5saW5lSW1hZ2UiLCJwYWludFhPYmplY3QiLCJtYXJrUG9pbnQiLCJtYXJrUG9pbnRQcm9wcyIsImJlZ2luTWFya2VkQ29udGVudCIsImJlZ2luTWFya2VkQ29udGVudFByb3BzIiwiZW5kTWFya2VkQ29udGVudCIsImJlZ2luQ29tcGF0IiwiZW5kQ29tcGF0IiwicGFpbnRGb3JtWE9iamVjdEJlZ2luIiwicGFpbnRGb3JtWE9iamVjdEVuZCIsImJlZ2luR3JvdXAiLCJlbmRHcm91cCIsImJlZ2luQW5ub3RhdGlvbiIsImVuZEFubm90YXRpb24iLCJwYWludEltYWdlTWFza1hPYmplY3QiLCJwYWludEltYWdlTWFza1hPYmplY3RHcm91cCIsInBhaW50SW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3RSZXBlYXQiLCJwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQiLCJwYWludFNvbGlkQ29sb3JJbWFnZU1hc2siLCJjb25zdHJ1Y3RQYXRoIiwic2V0U3Ryb2tlVHJhbnNwYXJlbnQiLCJzZXRGaWxsVHJhbnNwYXJlbnQiLCJyYXdGaWxsUGF0aCIsIkRyYXdPUFMiLCJQYXNzd29yZFJlc3BvbnNlcyIsIk5FRURfUEFTU1dPUkQiLCJJTkNPUlJFQ1RfUEFTU1dPUkQiLCJ2ZXJib3NpdHkiLCJzZXRWZXJib3NpdHlMZXZlbCIsImxldmVsIiwiaXNJbnRlZ2VyIiwiZ2V0VmVyYm9zaXR5TGV2ZWwiLCJpbmZvIiwibXNnIiwiY29uc29sZSIsIndhcm4iLCJ1bnJlYWNoYWJsZSIsImFzc2VydCIsImNvbmQiLCJfaXNWYWxpZFByb3RvY29sIiwicHJvdG9jb2wiLCJjcmVhdGVWYWxpZEFic29sdXRlVXJsIiwiYmFzZVVybCIsImFkZERlZmF1bHRQcm90b2NvbCIsInN0YXJ0c1dpdGgiLCJkb3RzIiwidHJ5Q29udmVydEVuY29kaW5nIiwic3RyaW5nVG9VVEY4U3RyaW5nIiwiYWJzb2x1dGVVcmwiLCJ1cGRhdGVVcmxIYXNoIiwiYWxsb3dSZWwiLCJyZXMiLCJzaGFkb3ciLCJub25TZXJpYWxpemFibGUiLCJCYXNlRXhjZXB0aW9uIiwiQmFzZUV4Y2VwdGlvbkNsb3N1cmUiLCJQYXNzd29yZEV4Y2VwdGlvbiIsImNvZGUiLCJVbmtub3duRXJyb3JFeGNlcHRpb24iLCJkZXRhaWxzIiwiSW52YWxpZFBERkV4Y2VwdGlvbiIsIlJlc3BvbnNlRXhjZXB0aW9uIiwic3RhdHVzIiwibWlzc2luZyIsIkZvcm1hdEVycm9yIiwiQWJvcnRFeGNlcHRpb24iLCJieXRlc1RvU3RyaW5nIiwiTUFYX0FSR1VNRU5UX0NPVU5UIiwic3RyQnVmIiwiY2h1bmtFbmQiLCJzdWJhcnJheSIsInN0cmluZ1RvQnl0ZXMiLCJzdHIiLCJjaGFyQ29kZUF0Iiwic3RyaW5nMzIiLCJvYmplY3RTaXplIiwiaXNMaXR0bGVFbmRpYW4iLCJidWZmZXI4IiwidmlldzMyIiwiaXNFdmFsU3VwcG9ydGVkIiwidXRpbF9GZWF0dXJlVGVzdCIsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwiaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQiLCJJbWFnZURlY29kZXIiLCJwbGF0Zm9ybSIsImlzQW5kcm9pZCIsImlzTGludXgiLCJpc01hYyIsImlzV2luZG93cyIsImlzRmlyZWZveCIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJDU1MiLCJzdXBwb3J0cyIsImhleE51bWJlcnMiLCJwYWRTdGFydCIsIlV0aWwiLCJtYWtlSGV4Q29sb3IiLCJyIiwiZyIsImRvbU1hdHJpeFRvVHJhbnNmb3JtIiwiZG0iLCJzY2FsZU1pbk1heCIsIm1pbk1heCIsIm0xIiwibTIiLCJtdWx0aXBseUJ5RE9NTWF0cml4IiwibWQiLCJhcHBseVRyYW5zZm9ybSIsInAiLCJwb3MiLCJwMCIsInAxIiwiYXBwbHlUcmFuc2Zvcm1Ub0JlemllciIsIm0wIiwibTMiLCJtNCIsIm01IiwicEkiLCJwSTEiLCJhcHBseUludmVyc2VUcmFuc2Zvcm0iLCJheGlhbEFsaWduZWRCb3VuZGluZ0JveCIsInJlY3QiLCJvdXRwdXQiLCJyMCIsInIxIiwicjIiLCJyMyIsImEwIiwiYTIiLCJhMSIsImEzIiwiYjAiLCJiMiIsImIxIiwiYjMiLCJtMXIwIiwibTFyMiIsIm0ycjEiLCJtMnIzIiwiaW52ZXJzZVRyYW5zZm9ybSIsInNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlIiwibWF0cml4IiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0Iiwibm9ybWFsaXplUmVjdCIsImludGVyc2VjdCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJwb2ludEJvdW5kaW5nQm94IiwicmVjdEJvdW5kaW5nQm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJnZXRFeHRyZW11bU9uQ3VydmUiLCJ4MiIsIngzIiwieTIiLCJ5MyIsInQiLCJtdCIsInR0IiwidHR0IiwiZ2V0RXh0cmVtdW0iLCJkZWx0YSIsInNxcnREZWx0YSIsImJlemllckJvdW5kaW5nQm94IiwiUERGU3RyaW5nVHJhbnNsYXRlVGFibGUiLCJzdHJpbmdUb1BERlN0cmluZyIsImtlZXBFc2NhcGVTZXF1ZW5jZSIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGVkIiwiZGVjb2RlIiwicmVwbGFjZUFsbCIsImV4IiwiaWkiLCJjaGFyQ29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsInV0ZjhTdHJpbmdUb1N0cmluZyIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaXNBcnJheUVxdWFsIiwiYXJyMSIsImFycjIiLCJnZXRNb2RpZmljYXRpb25EYXRlIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJOb3JtYWxpemVSZWdleCIsIk5vcm1hbGl6YXRpb25NYXAiLCJub3JtYWxpemVVbmljb2RlIiwiTWFwIiwiXyIsInAyIiwiZ2V0VXVpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJidWYiLCJnZXRSYW5kb21WYWx1ZXMiLCJBbm5vdGF0aW9uUHJlZml4IiwiX2lzVmFsaWRFeHBsaWNpdERlc3QiLCJ2YWxpZFJlZiIsInZhbGlkTmFtZSIsImRlc3QiLCJwYWdlIiwiem9vbSIsImFyZ3NMZW4iLCJhbGxvd051bGwiLCJNYXRoQ2xhbXAiLCJ0b0hleFV0aWwiLCJhcnIiLCJudW0iLCJ0b0Jhc2U2NFV0aWwiLCJidG9hIiwiZnJvbUJhc2U2NFV0aWwiLCJhdG9iIiwiQWJvcnRTaWduYWwiLCJhbnkiLCJhYyIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImFib3J0ZWQiLCJhYm9ydCIsInJlYXNvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlc19pdGVyYXRvcl9tYXAiLCJ3ZWJfdXJsX3NlYXJjaF9wYXJhbXNfZGVsZXRlIiwid2ViX3VybF9zZWFyY2hfcGFyYW1zX2hhcyIsIndlYl91cmxfc2VhcmNoX3BhcmFtc19zaXplIiwiWGZhVGV4dCIsInRleHRDb250ZW50IiwieGZhIiwic3R5bGVzIiwid2FsayIsInNob3VsZEJ1aWxkVGV4dCIsImF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsImNoaWxkIiwiWGZhTGF5ZXIiLCJzZXR1cFN0b3JhZ2UiLCJlbGVtZW50Iiwic3RvcmFnZSIsImludGVudCIsInN0b3JlZERhdGEiLCJnZXRWYWx1ZSIsImV2ZW50Iiwic2V0VmFsdWUiLCJ4ZmFPbiIsInNldEF0dHJpYnV0ZSIsInhmYU9mZiIsInJlbW92ZUF0dHJpYnV0ZSIsImNoZWNrZWQiLCJnZXRBdHRyaWJ1dGUiLCJvcHRpb24iLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJzZXRBdHRyaWJ1dGVzIiwibGlua1NlcnZpY2UiLCJpc0hUTUxBbmNob3JFbGVtZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJhc3NpZ24iLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsImRhdGFJZCIsInJlbmRlciIsInBhcmFtZXRlcnMiLCJhbm5vdGF0aW9uU3RvcmFnZSIsInhmYUh0bWwiLCJyb290SHRtbCIsImlzTm90Rm9yUmljaFRleHQiLCJyb290RGl2IiwiZGl2Iiwidmlld3BvcnQiLCJ0ZXh0RGl2cyIsImNyZWF0ZVRleHROb2RlIiwicGFyZW50IiwicG9wIiwiY2hpbGRIdG1sIiwieG1sbnMiLCJjcmVhdGVFbGVtZW50TlMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXBkYXRlIiwiaGlkZGVuIiwiU1ZHX05TIiwiUGl4ZWxzUGVySW5jaCIsIlBERiIsIlBERl9UT19DU1NfVU5JVFMiLCJmZXRjaERhdGEiLCJpc1ZhbGlkRmV0Y2hVcmwiLCJiYXNlVVJJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJqc29uIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJyZXNwb25zZVRleHQiLCJzZW5kIiwiUGFnZVZpZXdwb3J0Iiwidmlld0JveCIsInVzZXJVbml0Iiwic2NhbGUiLCJyb3RhdGlvbiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZG9udEZsaXAiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJvdGF0ZUEiLCJyb3RhdGVCIiwicm90YXRlQyIsInJvdGF0ZUQiLCJvZmZzZXRDYW52YXNYIiwib2Zmc2V0Q2FudmFzWSIsIndpZHRoIiwiaGVpZ2h0IiwicmF3RGltcyIsImRpbXMiLCJwYWdlV2lkdGgiLCJwYWdlSGVpZ2h0IiwicGFnZVgiLCJwYWdlWSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiZXh0cmFEZWxheSIsImlzRGF0YVNjaGVtZSIsInRyaW0iLCJzdWJzdHJpbmciLCJpc1BkZkZpbGUiLCJmaWxlbmFtZSIsImdldEZpbGVuYW1lRnJvbVVybCIsImxhc3RJbmRleE9mIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZGVmYXVsdEZpbGVuYW1lIiwiZ2V0VVJMIiwibmV3VVJMIiwicGRmUmVnZXgiLCJyZXZlcnNlIiwicmVGaWxlbmFtZSIsImhhc2hGaWxlbmFtZSIsIlN0YXRUaW1lciIsInRpbWUiLCJzdGFydGVkIiwibm93IiwidGltZUVuZCIsInRpbWVzIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsIm5vQ29udGV4dE1lbnUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImRlcHJlY2F0ZWQiLCJsb2ciLCJQREZEYXRlU3RyaW5nIiwidG9EYXRlT2JqZWN0IiwiUmVnRXhwIiwibWF0Y2hlcyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJ1bml2ZXJzYWxUaW1lUmVsYXRpb24iLCJvZmZzZXRIb3VyIiwib2Zmc2V0TWludXRlIiwiVVRDIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwieGZhUGFnZSIsImdldFJHQiIsImNvbG9yIiwiY29sb3JSR0IiLCJnZXRDb2xvclZhbHVlcyIsImNvbG9ycyIsInNwYW4iLCJ2aXNpYmlsaXR5IiwiY29sb3JTY2hlbWUiLCJib2R5IiwiY29tcHV0ZWRDb2xvciIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRDdXJyZW50VHJhbnNmb3JtIiwiY3R4IiwiZ2V0VHJhbnNmb3JtIiwiZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UiLCJpbnZlcnRTZWxmIiwic2V0TGF5ZXJEaW1lbnNpb25zIiwibXVzdEZsaXAiLCJtdXN0Um90YXRlIiwidXNlUm91bmQiLCJ3IiwiaCIsIndpZHRoU3RyIiwiaGVpZ2h0U3RyIiwiT3V0cHV0U2NhbGUiLCJwaXhlbFJhdGlvIiwic3giLCJzeSIsInNjYWxlZCIsInN5bW1ldHJpYyIsImxpbWl0Q2FudmFzIiwibWF4UGl4ZWxzIiwibWF4RGltIiwiY2FwQXJlYUZhY3RvciIsIm1heEFyZWFTY2FsZSIsIm1heFdpZHRoU2NhbGUiLCJtYXhIZWlnaHRTY2FsZSIsImNhcFBpeGVscyIsIm1heFNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpblBpeGVscyIsInNjcmVlbiIsImF2YWlsV2lkdGgiLCJhdmFpbEhlaWdodCIsIlN1cHBvcnRlZEltYWdlTWltZVR5cGVzIiwiQ29sb3JTY2hlbWUiLCJpc0RhcmtNb2RlIiwibWF0Y2hNZWRpYSIsIkNTU0NvbnN0YW50cyIsImNvbW1lbnRGb3JlZ3JvdW5kQ29sb3IiLCJjbGFzc0xpc3QiLCJhcHBseU9wYWNpdHkiLCJvcGFjaXR5Iiwid2hpdGUiLCJyb3VuZCIsIlJHQlRvSFNMIiwicmdiIiwibCIsIkhTTFRvUkdCIiwiaHNsIiwiY29tcHV0ZUx1bWluYW5jZSIsImNvbnRyYXN0UmF0aW8iLCJoc2wxIiwiaHNsMiIsImx1bTEiLCJsdW0yIiwiY29udHJhc3RDYWNoZSIsImZpbmRDb250cmFzdENvbG9yIiwiYmFzZUNvbG9yIiwiZml4ZWRDb2xvciIsImNhY2hlZFZhbHVlIiwiYmFzZUhTTCIsImZpeGVkSFNMIiwiaXNGaXhlZENvbG9yRGFyayIsIm1pbkNvbnRyYXN0IiwiUFJFQ0lTSU9OIiwibWlkIiwicmVuZGVyUmljaFRleHQiLCJkaXIiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJsaW5lcyIsImxpbmUiLCJmaXJzdENoaWxkIiwiZXNfaXRlcmF0b3JfdGFrZSIsImVzX3Byb21pc2Vfd2l0aF9yZXNvbHZlcnMiLCJlc19zZXRfZGlmZmVyZW5jZV92MiIsImVzX3NldF9pbnRlcnNlY3Rpb25fdjIiLCJlc19zZXRfaXNfZGlzam9pbnRfZnJvbV92MiIsImVzX3NldF9pc19zdWJzZXRfb2ZfdjIiLCJlc19zZXRfaXNfc3VwZXJzZXRfb2ZfdjIiLCJlc19zZXRfc3ltbWV0cmljX2RpZmZlcmVuY2VfdjIiLCJlc19zZXRfdW5pb25fdjIiLCJlc19pdGVyYXRvcl9kcm9wIiwiZXNfaXRlcmF0b3JfZXZlcnkiLCJlc19pdGVyYXRvcl9zb21lIiwiZXNuZXh0X2pzb25fcGFyc2UiLCJFZGl0b3JUb29sYmFyIiwidG9vbGJhciIsImNvbG9yUGlja2VyIiwiZWRpdG9yIiwiYnV0dG9ucyIsImFsdFRleHQiLCJjb21tZW50IiwiY29tbWVudEJ1dHRvbkRpdmlkZXIiLCJzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiIsImwxMG5SZW1vdmUiLCJmcmVlemUiLCJmcmVldGV4dCIsImhpZ2hsaWdodCIsImluayIsInN0YW1wIiwic2lnbmF0dXJlIiwiZWRpdFRvb2xiYXIiLCJfdWlNYW5hZ2VyIiwiX3NpZ25hbCIsInBvaW50ZXJEb3duIiwicG9zaXRpb24iLCJ0b29sYmFyUG9zaXRpb24iLCJkaXJlY3Rpb24iLCJpbnNldElubGluZUVuZCIsInRvcCIsImZvY3VzSW4iLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiZm9jdXNPdXQiLCJhZGRMaXN0ZW5lcnNUb0VsZW1lbnQiLCJjYXB0dXJlIiwiaGlkZSIsImhpZGVEcm9wZG93biIsInNob3ciLCJzaG93biIsImFkZERlbGV0ZUJ1dHRvbiIsImVkaXRvclR5cGUiLCJidXR0b24iLCJ0YWJJbmRleCIsImRlbGV0ZSIsImRpdmlkZXIiLCJhZGRBbHRUZXh0IiwiYWRkQ29tbWVudCIsImJlZm9yZUVsZW1lbnQiLCJyZW5kZXJGb3JUb29sYmFyIiwiaW5zZXJ0QmVmb3JlIiwiYWRkQ29sb3JQaWNrZXIiLCJyZW5kZXJCdXR0b24iLCJhZGRFZGl0U2lnbmF0dXJlQnV0dG9uIiwic2lnbmF0dXJlTWFuYWdlciIsInJlbmRlckVkaXRCdXR0b24iLCJyZW1vdmVCdXR0b24iLCJyZW1vdmVUb29sYmFyQ29tbWVudEJ1dHRvbiIsImFkZEJ1dHRvbiIsInRvb2wiLCJhZGRCdXR0b25CZWZvcmUiLCJiZWZvcmVTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJ1cGRhdGVFZGl0U2lnbmF0dXJlQnV0dG9uIiwiZGVzY3JpcHRpb24iLCJ0aXRsZSIsImRlc3Ryb3kiLCJGbG9hdGluZ1Rvb2xiYXIiLCJ1aU1hbmFnZXIiLCJoYXNDb21tZW50TWFuYWdlciIsIm1ha2VCdXR0b24iLCJjb21tZW50U2VsZWN0aW9uIiwiaGlnaGxpZ2h0U2VsZWN0aW9uIiwiZ2V0TGFzdFBvaW50IiwiYm94ZXMiLCJpc0xUUiIsImxhc3RZIiwibGFzdFgiLCJib3giLCJidXR0b25DbGFzcyIsImwxMG5JZCIsImxhYmVsTDEwbklkIiwiY2xpY2tIYW5kbGVyIiwiYmluZEV2ZW50cyIsIklkTWFuYWdlciIsIkltYWdlTWFuYWdlciIsImJhc2VJZCIsImNhY2hlIiwiX2lzU1ZHRml0dGluZ0NhbnZhcyIsInN2ZyIsImNhbnZhcyIsImdldENvbnRleHQiLCJ3aWxsUmVhZEZyZXF1ZW50bHkiLCJpbWFnZSIsIkltYWdlIiwidGhlbiIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsInJhd0RhdGEiLCJyZWZDb3VudGVyIiwiaXNTdmciLCJGaWxlIiwiZmlsZSIsIkJsb2IiLCJtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJpbWFnZUVsZW1lbnQiLCJpbWFnZVByb21pc2UiLCJvbmxvYWQiLCJzdmdVcmwiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImNyZWF0ZUltYWdlQml0bWFwIiwiZ2V0RnJvbUZpbGUiLCJsYXN0TW9kaWZpZWQiLCJnZXRGcm9tVXJsIiwiZ2V0RnJvbUJsb2IiLCJibG9iUHJvbWlzZSIsImdldEZyb21JZCIsImdldEZyb21DYW52YXMiLCJvZmZzY3JlZW4iLCJ0cmFuc2ZlclRvSW1hZ2VCaXRtYXAiLCJnZXRTdmdVcmwiLCJkZWxldGVJZCIsInRyYW5zZmVyRnJvbUltYWdlQml0bWFwIiwiY29udmVydFRvQmxvYiIsImlzVmFsaWRJZCIsIkNvbW1hbmRNYW5hZ2VyIiwiY29tbWFuZHMiLCJsb2NrZWQiLCJtYXhTaXplIiwiY21kIiwidW5kbyIsInBvc3QiLCJtdXN0RXhlYyIsIm92ZXJ3cml0ZUlmU2FtZVR5cGUiLCJrZWVwVW5kbyIsInNwbGljZSIsInJlZG8iLCJoYXNTb21ldGhpbmdUb1VuZG8iLCJoYXNTb21ldGhpbmdUb1JlZG8iLCJjbGVhblR5cGUiLCJLZXlib2FyZE1hbmFnZXIiLCJjYWxsYmFja3MiLCJhbGxLZXlzIiwiaXNNYWNLZXkiLCJzZXJpYWxpemUiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYnViYmxlcyIsImNoZWNrZXIiLCJDb2xvck1hbmFnZXIiLCJfY29sb3JzTWFwcGluZyIsIl9jb2xvcnMiLCJjb252ZXJ0IiwiUkdCIiwiZ2V0SGV4Q29kZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0YWJsZUFubm90YXRpb25zIiwiYWxsRWRpdG9ycyIsImFsbExheWVycyIsImFsdFRleHRNYW5hZ2VyIiwiY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMiLCJjb21tYW5kTWFuYWdlciIsImNvbW1lbnRNYW5hZ2VyIiwiY29weVBhc3RlQUMiLCJjdXJyZW50RHJhd2luZ1Nlc3Npb24iLCJjdXJyZW50UGFnZUluZGV4IiwiZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyIsImRyYWdnaW5nRWRpdG9ycyIsImVkaXRvclR5cGVzIiwiZWRpdG9yc1RvUmVzY2FsZSIsImVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uIiwiZW5hYmxlVXBkYXRlZEFkZEltYWdlIiwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImZpbHRlckZhY3RvcnkiLCJmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQiLCJmb2N1c01hbmFnZXJBQyIsImhpZ2hsaWdodENvbG9ycyIsImhpZ2hsaWdodFdoZW5TaGlmdFVwIiwiZmxvYXRpbmdUb29sYmFyIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNQb2ludGVyRG93biIsImlzV2FpdGluZyIsImtleWJvYXJkTWFuYWdlckFDIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJtaXNzaW5nQ2FudmFzZXMiLCJtbE1hbmFnZXIiLCJzZWxlY3RlZEVkaXRvcnMiLCJzZWxlY3RlZFRleHROb2RlIiwicGFnZUNvbG9ycyIsInNob3dBbGxTdGF0ZXMiLCJwZGZEb2N1bWVudCIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsInZpZXdlciIsInZpZXdlckFsZXJ0IiwidXBkYXRlTW9kZUNhcGFiaWxpdHkiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsImFycm93Q2hlY2tlciIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsInRhZ05hbWUiLCJoYXNTb21ldGhpbmdUb0NvbnRyb2wiLCJ0ZXh0SW5wdXRDaGVja2VyIiwiX3NlbGYiLCJIVE1MSW5wdXRFbGVtZW50Iiwic21hbGwiLCJiaWciLCJzZWxlY3RBbGwiLCJhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQiLCJIVE1MQnV0dG9uRWxlbWVudCIsImlzRW50ZXJIYW5kbGVkIiwidW5zZWxlY3RBbGwiLCJ0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMiLCJldmVudEJ1cyIsImVkaXRvclVuZG9CYXIiLCJzdXBwb3J0c1BpbmNoVG9ab29tIiwiX2VkaXRvclVuZG9CYXIiLCJpc0VkaXRpbmciLCJpc0VtcHR5IiwiaGFzU2VsZWN0ZWRFZGl0b3IiLCJoYXNTZWxlY3RlZFRleHQiLCJfZXZlbnRCdXMiLCJfb24iLCJvbkVkaXRpbmdBY3Rpb24iLCJvblBhZ2VDaGFuZ2luZyIsIm9uU2NhbGVDaGFuZ2luZyIsIm9uUm90YXRpb25DaGFuZ2luZyIsIm9uU2V0UHJlZmVyZW5jZSIsImV2dCIsInVwZGF0ZVBhcmFtcyIsImFkZFNlbGVjdGlvbkxpc3RlbmVyIiwiYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMiLCJhZGRLZXlib2FyZE1hbmFnZXIiLCJ2aWV3UGFyYW1ldGVycyIsInJlYWxTY2FsZSIsImlzU2hpZnRLZXlEb3duIiwiX3N1cHBvcnRzUGluY2hUb1pvb20iLCJzZXRTaWRlYmFyVWlNYW5hZ2VyIiwibGF5ZXIiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lZFNpZ25hbCIsInVzZU5ld0FsdFRleHRGbG93IiwidXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwiX2hpZ2hsaWdodENvbG9ycyIsInBhaXIiLCJ0b1VwcGVyQ2FzZSIsImhhc0hDTSIsImlzTmFtZUZvckhDTSIsImVuZHNXaXRoIiwiaGlnaGxpZ2h0Q29sb3JOYW1lcyIsImdldE5vbkhDTUNvbG9yIiwiY29sb3JOYW1lIiwiZ2V0Tm9uSENNQ29sb3JOYW1lIiwic2V0Q3VycmVudERyYXdpbmdTZXNzaW9uIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJlZGl0QWx0VGV4dCIsImZpcnN0VGltZSIsImVkaXRDb21tZW50IiwicG9zWCIsInBvc1kiLCJzaG93RGlhbG9nIiwic2VsZWN0Q29tbWVudCIsInBhZ2VJbmRleCIsImdldEVkaXRvckJ5VUlEIiwidG9nZ2xlQ29tbWVudCIsInVwZGF0ZUNvbW1lbnQiLCJnZXREYXRhIiwidXBkYXRlUG9wdXBDb2xvciIsInJlbW92ZUNvbW1lbnQiLCJyZW1vdmVDb21tZW50cyIsImlzU2VsZWN0ZWQiLCJ0b2dnbGVDb21tZW50UG9wdXAiLCJtYWtlQ29tbWVudENvbG9yIiwiZ2V0Q29tbWVudERpYWxvZ0VsZW1lbnQiLCJkaWFsb2dFbGVtZW50Iiwid2FpdEZvckVkaXRvcnNSZW5kZXJlZCIsInBhZ2VOdW1iZXIiLCJvbkVkaXRvcnNSZW5kZXJlZCIsIl9vZmYiLCJvbiIsImdldFNpZ25hdHVyZSIsInN3aXRjaFRvTW9kZSIsIm9uY2UiLCJkaXNwYXRjaCIsInNldFByZWZlcmVuY2UiLCJmb2N1c01haW5Db250YWluZXIiLCJmb2N1cyIsImZpbmRQYXJlbnQiLCJsYXllclgiLCJsYXllclkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b2dnbGUiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsImNvbW1pdE9yUmVtb3ZlIiwicGFnZXNSb3RhdGlvbiIsImdldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwibm9kZVR5cGUiLCJURVhUX05PREUiLCJwYXJlbnRFbGVtZW50IiwiZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIiLCJ0ZXh0TGF5ZXIiLCJjdXJyZW50TGF5ZXIiLCJoYXNUZXh0TGF5ZXIiLCJtZXRob2RPZkNyZWF0aW9uIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwiaXNDb2xsYXBzZWQiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImFuY2hvckVsZW1lbnQiLCJjbG9zZXN0IiwiZ2V0U2VsZWN0aW9uQm94ZXMiLCJlbXB0eSIsImlzTm9uZU1vZGUiLCJjcmVhdGVBbmRBZGROZXdFZGl0b3IiLCJzaG93QWxsRWRpdG9ycyIsImRpc3BsYXlGbG9hdGluZ1Rvb2xiYXIiLCJnZXRBbmRSZW1vdmVEYXRhRnJvbUFubm90YXRpb25TdG9yYWdlIiwiYW5ub3RhdGlvbklkIiwic3RvcmVkVmFsdWUiLCJnZXRSYXdWYWx1ZSIsImFkZFRvQW5ub3RhdGlvblN0b3JhZ2UiLCJhMTF5QWxlcnQiLCJtZXNzYWdlSWQiLCJzdHJpbmdpZnkiLCJzZWxlY3Rpb25DaGFuZ2UiLCJkaXNwYXRjaFVwZGF0ZVN0YXRlcyIsImFjdGl2ZUxheWVyIiwidG9nZ2xlRHJhd2luZyIsInBvaW50ZXJ1cCIsIm9uU2VsZWN0RW5kIiwiYWRkRm9jdXNNYW5hZ2VyIiwiYmx1ciIsInJlbW92ZUZvY3VzTWFuYWdlciIsImhhc1NlbGVjdGlvbiIsImxhc3RFZGl0b3IiLCJrZXlkb3duIiwia2V5dXAiLCJyZW1vdmVLZXlib2FyZE1hbmFnZXIiLCJhZGRDb3B5UGFzdGVMaXN0ZW5lcnMiLCJjb3B5IiwiY3V0IiwicGFzdGUiLCJyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMiLCJkcmFnT3ZlciIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZGF0YVRyYW5zZmVyIiwiaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nIiwiZHJvcEVmZmVjdCIsImVkaXRvcnMiLCJzZXJpYWxpemVkIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJuZXdFZGl0b3JzIiwiZGVzZXJpYWxpemVkRWRpdG9yIiwiZGVzZXJpYWxpemUiLCJhZGRFZGl0b3JUb0xheWVyIiwic2VsZWN0RWRpdG9ycyIsImFkZENvbW1hbmRzIiwiaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkIiwiaGFzQ2hhbmdlZCIsImRpc3BhdGNoVXBkYXRlVUkiLCJzZXRFZGl0aW5nU3RhdGUiLCJyZWdpc3RlckVkaXRvclR5cGVzIiwidHlwZXMiLCJkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlIiwiZ2V0SWQiLCJnZXRMYXllciIsImFkZExheWVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsInJlbW92ZUxheWVyIiwidXBkYXRlTW9kZSIsImVkaXRJZCIsImlzRnJvbUtleWJvYXJkIiwibXVzdEVudGVySW5FZGl0TW9kZSIsImhpZGVTaWRlYmFyIiwiZGVzdHJveVBvcHVwIiwiZGlzYWJsZUFsbCIsImhpZGVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbiIsImFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uIiwibG9hZFNpZ25hdHVyZXMiLCJlbmFibGVBbGwiLCJnZXRBbm5vdGF0aW9uc0J5VHlwZSIsImVkaXRvckNsYXNzIiwiX2VkaXRvclR5cGUiLCJlbGVtZW50SWRzIiwiYWxsQ29tbWVudHMiLCJhbm5vdGF0aW9uRWxlbWVudElkIiwiaGFzQ29tbWVudCIsImRlbGV0ZWQiLCJhbm5vdGF0aW9uIiwicG9wdXBSZWYiLCJjb250ZW50c09iaiIsInNob3dTaWRlYmFyIiwic2V0U2VsZWN0ZWQiLCJlbnRlckluRWRpdE1vZGUiLCJ1bnNlbGVjdCIsImNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yIiwiYWRkTmV3RWRpdG9yIiwidXBkYXRlVG9vbGJhciIsImFjdGlvbiIsInVwZGF0ZURlZmF1bHRQYXJhbXMiLCJ2aXNpYmxlIiwidXBkYXRlQnV0dG9uIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJwcm9taXNlcyIsImdldEVkaXRvcnMiLCJnZXRFZGl0b3IiLCJhZGRFZGl0b3IiLCJyZW1vdmVFZGl0b3IiLCJzZXRUaW1lb3V0IiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImFkZE9yUmVidWlsZCIsInNldEFjdGl2ZUVkaXRvciIsInByb3BlcnRpZXNUb1VwZGF0ZSIsImxhc3RTZWxlY3RlZEVkaXRvciIsImVkIiwidXBkYXRlVUkiLCJ1cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzIiwidG9nZ2xlU2VsZWN0ZWQiLCJzZWxlY3QiLCJmaXJzdFNlbGVjdGVkRWRpdG9yIiwiY2xlYW5VbmRvU3RhY2siLCJkcmF3aW5nRWRpdG9yIiwiZW5kRHJhd2luZ1Nlc3Npb24iLCJjb21taXQiLCJub0NvbW1pdCIsInRvdGFsWCIsInRvdGFsWSIsIlRJTUVfVE9fV0FJVCIsInRyYW5zbGF0ZUluUGFnZSIsInRyYW5zbGF0aW9uRG9uZSIsInNldFVwRHJhZ1Nlc3Npb24iLCJzYXZlZFgiLCJzYXZlZFkiLCJzYXZlZFBhZ2VJbmRleCIsIm5ld1giLCJuZXdZIiwibmV3UGFnZUluZGV4IiwiZW5kRHJhZ1Nlc3Npb24iLCJtdXN0QmVBZGRlZEluVW5kb1N0YWNrIiwibW92ZSIsIl9zZXRQYXJlbnRBbmRQb3NpdGlvbiIsImRyYWdTZWxlY3RlZEVkaXRvcnMiLCJ0eCIsInR5IiwiZHJhZyIsInJlYnVpbGQiLCJjaGFuZ2VQYXJlbnQiLCJnZXRBY3RpdmUiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsImlzQWN0aXZlIiwiZ2V0TW9kZSIsImlzRWRpdGluZ01vZGUiLCJpbWFnZU1hbmFnZXIiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwicGFyZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJyb3RhdG9yIiwicmFuZ2UiLCJjb2xsYXBzZWQiLCJnZXRDbGllbnRSZWN0cyIsInJlbmRlckFubm90YXRpb25FbGVtZW50IiwiZWRpdG9ySWQiLCJoYXNCZWVuTW9kaWZpZWQiLCJzZXRNaXNzaW5nQ2FudmFzIiwic2V0Q2FudmFzIiwiYWRkTWlzc2luZ0NhbnZhcyIsIkFsdFRleHQiLCJhbHRUZXh0RGVjb3JhdGl2ZSIsImFsdFRleHRCdXR0b24iLCJhbHRUZXh0QnV0dG9uTGFiZWwiLCJhbHRUZXh0VG9vbHRpcCIsImFsdFRleHRUb29sdGlwVGltZW91dCIsImFsdFRleHRXYXNGcm9tS2V5Qm9hcmQiLCJiYWRnZSIsImd1ZXNzZWRUZXh0IiwidGV4dFdpdGhEaXNjbGFpbWVyIiwibDEwbk5ld0J1dHRvbiIsIl9sMTBuIiwiYWRkZWQiLCJyZXZpZXciLCJpbml0aWFsaXplIiwibDEwbiIsImxhYmVsIiwib25DbGljayIsIl9yZXBvcnRUZWxlbWV0cnkiLCJzZXRTdGF0ZSIsImZpbmlzaCIsImZvY3VzVmlzaWJsZSIsImhhc0RhdGEiLCJzZXRHdWVzc2VkVGV4dCIsImdlbmVyYXRlZEFsdFRleHQiLCJ0b2dnbGVBbHRUZXh0QmFkZ2UiLCJpc0ZvckNvcHlpbmciLCJkZWNvcmF0aXZlIiwiY2FuY2VsIiwiZW5hYmxlZCIsImRpc2FibGVkIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsInBhcmVudE5vZGUiLCJnZXRFbGVtZW50Rm9yQWx0VGV4dCIsIkNvbW1lbnQiLCJjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiIsImNvbW1lbnRUb29sYmFyQnV0dG9uIiwiY29tbWVudFdhc0Zyb21LZXlCb2FyZCIsImluaXRpYWxUZXh0IiwicmljaFRleHQiLCJwb3B1cFBvc2l0aW9uIiwicmVuZGVyRm9yU3RhbmRhbG9uZSIsImNvbW1lbnRCdXR0b25Qb3NpdGlvbiIsImNvbW1lbnRCdXR0b25Db2xvciIsImJhY2tncm91bmRDb2xvciIsImZvY3VzQnV0dG9uIiwib25VcGRhdGVkQ29sb3IiLCJjb21tZW50QnV0dG9uV2lkdGgiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJjb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIiLCJwYXJlbnRYIiwicGFyZW50WSIsImhhc0RlZmF1bHRQb3B1cFBvc2l0aW9uIiwicmVtb3ZlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24iLCJzZXRDb21tZW50QnV0dG9uU3RhdGVzIiwiaGFzUG9wdXAiLCJhcmlhRXhwYW5kZWQiLCJpc1N0YW5kYWxvbmUiLCJhcmlhSGFzUG9wdXAiLCJhcmlhQ29udHJvbHMiLCJhcmlhQ29udHJvbHNFbGVtZW50cyIsImVkaXQiLCJwYXJlbnREaW1lbnNpb25zIiwiaXNEZWxldGVkIiwiaGFzQmVlbkVkaXRlZCIsInNldEluaXRpYWxUZXh0IiwiVG91Y2hNYW5hZ2VyIiwiaXNQaW5jaGluZyIsImlzUGluY2hpbmdTdG9wcGVkIiwiaXNQaW5jaGluZ0Rpc2FibGVkIiwib25QaW5jaFN0YXJ0Iiwib25QaW5jaGluZyIsIm9uUGluY2hFbmQiLCJwb2ludGVyRG93bkFDIiwidG91Y2hJbmZvIiwidG91Y2hNYW5hZ2VyQUMiLCJ0b3VjaE1vdmVBQyIsIm9uVG91Y2hTdGFydCIsInBhc3NpdmUiLCJNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0giLCJ0b3VjaGVzIiwib3B0cyIsImNhbmNlbFBvaW50ZXJEb3duIiwicG9pbnRlclR5cGUiLCJvcHQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJ0b3VjaDAiLCJ0b3VjaDEiLCJpZGVudGlmaWVyIiwidG91Y2gwWCIsInNjcmVlblgiLCJ0b3VjaDBZIiwic2NyZWVuWSIsInRvdWNoMVgiLCJ0b3VjaDFZIiwic2NyZWVuMFgiLCJzY3JlZW4wWSIsInNjcmVlbjFYIiwic2NyZWVuMVkiLCJwVG91Y2gwWCIsInBUb3VjaDBZIiwicFRvdWNoMVgiLCJwVG91Y2gxWSIsInByZXZHYXBYIiwicHJldkdhcFkiLCJjdXJyR2FwWCIsImN1cnJHYXBZIiwiZGlzdGFuY2UiLCJoeXBvdCIsInBEaXN0YW5jZSIsIm9yaWdpbiIsIkFubm90YXRpb25FZGl0b3IiLCJhY2Nlc3NpYmlsaXR5RGF0YSIsImFsbFJlc2l6ZXJEaXZzIiwiZHJhZ1BvaW50ZXJJZCIsImRyYWdQb2ludGVyVHlwZSIsInJlc2l6ZXJzRGl2IiwibGFzdFBvaW50ZXJDb29yZHMiLCJzYXZlZERpbWVuc2lvbnMiLCJmYWtlQW5ub3RhdGlvbiIsImZvY3VzQUMiLCJmb2N1c2VkUmVzaXplck5hbWUiLCJoYXNCZWVuQ2xpY2tlZCIsImluaXRpYWxSZWN0IiwiaXNJbkVkaXRNb2RlIiwiaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkIiwibW92ZUluRE9NVGltZW91dCIsInByZXZEcmFnWCIsInByZXZEcmFnWSIsInRlbGVtZXRyeVRpbWVvdXRzIiwidG91Y2hNYW5hZ2VyIiwiX2wxMG5SZXNpemVyIiwiaXNEcmFnZ2FibGUiLCJ6SW5kZXgiLCJfYm9yZGVyTGluZVdpZHRoIiwiX2NvbG9yTWFuYWdlciIsIl96SW5kZXgiLCJfdGVsZW1ldHJ5VGltZW91dCIsIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyIiwicmVzaXplIiwiX3Jlc2l6ZVdpdGhLZXlib2FyZCIsIl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQiLCJfaXNDb3B5IiwiX2VkaXRUb29sYmFyIiwiX2luaXRpYWxPcHRpb25zIiwiX2luaXRpYWxEYXRhIiwiX2lzVmlzaWJsZSIsIl93aWxsS2VlcEFzcGVjdFJhdGlvIiwiaXNDZW50ZXJlZCIsIl9zdHJ1Y3RUcmVlUGFyZW50SWQiLCJjcmVhdGlvbkRhdGUiLCJtb2RpZmljYXRpb25EYXRlIiwicGFnZVJvdGF0aW9uIiwicGFnZURpbWVuc2lvbnMiLCJwYWdlVHJhbnNsYXRpb24iLCJpc0F0dGFjaGVkVG9ET00iLCJfdHlwZSIsImlzRHJhd2VyIiwiX2RlZmF1bHRMaW5lQ29sb3IiLCJkZWxldGVBbm5vdGF0aW9uRWxlbWVudCIsImZha2VFZGl0b3IiLCJGYWtlRWRpdG9yIiwiZ2V0TmV4dElkIiwidG9wTWlkZGxlIiwidG9wUmlnaHQiLCJtaWRkbGVSaWdodCIsImJvdHRvbU1pZGRsZSIsImJvdHRvbUxlZnQiLCJtaWRkbGVMZWZ0IiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJfdmFsdWUiLCJtaW1lIiwiX2lzRHJhZ2dhYmxlIiwiY2VudGVyIiwicGFyZW50Um90YXRpb24iLCJmaXhBbmRTZXRQb3NpdGlvbiIsInNldEluQmFja2dyb3VuZCIsInNldEluRm9yZWdyb3VuZCIsInNldFBhcmVudCIsInN0b3BSZXNpemluZyIsImZvY3VzaW4iLCJmb2N1c291dCIsInJlbGF0ZWRUYXJnZXQiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwic2V0QXQiLCJzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbiIsIl9tb3ZlQWZ0ZXJQYXN0ZSIsImJhc2VYIiwiYmFzZVkiLCJfb25UcmFuc2xhdGVkIiwidHJhbnNsYXRlIiwiX29uVHJhbnNsYXRpbmciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZmluZE5ld1BhcmVudCIsImJ4IiwiYnkiLCJnZXRCYXNlVHJhbnNsYXRpb24iLCJsZWZ0IiwidG9GaXhlZCIsIl9oYXNCZWVuTW92ZWQiLCJfaGFzQmVlblJlc2l6ZWQiLCJfbXVzdEZpeFBvc2l0aW9uIiwibW92ZUluRE9NIiwicm90YXRlUG9pbnQiLCJhbmdsZSIsInBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuIiwiZ2V0Um90YXRpb25NYXRyaXgiLCJwYXJlbnRTY2FsZSIsInNldERpbXMiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNsYXNzZXMiLCJyZXNpemVyUG9pbnRlcmRvd24iLCJwcmVwZW5kIiwic2F2ZWREcmFnZ2FibGUiLCJ0b2dnbGVQb2ludGVyRXZlbnRzIiwicmVzaXplclBvaW50ZXJtb3ZlIiwic2F2ZWRXaWR0aCIsInNhdmVkSGVpZ2h0Iiwic2F2ZWRQYXJlbnRDdXJzb3IiLCJjdXJzb3IiLCJzYXZlZEN1cnNvciIsInBvaW50ZXJVcENhbGxiYWNrIiwiYWRkUmVzaXplVG9VbmRvU3RhY2siLCJfb25SZXNpemVkIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJfcm91bmQiLCJtaW5XaWR0aCIsIk1JTl9TSVpFIiwibWluSGVpZ2h0Iiwicm90YXRpb25NYXRyaXgiLCJ0cmFuc2YiLCJpbnZSb3RhdGlvbk1hdHJpeCIsImludlRyYW5zZiIsImdldFBvaW50IiwiZ2V0T3Bwb3NpdGUiLCJpc0RpYWdvbmFsIiwiaXNIb3Jpem9udGFsIiwicG9pbnQiLCJvcHBvc2l0ZVBvaW50IiwidHJhbnNmT3Bwb3NpdGVQb2ludCIsIm9wcG9zaXRlWCIsIm9wcG9zaXRlWSIsInJhdGlvWCIsInJhdGlvWSIsImRlbHRhWCIsImRlbHRhWSIsImZyb21LZXlib2FyZCIsImxhc3RTY3JlZW5YIiwibGFzdFNjcmVlblkiLCJvbGREaWFnIiwiX29uUmVzaXppbmciLCJhbHRUZXh0RmluaXNoIiwidG9vbGJhckJ1dHRvbnMiLCJhZGRFZGl0VG9vbGJhciIsImFkZENvbW1lbnRCdXR0b24iLCJhZGRDb21tZW50QnV0dG9uSW5Ub29sYmFyIiwicmVtb3ZlQ29tbWVudEJ1dHRvbkZyb21Ub29sYmFyIiwicmVtb3ZlRWRpdFRvb2xiYXIiLCJhZGRDb250YWluZXIiLCJlZGl0VG9vbGJhckRpdiIsImJlZm9yZSIsImdldENsaWVudERpbWVuc2lvbnMiLCJjcmVhdGVBbHRUZXh0IiwiYWx0VGV4dERhdGEiLCJndWVzc2VkQWx0VGV4dCIsInNldEd1ZXNzZWRBbHRUZXh0Iiwic2VyaWFsaXplQWx0VGV4dCIsImhhc0FsdFRleHQiLCJoYXNBbHRUZXh0RGF0YSIsImZvY3VzQ29tbWVudEJ1dHRvbiIsInNldENvbW1lbnREYXRhIiwidXBkYXRlRnJvbUFubm90YXRpb25MYXllciIsImhhc0VkaXRlZENvbW1lbnQiLCJoYXNEZWxldGVkQ29tbWVudCIsInNldFNlbGVjdGVkQ29tbWVudEJ1dHRvbiIsInNldFNlbGVjdGVkQnV0dG9uIiwiREVGQVVMVF9QT1BVUF9XSURUSCIsIkRFRkFVTFRfUE9QVVBfSEVJR0hUIiwidHJZIiwiYmxYIiwiYmxZIiwidHJYIiwicG9wdXAiLCJjb250ZW50cyIsInBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdCIsImRlZmF1bHRMMTBuSWQiLCJhZGRGb2N1c0xpc3RlbmVycyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwidG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2siLCJ0b3VjaFBpbmNoQ2FsbGJhY2siLCJ0b3VjaFBpbmNoRW5kQ2FsbGJhY2siLCJfb3JpZ2luIiwicHJldkRpc3RhbmNlIiwic2xvd0Rvd25GYWN0b3IiLCJmYWN0b3IiLCJ0cmFuc2ZDZW50ZXJQb2ludCIsIm5ld1RyYW5zZkNlbnRlclBvaW50IiwicG9pbnRlcmRvd24iLCJzZWxlY3RPblBvaW50ZXJFdmVudCIsImhhc0RyYWdnaW5nU3RhcnRlZCIsImNhbmNlbERyYWciLCJfb25TdG9wRHJhZ2dpbmciLCJjbGllbnRYIiwiY2xpZW50WSIsInBvaW50ZXJJZCIsIl9vblN0YXJ0RHJhZ2dpbmciLCJpc1ByaW1hcnkiLCJtb3ZlRWRpdG9ySW5ET00iLCJnZXRSZWN0Iiwic2hpZnRYIiwic2hpZnRZIiwiZ2V0UmVjdEluQ3VycmVudENvb3JkcyIsImdldFBERlJlY3QiLCJvbmNlQWRkZWQiLCJlbmFibGVFZGl0TW9kZSIsImRpc2FibGVFZGl0TW9kZSIsIm5lZWRzVG9CZVJlYnVpbHQiLCJpc09uU2NyZWVuIiwiYm90dG9tIiwicmlnaHQiLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJyb3RhdGUiLCJfYW5nbGUiLCJzZXJpYWxpemVEZWxldGVkIiwiYW5ub3RhdGlvblR5cGUiLCJzdHJ1Y3RUcmVlUGFyZW50SWQiLCJpc0NvcHkiLCJ0aW1lb3V0IiwibWFrZVJlc2l6YWJsZSIsImNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZSIsImNvbW1lbnRQb3B1cFBvc2l0aW9uIiwiZWxlbWVudEJlZm9yZVBvcHVwIiwiYm91bmRSZXNpemVyS2V5ZG93biIsInJlc2l6ZXJLZXlkb3duIiwiYm91bmRSZXNpemVyQmx1ciIsInJlc2l6ZXJCbHVyIiwicmVzaXplckZvY3VzIiwiZmlyc3RQb3NpdGlvbiIsIm5leHRGaXJzdFBvc2l0aW9uIiwibGFzdENoaWxkIiwic2V0UmVzaXplclRhYkluZGV4Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJldmVudFNjcm9sbCIsImRpc2FibGVFZGl0aW5nIiwiZW5hYmxlRWRpdGluZyIsImNhbkNoYW5nZUNvbnRlbnQiLCJkYmxjbGljayIsIm5vZGVOYW1lIiwiY29udGVudERpdiIsInRlbGVtZXRyeUluaXRpYWxEYXRhIiwidGVsZW1ldHJ5RmluYWxEYXRhIiwidXBkYXRlRmFrZUFubm90YXRpb25FbGVtZW50IiwiYW5ub3RhdGlvbkxheWVyIiwiYWRkRmFrZUFubm90YXRpb24iLCJ1cGRhdGVFZGl0ZWQiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJtb2RpZmllZCIsIm1vZGlmaWVkSWRzIiwiZWRpdG9yc01hcCIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJkZWZhdWx0VmFsdWUiLCJyZXNldE1vZGlmaWVkIiwic2V0TW9kaWZpZWQiLCJwcmludCIsIlByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJzZXJpYWxpemFibGUiLCJoYXNCaXRtYXAiLCJlZGl0b3JTdGF0cyIsInN0YXRzIiwidHlwZVRvRWRpdG9yIiwibnVtYmVyT2ZFZGl0ZWRDb21tZW50cyIsIm51bWJlck9mRGVsZXRlZENvbW1lbnRzIiwiaXNDb21tZW50RGVsZXRlZCIsImNvdW50ZXJzIiwiY29tbWVudHMiLCJlZGl0ZWQiLCJjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhIiwicmVzZXRNb2RpZmllZElkcyIsInVwZGF0ZUVkaXRvciIsImlkcyIsIkZvbnRMb2FkZXIiLCJzeXN0ZW1Gb250cyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJzeXN0ZW1Gb250SW5mbyIsImRpc2FibGVGb250RmFjZSIsIl9pbnNwZWN0Rm9udCIsImxvYWRlZE5hbWUiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJmb250IiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwibG9hZGVkIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsImNvbXBsZXRlUmVxdWVzdCIsIm90aGVyUmVxdWVzdCIsImNvbXBsZXRlIiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJpbnNlcnQiLCJjaHVuazEiLCJjaHVuazIiLCJjYWxsZWQiLCJpc0ZvbnRSZWFkeSIsImZpbGxUZXh0IiwiaW1hZ2VEYXRhIiwiQ09NTUVOVF9PRkZTRVQiLCJDRkZfQ0hFQ0tTVU1fT0ZGU0VUIiwiWFhYWF9WQUxVRSIsImNoZWNrc3VtIiwiZm9udEZhbWlseSIsIkZvbnRGYWNlT2JqZWN0IiwiZm9udERhdGEiLCJ0cmFuc2xhdGVkRGF0YSIsImluc3BlY3RGb250IiwiZXh0cmEiLCJjaGFyUHJvY09wZXJhdG9yTGlzdCIsImNvbXBpbGVkR2x5cGhzIiwiY3NzRm9udEluZm8iLCJjc3MiLCJ3ZWlnaHQiLCJmb250V2VpZ2h0IiwiaXRhbGljQW5nbGUiLCJtaW1ldHlwZSIsImdldFBhdGhHZW5lcmF0b3IiLCJvYmpzIiwiY2hhcmFjdGVyIiwib2JqSWQiLCJjbWRzIiwicGF0aCIsIlBhdGgyRCIsImZvbnRFeHRyYVByb3BlcnRpZXMiLCJibGFjayIsImJvbGQiLCJpc0ludmFsaWRQREZqc0ZvbnQiLCJpc1R5cGUzRm9udCIsIml0YWxpYyIsInJlbWVhc3VyZSIsInZlcnRpY2FsIiwiYXNjZW50IiwiZGVmYXVsdFdpZHRoIiwiZGVzY2VudCIsImJib3giLCJmb250TWF0cml4IiwiZmFsbGJhY2tOYW1lIiwiY2xlYXJEYXRhIiwiZGVmYXVsdFZNZXRyaWNzIiwiZ2V0VXJsUHJvcCIsImxvY2F0aW9uIiwiZ2V0RGF0YVByb3AiLCJCdWZmZXIiLCJpc05hTiIsImdldEZhY3RvcnlVcmxQcm9wIiwiaXNSZWZQcm94eSIsImdlbiIsImlzTmFtZVByb3h5IiwiaXNWYWxpZEV4cGxpY2l0RGVzdCIsIkxvb3BiYWNrUG9ydCIsImxpc3RlbmVycyIsImRlZmVycmVkIiwibGlzdGVuZXIiLCJybUFib3J0Iiwib25BYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJDYWxsYmFja0tpbmQiLCJEQVRBIiwiRVJST1IiLCJTdHJlYW1LaW5kIiwiQ0FOQ0VMIiwiQ0FOQ0VMX0NPTVBMRVRFIiwiQ0xPU0UiLCJFTlFVRVVFIiwiUFVMTCIsIlBVTExfQ09NUExFVEUiLCJTVEFSVF9DT01QTEVURSIsIm9uRm4iLCJ3cmFwUmVhc29uIiwiTWVzc2FnZUhhbmRsZXIiLCJtZXNzYWdlQUMiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImNvbU9iaiIsImNhbGxiYWNrSWQiLCJzdHJlYW1JZCIsInN0cmVhbVNpbmtzIiwic3RyZWFtQ29udHJvbGxlcnMiLCJjYWxsYmFja0NhcGFiaWxpdGllcyIsImFjdGlvbkhhbmRsZXIiLCJvbk1lc3NhZ2UiLCJzdHJlYW0iLCJwcm9jZXNzU3RyZWFtTWVzc2FnZSIsImNhcGFiaWxpdHkiLCJ0cnkiLCJjcmVhdGVTdHJlYW1TaW5rIiwiYWN0aW9uTmFtZSIsImhhbmRsZXIiLCJhaCIsInRyYW5zZmVycyIsInNlbmRXaXRoUHJvbWlzZSIsInNlbmRXaXRoU3RyZWFtIiwicXVldWVpbmdTdHJhdGVneSIsIlJlYWRhYmxlU3RyZWFtIiwiY29udHJvbGxlciIsInN0YXJ0Q2FwYWJpbGl0eSIsInN0YXJ0Q2FsbCIsInB1bGxDYWxsIiwiY2FuY2VsQ2FsbCIsImlzQ2xvc2VkIiwiZGVzaXJlZFNpemUiLCJwdWxsIiwicHVsbENhcGFiaWxpdHkiLCJjYW5jZWxDYXBhYmlsaXR5Iiwic3RyZWFtU2luayIsImVucXVldWUiLCJpc0NhbmNlbGxlZCIsImxhc3REZXNpcmVkU2l6ZSIsInNpbmtDYXBhYmlsaXR5IiwicmVhZHkiLCJvblB1bGwiLCJvbkNhbmNlbCIsInN1Y2Nlc3MiLCJzdHJlYW1Db250cm9sbGVyIiwiZGVsZXRlU3RyZWFtQ29udHJvbGxlciIsImRhdGFSZWFzb24iLCJhbGxTZXR0bGVkIiwiQmFzZUNhbnZhc0ZhY3RvcnkiLCJlbmFibGVIV0EiLCJfY3JlYXRlQ2FudmFzIiwicmVzZXQiLCJjYW52YXNBbmRDb250ZXh0IiwiRE9NQ2FudmFzRmFjdG9yeSIsIkJhc2VDTWFwUmVhZGVyRmFjdG9yeSIsImlzQ29tcHJlc3NlZCIsIl9mZXRjaCIsImNNYXBEYXRhIiwiY2F0Y2giLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsImVzX2l0ZXJhdG9yX2ZpbHRlciIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiYWRkRmlsdGVyIiwibWFwcyIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiYWRkQWxwaGFGaWx0ZXIiLCJhZGRMdW1pbm9zaXR5RmlsdGVyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwiZmlsdGVyTmFtZSIsIm5ld0ZnQ29sb3IiLCJuZXdCZ0NvbG9yIiwia2VlcEhDTSIsIkRPTUZpbHRlckZhY3RvcnkiLCJfY2FjaGUiLCJfZGVmcyIsImRvY0lkIiwiX2hjbUNhY2hlIiwiaGNtQ2FjaGUiLCJkZWZzIiwiY29udGFpbiIsImNyZWF0ZVRhYmxlcyIsIm1hcFIiLCJ0YWJsZSIsIm1hcEciLCJtYXBCIiwiYnVmZmVyUiIsImJ1ZmZlckciLCJidWZmZXJCIiwiY3JlYXRlVXJsIiwidGFibGVSIiwidGFibGVHIiwidGFibGVCIiwiY3JlYXRlRmlsdGVyIiwiYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uIiwiZmdSR0IiLCJiZ1JHQiIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJ0YWJsZUEiLCJhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbiIsImFkZEx1bWlub3NpdHlDb252ZXJzaW9uIiwiZmdHcmF5IiwiYmdHcmF5IiwibmV3RmdSR0IiLCJuZXdCZ1JHQiIsImZnIiwiYmciLCJuZXdTdGFydCIsIm5ld1N0ZXAiLCJwcmV2IiwiZmVDb2xvck1hdHJpeCIsImFwcGVuZEZlRnVuYyIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJhVGFibGUiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkJhc2VXYXNtRmFjdG9yeSIsIkRPTVdhc21GYWN0b3J5IiwicmVxdWlyZSIsImNyZWF0ZVJlcXVpcmUiLCJET01NYXRyaXgiLCJJbWFnZURhdGEiLCJsYW5ndWFnZSIsIm5vZGVfdXRpbHNfZmV0Y2hEYXRhIiwiZnMiLCJyZWFkRmlsZSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiTm9kZUNhbnZhc0ZhY3RvcnkiLCJjcmVhdGVDYW52YXMiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJOb2RlV2FzbUZhY3RvcnkiLCJlc19pdGVyYXRvcl9mb3JfZWFjaCIsIkZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMIiwiZXhwYW5kQkJveCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJFTVBUWV9CQk9YIiwiQkJveFJlYWRlciIsImJib3hlcyIsImNvb3JkcyIsImVuc3VyZURlYnVnTWV0YWRhdGEiLCJkZXBlbmRlbmNpZXMiLCJpc1JlbmRlcmluZ09wZXJhdGlvbiIsIkNhbnZhc0RlcGVuZGVuY3lUcmFja2VyIiwiaW5jcmVtZW50YWwiLCJuYW1lZERlcGVuZGVuY2llcyIsInNhdmVzU3RhY2siLCJtYXJrZWRDb250ZW50U3RhY2siLCJiYXNlVHJhbnNmb3JtU3RhY2siLCJjbGlwQm94IiwicGVuZGluZ0JCb3giLCJwZW5kaW5nQkJveElkeCIsInBlbmRpbmdEZXBlbmRlbmNpZXMiLCJvcGVyYXRpb25zIiwiZm9udEJCb3hUcnVzdHdvcnRoeSIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiYmJveGVzQ29vcmRzIiwiZGVidWdNZXRhZGF0YSIsIm9wZXJhdGlvbnNDb3VudCIsInJlY29yZERlYnVnTWV0YWRhdGEiLCJzYW1lTGluZVRleHQiLCJpbml0aWFsaXplQkJveGVzIiwiZ3Jvd09wZXJhdGlvbnNDb3VudCIsIm9sZEJCb3hlcyIsIm9wSWR4IiwicHJldmlvdXMiLCJsYXN0U2F2ZSIsInJlY29yZE9wZW5NYXJrZXIiLCJpZHgiLCJnZXRPcGVuTWFya2VyIiwicmVjb3JkQ2xvc2VNYXJrZXIiLCJwdXNoQmFzZVRyYW5zZm9ybSIsInBvcEJhc2VUcmFuc2Zvcm0iLCJyZWNvcmRTaW1wbGVEYXRhIiwicmVjb3JkSW5jcmVtZW50YWxEYXRhIiwicmVzZXRJbmNyZW1lbnRhbERhdGEiLCJyZWNvcmROYW1lZERhdGEiLCJyZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkIiwiZGVwTmFtZSIsImZhbGxiYWNrSWR4IiwicmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeSIsImluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMiLCJpbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzIiwiZGVwIiwicmVzZXRCQm94IiwicmVjb3JkQ2xpcEJveCIsInJlY29yZEJCb3giLCJyZWNvcmRDaGFyYWN0ZXJCQm94IiwiZ2V0TWVhc3VyZSIsImZvbnRCQm94IiwiaXNCQm94VHJ1c3R3b3J0aHkiLCJjb21wdXRlZEJCb3giLCJyZWNvcmRGdWxsUGFnZUJCb3giLCJtZWFzdXJlIiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwiZ2V0U2ltcGxlSW5kZXgiLCJkZXBlbmRlbmN5TmFtZSIsInJlY29yZERlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lOYW1lcyIsInJlY29yZE5hbWVkRGVwZW5kZW5jeSIsInJlY29yZE9wZXJhdGlvbiIsInByZXNlcnZlIiwiZGVwSWR4Iiwic2F2ZUlkeCIsInJlY29yZFNob3dUZXh0T3BlcmF0aW9uIiwiZGVwcyIsImJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uIiwiX3Rha2VQZW5kaW5nRGVwZW5kZW5jaWVzIiwiX2V4dHJhY3RPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJfcHVzaFBlbmRpbmdEZXBlbmRlbmNpZXMiLCJ0YWtlRGVidWdNZXRhZGF0YSIsIkNhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyIiwiZGVwZW5kZW5jeVRyYWNrZXIiLCJpZ25vcmVCQm94ZXMiLCJuZXN0aW5nTGV2ZWwiLCJzYXZlc0xldmVsIiwiRGVwZW5kZW5jaWVzIiwiaW1hZ2VYT2JqZWN0IiwidHJhbnNmb3JtQW5kRmlsbCIsIlBhdGhUeXBlIiwiU0hBRElORyIsImFwcGx5Qm91bmRpbmdCb3giLCJyZWdpb24iLCJCYXNlU2hhZGluZ1BhdHRlcm4iLCJpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0iLCJnZXRQYXR0ZXJuIiwiUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiIsIklSIiwiX2Jib3giLCJfY29sb3JTdG9wcyIsIl9wMCIsIl9wMSIsIl9yMCIsIl9yMSIsIl9jcmVhdGVHcmFkaWVudCIsImdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwib3duZXIiLCJwYXRoVHlwZSIsInBhdHRlcm4iLCJvd25lckJCb3giLCJnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94IiwidG1wQ2FudmFzIiwiY2FjaGVkQ2FudmFzZXMiLCJnZXRDYW52YXMiLCJ0bXBDdHgiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJiYXNlVHJhbnNmb3JtIiwiZmlsbFN0eWxlIiwiY3JlYXRlUGF0dGVybiIsImRvbU1hdHJpeCIsInNldFRyYW5zZm9ybSIsImRyYXdUcmlhbmdsZSIsInAzIiwiYzEiLCJjMiIsImMzIiwicm93U2l6ZSIsInNjYWxlWCIsInNjYWxlWSIsImMxciIsImMxZyIsImMxYiIsImMyciIsImMyZyIsImMyYiIsImMzciIsImMzZyIsImMzYiIsInhhIiwiY2FyIiwiY2FnIiwiY2FiIiwieGIiLCJjYnIiLCJjYmciLCJjYmIiLCJ4MV8iLCJ4Ml8iLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9maWd1cmVzIiwiX2JvdW5kcyIsIl9iYWNrZ3JvdW5kIiwiX2NyZWF0ZU1lc2hDYW52YXMiLCJjb21iaW5lZFNjYWxlIiwiRVhQRUNURURfU0NBTEUiLCJNQVhfUEFUVEVSTl9TSVpFIiwiQk9SREVSX1NJWkUiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsInBhZGRlZFdpZHRoIiwicGFkZGVkSGVpZ2h0IiwiY3JlYXRlSW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwibWF0cml4U2NhbGVYIiwibWF0cml4U2NhbGVZIiwidGVtcG9yYXJ5UGF0dGVybkNhbnZhcyIsIkR1bW15U2hhZGluZ1BhdHRlcm4iLCJnZXRTaGFkaW5nUGF0dGVybiIsIlBhaW50VHlwZSIsIkNPTE9SRUQiLCJVTkNPTE9SRUQiLCJUaWxpbmdQYXR0ZXJuIiwiY2FudmFzR3JhcGhpY3NGYWN0b3J5Iiwib3BlcmF0b3JMaXN0IiwieHN0ZXAiLCJ5c3RlcCIsInBhaW50VHlwZSIsInRpbGluZ1R5cGUiLCJjcmVhdGVQYXR0ZXJuQ2FudmFzIiwiY29tYmluZWRTY2FsZVgiLCJjb21iaW5lZFNjYWxlWSIsInJlZHJhd0hvcml6b250YWxseSIsInJlZHJhd1ZlcnRpY2FsbHkiLCJ4U2NhbGVkU3RlcCIsInlTY2FsZWRTdGVwIiwieFNjYWxlZFdpZHRoIiwieVNjYWxlZEhlaWdodCIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJjcmVhdGVDYW52YXNHcmFwaGljcyIsImdyb3VwTGV2ZWwiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJjbGlwQmJveCIsImV4ZWN1dGVPcGVyYXRvckxpc3QiLCJlbmREcmF3aW5nIiwiZGlteDIiLCJkaW15MiIsInhTaXplIiwieVNpemUiLCJ0bXBDYW52YXMyIiwidG1wQ3R4MiIsImpqIiwicmVhbE91dHB1dFNpemUiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0Iiwic3Ryb2tlU3R5bGUiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsImNvbnZlcnRUb1JHQkEiLCJJbWFnZUtpbmQiLCJjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSIsImNvbnZlcnRSR0JUb1JHQkEiLCJzcmNQb3MiLCJub25CbGFja0NvbG9yIiwiaW52ZXJzZURlY29kZSIsInplcm9NYXBwaW5nIiwib25lTWFwcGluZyIsIndpZHRoSW5Tb3VyY2UiLCJ3aWR0aFJlbWFpbmRlciIsInNyY0xlbmd0aCIsImRlc3RQb3MiLCJlbGVtIiwibGVuMzIiLCJzcmMzMiIsIkZlYXR1cmVUZXN0IiwiczEiLCJzMiIsInMzIiwiZ3JheVRvUkdCQSIsIk1JTl9GT05UX1NJWkUiLCJNQVhfRk9OVF9TSVpFIiwiRVhFQ1VUSU9OX1RJTUUiLCJFWEVDVVRJT05fU1RFUFMiLCJGVUxMX0NIVU5LX0hFSUdIVCIsIlNDQUxFX01BVFJJWCIsIlhZIiwiTUlOX01BWF9JTklUIiwibWlycm9yQ29udGV4dE9wZXJhdGlvbnMiLCJkZXN0Q3R4IiwiX3JlbW92ZU1pcnJvcmluZyIsIl9fb3JpZ2luYWxTYXZlIiwiX19vcmlnaW5hbFJlc3RvcmUiLCJfX29yaWdpbmFsUm90YXRlIiwiX19vcmlnaW5hbFNjYWxlIiwiX19vcmlnaW5hbFRyYW5zbGF0ZSIsIl9fb3JpZ2luYWxUcmFuc2Zvcm0iLCJfX29yaWdpbmFsU2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtIiwicmVzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsQ2xpcCIsIl9fb3JpZ2luYWxNb3ZlVG8iLCJfX29yaWdpbmFsTGluZVRvIiwiX19vcmlnaW5hbEJlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhbnZhc0ZhY3RvcnkiLCJjYW52YXNFbnRyeSIsImRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyIsInNyY0ltZyIsInNyY1giLCJzcmNZIiwic3JjVyIsInNyY0giLCJkZXN0WCIsImRlc3RZIiwiZGVzdFciLCJkZXN0SCIsInRsWCIsInJUbFgiLCJ0bFkiLCJyVGxZIiwiYnJYIiwicldpZHRoIiwiYnJZIiwickhlaWdodCIsIkNhbnZhc0V4dHJhU3RhdGUiLCJwcmVJbml0IiwiYWxwaGFJc1NoYXBlIiwiZm9udFNpemUiLCJmb250U2l6ZVNjYWxlIiwidGV4dE1hdHJpeCIsInRleHRNYXRyaXhTY2FsZSIsImxlYWRpbmciLCJsaW5lWCIsImxpbmVZIiwiY2hhclNwYWNpbmciLCJ3b3JkU3BhY2luZyIsInRleHRIU2NhbGUiLCJ0ZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwicGF0dGVybkZpbGwiLCJwYXR0ZXJuU3Ryb2tlIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsImdldFBhdGhCb3VuZGluZ0JveCIsInhTdHJva2VQYWQiLCJ5U3Ryb2tlUGFkIiwidXBkYXRlQ2xpcEZyb21QYXRoIiwic3RhcnROZXdQYXRoQW5kQ2xpcEJveCIsImlzRW1wdHlDbGlwIiwicHV0QmluYXJ5SW1hZ2VEYXRhIiwiaW1nRGF0YSIsInBhcnRpYWxDaHVua0hlaWdodCIsImZ1bGxDaHVua3MiLCJ0b3RhbENodW5rcyIsImNodW5rSW1nRGF0YSIsInRoaXNDaHVua0hlaWdodCIsImVsZW1zSW5UaGlzQ2h1bmsiLCJkZXN0MzIiLCJkZXN0MzJEYXRhTGVuZ3RoIiwiZnVsbFNyY0RpZmYiLCJzcmNEaWZmIiwia0VuZCIsImtFbmRVbnJvbGxlZCIsIm1hc2siLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInNldExpbmVEYXNoIiwiZ2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInJlc2V0Q3R4VG9EZWZhdWx0IiwiZmlsbFJ1bGUiLCJnbG9iYWxBbHBoYSIsImxpbmVDYXAiLCJsaW5lSm9pbiIsIm1pdGVyTGltaXQiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImFjdHVhbFNjYWxlIiwiZnJvdW5kIiwiTElORV9DQVBfU1RZTEVTIiwiTElORV9KT0lOX1NUWUxFUyIsIk5PUk1BTF9DTElQIiwiRU9fQ0xJUCIsIkNhbnZhc0dyYXBoaWNzIiwiY2FudmFzQ3R4IiwiY29tbW9uT2JqcyIsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsImFubm90YXRpb25DYW52YXNNYXAiLCJzdGF0ZVN0YWNrIiwicGVuZGluZ0NsaXAiLCJwZW5kaW5nRU9GaWxsIiwieG9ianMiLCJncm91cFN0YWNrIiwic21hc2tTdGFjayIsInNtYXNrQ291bnRlciIsInRlbXBTTWFzayIsInN1c3BlbmRlZEN0eCIsImNvbnRlbnRWaXNpYmxlIiwiY2FjaGVkUGF0dGVybnMiLCJ2aWV3cG9ydFNjYWxlIiwib3V0cHV0U2NhbGVYIiwib3V0cHV0U2NhbGVZIiwiX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmciLCJfY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCIsIl9jYWNoZWRCaXRtYXBzTWFwIiwiZ2V0T2JqZWN0IiwiZmFsbGJhY2siLCJiZWdpbkRyYXdpbmciLCJ0cmFuc3BhcmVuY3kiLCJzYXZlZEZpbGxTdHlsZSIsImZpbGxSZWN0IiwidHJhbnNwYXJlbnRDYW52YXMiLCJjb21wb3NpdGVDdHgiLCJleGVjdXRpb25TdGFydElkeCIsImNvbnRpbnVlQ2FsbGJhY2siLCJzdGVwcGVyIiwib3BlcmF0aW9uc0ZpbHRlciIsImFyZ3NBcnJheSIsImZuQXJyYXkiLCJhcmdzQXJyYXlMZW4iLCJjaHVua09wZXJhdGlvbnMiLCJlbmRUaW1lIiwic3RlcHMiLCJmbklkIiwiZm5BcmdzIiwibmV4dEJyZWFrUG9pbnQiLCJicmVha0l0IiwiZGVwT2JqSWQiLCJvYmpzUG9vbCIsInJlc3RvcmVJbml0aWFsU3RhdGUiLCJpblNNYXNrTW9kZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZHJhd0ZpbHRlciIsImhjbUZpbHRlcklkIiwic2F2ZWRGaWx0ZXIiLCJfc2NhbGVJbWFnZSIsImltZyIsImRpc3BsYXlXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJ3aWR0aFNjYWxlIiwiaGVpZ2h0U2NhbGUiLCJwYWludFdpZHRoIiwicGFpbnRIZWlnaHQiLCJ0bXBDYW52YXNJZCIsIl9jcmVhdGVNYXNrQ2FudmFzIiwiaXNQYXR0ZXJuRmlsbCIsImN1cnJlbnRUcmFuc2Zvcm0iLCJjYWNoZUtleSIsIm1hc2tDYW52YXMiLCJtYWluS2V5IiwiY2FjaGVkSW1hZ2UiLCJtYXNrVG9DYW52YXMiLCJkcmF3bldpZHRoIiwiZHJhd25IZWlnaHQiLCJmaWxsQ2FudmFzIiwiZmlsbEN0eCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsImRhc2hBcnJheSIsImRhc2hQaGFzZSIsImZsYXRuZXNzIiwic3RhdGVzIiwiY2hlY2tTTWFza1N0YXRlIiwiYmVnaW5TTWFza01vZGUiLCJlbmRTTWFza01vZGUiLCJjYWNoZUlkIiwic2NyYXRjaENhbnZhcyIsImNvbXBvc2UiLCJkaXJ0eUJveCIsInNtYXNrIiwiY29tcG9zZVNNYXNrIiwibGF5ZXJDdHgiLCJsYXllckJveCIsImxheWVyT2Zmc2V0WCIsImxheWVyT2Zmc2V0WSIsImxheWVyV2lkdGgiLCJsYXllckhlaWdodCIsImdlbmVyaWNDb21wb3NlU01hc2siLCJzdWJ0eXBlIiwiYmFja2Ryb3AiLCJ0cmFuc2Zlck1hcCIsIm1hc2tDdHgiLCJtYXNrT2Zmc2V0WCIsIm1hc2tPZmZzZXRZIiwibWFza1giLCJtYXNrWSIsIm9sZCIsIm9wIiwib3V0ZXJFeHRyYVNpemUiLCJwYXRoMmQiLCJfcGF0aFN0YXJ0SWR4IiwiY29uc3VtZVBhdGgiLCJuZXdQYXRoIiwiYWRkUGF0aCIsIm11bHRpcGx5U2VsZiIsInJlc2NhbGVBbmRTdHJva2UiLCJuZWVkUmVzdG9yZSIsInBhdGhzIiwicGVuZGluZ1RleHRQYXRocyIsInByZU11bHRpcGx5U2VsZiIsInNwYWNpbmciLCJmb250UmVmTmFtZSIsImZvbnRPYmoiLCJmb250RGlyZWN0aW9uIiwidHlwZWZhY2UiLCJicm93c2VyRm9udFNpemUiLCJyaXNlIiwiZ2V0U2NhbGVkUGF0aCIsInBhaW50Q2hhciIsInBhdHRlcm5GaWxsVHJhbnNmb3JtIiwicGF0dGVyblN0cm9rZVRyYW5zZm9ybSIsImZpbGxTdHJva2VNb2RlIiwiaXNBZGRUb1BhdGhTZXQiLCJzY2FsZWRQYXRoIiwiaW52UGF0dGVyblRyYW5zZm9ybSIsIm1lYXN1cmVUZXh0Iiwic3Ryb2tlVGV4dCIsImlzRm9udFN1YnBpeGVsQUFFbmFibGVkIiwiZ2x5cGhzIiwic2hvd1R5cGUzVGV4dCIsImdseXBoc0xlbmd0aCIsInNwYWNpbmdEaXIiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwiam9pbmVkQ2hhcnMiLCJyZXN0b3JlTmVlZGVkIiwiaXNTcGFjZSIsImZvbnRDaGFyIiwiYWNjZW50Iiwic2NhbGVkWCIsInNjYWxlZFkiLCJ2bWV0cmljIiwidngiLCJ2eSIsIm1lYXN1cmVkV2lkdGgiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsIm9wZXJhdG9yTGlzdElkIiwieFdpZHRoIiwieVdpZHRoIiwibGx4IiwibGx5IiwidXJ4IiwidXJ5IiwiZ2V0Q29sb3JOX1BhdHRlcm4iLCJyZW5kZXJpbmdPcElkeCIsIl9nZXRQYXR0ZXJuIiwiaW52IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImJvdW5kcyIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImFubm90YXRpb25DYW52YXMiLCJzYXZlZEN0eCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwiQ3NzRm9udEluZm8iLCJ2aWV3Iiwic3RyaW5ncyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWRTdHJpbmdzIiwic3RyaW5nc0xlbmd0aCIsImVuY29kZWQiLCJlbmNvZGUiLCJzZXRVaW50MzIiLCJyZWFkU3RyaW5nIiwiZ2V0VWludDMyIiwiU3lzdGVtRm9udEluZm8iLCJlbmNvZGVkU3R5bGVTdHlsZSIsImVuY29kZWRTdHlsZVdlaWdodCIsImxlbmd0aEVzdGltYXRlIiwic2V0VWludDgiLCJndWVzc0ZhbGxiYWNrIiwiZ2V0VWludDgiLCJzdHlsZUxlbmd0aCIsIndlaWdodExlbmd0aCIsIkZvbnRJbmZvIiwiYm9vbHMiLCJPRkZTRVRfTlVNQkVSUyIsIk9GRlNFVF9CQk9YIiwiT0ZGU0VUX0ZPTlRfTUFUUklYIiwiT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1MiLCJPRkZTRVRfU1RSSU5HUyIsInJlYWRCb29sZWFuIiwiYnl0ZU9mZnNldCIsImJpdE9mZnNldCIsInJlYWROdW1iZXIiLCJnZXRGbG9hdDY0IiwibnVtQ29vcmRzIiwiZ2V0SW50MTYiLCJudW1Qb2ludHMiLCJudW1NZXRyaWNzIiwic3RyaW5nRGF0YSIsInN5c3RlbUZvbnRJbmZvTGVuZ3RoIiwiY3NzRm9udEluZm9MZW5ndGgiLCJjc3NGb250SW5mb0RhdGEiLCJzeXN0ZW1Gb250SW5mb0RhdGEiLCJzeXN0ZW1Gb250SW5mb0J1ZmZlciIsImNzc0ZvbnRJbmZvQnVmZmVyIiwibnVtQm9vbHMiLCJib29sQnl0ZSIsImJvb2xCaXQiLCJiaXRzIiwic2V0RmxvYXQ2NCIsImNvb3JkIiwic2V0SW50MTYiLCJtZXRyaWMiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwicG9ydCIsIndvcmtlclBvcnQiLCJXb3JrZXIiLCJ3b3JrZXJTcmMiLCJNZXRhZGF0YSIsInBhcnNlZERhdGEiLCJnZXRSYXciLCJJTlRFUk5BTCIsIk9wdGlvbmFsQ29udGVudEdyb3VwIiwiaXNEaXNwbGF5IiwiaXNQcmludCIsInVzZXJTZXQiLCJyZW5kZXJpbmdJbnRlbnQiLCJ1c2FnZSIsInJiR3JvdXBzIiwidmlld1N0YXRlIiwicHJpbnRTdGF0ZSIsIl9zZXRWaXNpYmxlIiwiaW50ZXJuYWwiLCJPcHRpb25hbENvbnRlbnRDb25maWciLCJjYWNoZWRHZXRIYXNoIiwiZ3JvdXBzIiwiaW5pdGlhbEhhc2giLCJvcmRlciIsImNyZWF0b3IiLCJiYXNlU3RhdGUiLCJvZmYiLCJnZXRIYXNoIiwiZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbiIsIm9wZXJhdG9yIiwiZXhwcmVzc2lvbiIsInBvbGljeSIsInNldFZpc2liaWxpdHkiLCJwcmVzZXJ2ZVJCIiwicmJHcm91cCIsIm90aGVySWQiLCJzZXRPQ0dTdGF0ZSIsImhhc0luaXRpYWxWaXNpYmlsaXR5IiwiZ2V0T3JkZXIiLCJnZXRHcm91cCIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0iLCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwiaW5pdGlhbERhdGEiLCJwcm9ncmVzc2l2ZURvbmUiLCJjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9xdWV1ZWRDaHVua3MiLCJfcHJvZ3Jlc3NpdmVEb25lIiwiX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9pc1N0cmVhbWluZ1N1cHBvcnRlZCIsIl9pc1JhbmdlU3VwcG9ydGVkIiwiX2NvbnRlbnRMZW5ndGgiLCJfZnVsbFJlcXVlc3RSZWFkZXIiLCJfcmFuZ2VSZWFkZXJzIiwiYWRkUmFuZ2VMaXN0ZW5lciIsImJlZ2luIiwiX29uUmVjZWl2ZURhdGEiLCJhZGRQcm9ncmVzc0xpc3RlbmVyIiwidG90YWwiLCJfb25Qcm9ncmVzcyIsImFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIiLCJfb25Qcm9ncmVzc2l2ZURvbmUiLCJ0cmFuc3BvcnRSZWFkeSIsIl9lbnF1ZXVlIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJnZXRGdWxsUmVhZGVyIiwicXVldWVkQ2h1bmtzIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciIsImdldFJhbmdlUmVhZGVyIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIiwicmVxdWVzdERhdGFSYW5nZSIsImNhbmNlbEFsbFJlcXVlc3RzIiwiX3N0cmVhbSIsIl9kb25lIiwiX2ZpbGVuYW1lIiwiX3JlcXVlc3RzIiwiX2hlYWRlcnNSZWFkeSIsInJlcXVlc3RDYXBhYmlsaXR5IiwiaGVhZGVyc1JlYWR5IiwiaXNSYW5nZVN1cHBvcnRlZCIsImlzU3RyZWFtaW5nU3VwcG9ydGVkIiwiY29udGVudExlbmd0aCIsIl9lbmQiLCJfcXVldWVkQ2h1bmsiLCJyZXF1ZXN0c0NhcGFiaWxpdHkiLCJnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIiLCJjb250ZW50RGlzcG9zaXRpb24iLCJuZWVkc0VuY29kaW5nRml4dXAiLCJ0b1BhcmFtUmVnRXhwIiwicmZjMjYxNnVucXVvdGUiLCJyZmM1OTg3ZGVjb2RlIiwicmZjMjA0N2RlY29kZSIsImZpeHVwRW5jb2RpbmciLCJyZmMyMjMxZ2V0cGFyYW0iLCJhdHRyaWJ1dGVQYXR0ZXJuIiwiZmxhZ3MiLCJ0ZXh0ZGVjb2RlIiwiY29udGVudERpc3Bvc2l0aW9uU3RyIiwiaXRlciIsInF1b3QiLCJwYXJ0IiwicGFydHMiLCJxdW90aW5kZXgiLCJleHR2YWx1ZSIsImVuY29kaW5nZW5kIiwibGFuZ3ZhbHVlIiwiY2hhcnNldCIsImNyZWF0ZUhlYWRlcnMiLCJpc0h0dHAiLCJodHRwSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0UmVzcG9uc2VPcmlnaW4iLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmVzcG9uc2VPcmlnaW4iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJyZXNwb25zZU9yaWdpbiIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwibmV0d29ya19nZXRBcnJheUJ1ZmZlciIsInhociIsIk5ldHdvcmtNYW5hZ2VyIiwiY3VyclhocklkIiwicGVuZGluZ1JlcXVlc3RzIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIlBERk5ldHdvcmtTdHJlYW0iLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsInJlc3BvbnNlVVJMIiwicmF3UmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbVN0YXJ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJ1cmxSZWdleCIsInBhcnNlVXJsT3JQYXRoIiwic291cmNlVXJsIiwicGF0aFRvRmlsZVVSTCIsIlBERk5vZGVTdHJlYW0iLCJQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIiLCJfcmVhZGFibGVTdHJlYW0iLCJsc3RhdCIsIl9zZXRSZWFkYWJsZVN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJfZXJyb3IiLCJyZWFkYWJsZVN0cmVhbSIsIklOSVRJQUxfREFUQSIsIlBERk9iamVjdHMiLCJlbnN1cmVPYmoiLCJNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiIsIkRFRkFVTFRfRk9OVF9TSVpFIiwiVGV4dExheWVyIiwiZGlzYWJsZVByb2Nlc3NJdGVtcyIsImZvbnRJbnNwZWN0b3JFbmFibGVkIiwibGFuZyIsImxheW91dFRleHRQYXJhbXMiLCJyb290Q29udGFpbmVyIiwic3R5bGVDYWNoZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHREaXZQcm9wZXJ0aWVzIiwiYXNjZW50Q2FjaGUiLCJjYW52YXNDb250ZXh0cyIsImNhbnZhc0N0eEZvbnRzIiwibWluRm9udFNpemUiLCJwZW5kaW5nVGV4dExheWVycyIsIkZvbnRJbnNwZWN0b3IiLCJlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkIiwiZmluYWxseSIsImZvbnRGYW1pbHlNYXAiLCJwdW1wIiwicHJvY2Vzc0l0ZW1zIiwib25CZWZvcmUiLCJnZXRDdHgiLCJsYXlvdXQiLCJhYm9ydEV4IiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwiaGFzVGV4dCIsImhhc0VPTCIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250U3Vic3RpdHV0aW9uIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJnZXRBc2NlbnQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiZGF0YXNldCIsImZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiYnIiLCJlbnN1cmVDdHhGb250IiwiY2xlYW51cCIsImFscGhhIiwiY2FjaGVkIiwibGluZUhlaWdodCIsImNhY2hlZEFzY2VudCIsIm1ldHJpY3MiLCJmb250Qm91bmRpbmdCb3hBc2NlbnQiLCJmb250Qm91bmRpbmdCb3hEZXNjZW50IiwicmF0aW8iLCJSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQiLCJnZXREb2N1bWVudCIsInRhc2siLCJQREZEb2N1bWVudExvYWRpbmdUYXNrIiwicGFzc3dvcmQiLCJyYW5nZVRyYW5zcG9ydCIsIlBERkRhdGFSYW5nZVRyYW5zcG9ydCIsIndvcmtlciIsIlBERldvcmtlciIsImRvY0Jhc2VVcmwiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsIkNNYXBSZWFkZXJGYWN0b3J5IiwiaWNjVXJsIiwic3RhbmRhcmRGb250RGF0YVVybCIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwid2FzbVVybCIsIldhc21GYWN0b3J5IiwiaWdub3JlRXJyb3JzIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiY2hyb21lIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJlbmFibGVYZmEiLCJkaXNhYmxlQXV0b0ZldGNoIiwicGRmQnVnIiwiQ2FudmFzRmFjdG9yeSIsIkZpbHRlckZhY3RvcnkiLCJ1c2VXYXNtIiwidXNlU3lzdGVtRm9udHMiLCJ1c2VXb3JrZXJGZXRjaCIsInRyYW5zcG9ydEZhY3RvcnkiLCJjTWFwUmVhZGVyRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwid2FzbUZhY3RvcnkiLCJfd29ya2VyIiwiZG9jUGFyYW1zIiwiYXBpVmVyc2lvbiIsImV2YWx1YXRvck9wdGlvbnMiLCJ0cmFuc3BvcnRQYXJhbXMiLCJsb2FkaW5nUGFyYW1zIiwiZGVzdHJveWVkIiwid29ya2VySWRQcm9taXNlIiwibWVzc2FnZUhhbmRsZXIiLCJuZXR3b3JrU3RyZWFtIiwiTmV0d29ya1N0cmVhbSIsIndvcmtlcklkIiwidHJhbnNwb3J0IiwiV29ya2VyVHJhbnNwb3J0IiwiX3RyYW5zcG9ydCIsIl9jYXBhYmlsaXR5IiwiX3BlbmRpbmdEZXN0cm95Iiwib25QYXNzd29yZCIsInByb2dyZXNzaXZlRG9uZUxpc3RlbmVycyIsInByb2dyZXNzaXZlUmVhZExpc3RlbmVycyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmFuZ2VMaXN0ZW5lcnMiLCJvbkRhdGFSYW5nZSIsIm9uRGF0YVByb2dyZXNzIiwib25EYXRhUHJvZ3Jlc3NpdmVSZWFkIiwib25EYXRhUHJvZ3Jlc3NpdmVEb25lIiwiUERGRG9jdW1lbnRQcm94eSIsInBkZkluZm8iLCJfcGRmSW5mbyIsIm51bVBhZ2VzIiwiZmluZ2VycHJpbnRzIiwiaXNQdXJlWGZhIiwiX2h0bWxGb3JYZmEiLCJhbGxYZmFIdG1sIiwiZ2V0UGFnZSIsImdldFBhZ2VJbmRleCIsInJlZiIsImdldERlc3RpbmF0aW9ucyIsImdldERlc3RpbmF0aW9uIiwiZ2V0UGFnZUxhYmVscyIsImdldFBhZ2VMYXlvdXQiLCJnZXRQYWdlTW9kZSIsImdldFZpZXdlclByZWZlcmVuY2VzIiwiZ2V0T3BlbkFjdGlvbiIsImdldEF0dGFjaG1lbnRzIiwicGFnZUluZGV4ZXNUb1NraXAiLCJnZXRKU0FjdGlvbnMiLCJnZXREb2NKU0FjdGlvbnMiLCJnZXRPdXRsaW5lIiwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwiZ2V0UGVybWlzc2lvbnMiLCJnZXRNZXRhZGF0YSIsImdldE1hcmtJbmZvIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwiY2FjaGVkUGFnZU51bWJlciIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJQREZQYWdlUHJveHkiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIl9wZGZCdWciLCJfaW50ZW50U3RhdGVzIiwicmVjb3JkZWRCQm94ZXMiLCJnZXRWaWV3cG9ydCIsImdldEFubm90YXRpb25zIiwiZ2V0UGFnZUpTQWN0aW9ucyIsImdldFhmYSIsImNhbnZhc0NvbnRleHQiLCJhbm5vdGF0aW9uTW9kZSIsIm9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UiLCJwcmludEFubm90YXRpb25TdG9yYWdlIiwicmVjb3JkT3BlcmF0aW9ucyIsImludGVudEFyZ3MiLCJpbnRlbnRTdGF0ZSIsInN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQiLCJpbnRlbnRQcmludCIsImRpc3BsYXlSZWFkeUNhcGFiaWxpdHkiLCJsYXN0Q2h1bmsiLCJzZXBhcmF0ZUFubm90cyIsIl9wdW1wT3BlcmF0b3JMaXN0IiwicmVjb3JkRm9yRGVidWdnZXIiLCJCb29sZWFuIiwiU3RlcHBlck1hbmFnZXIiLCJzaG91bGRSZWNvcmRPcGVyYXRpb25zIiwicmVuZGVyVGFza3MiLCJpbnRlcm5hbFJlbmRlclRhc2siLCJnZngiLCJzZXRPcGVyYXRvckJCb3hlcyIsInRyeUNsZWFudXAiLCJfYWJvcnRPcGVyYXRvckxpc3QiLCJTdGF0cyIsIkludGVybmFsUmVuZGVyVGFzayIsInVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbmRlclRhc2siLCJpbml0aWFsaXplR3JhcGhpY3MiLCJvcGVyYXRvckxpc3RDaGFuZ2VkIiwiZ2V0T3BlcmF0b3JMaXN0Iiwib3BMaXN0UmVhZENhcGFiaWxpdHkiLCJvcExpc3RUYXNrIiwic3RyZWFtVGV4dENvbnRlbnQiLCJpbmNsdWRlTWFya2VkQ29udGVudCIsImRpc2FibGVOb3JtYWxpemF0aW9uIiwiVEVYVF9DT05URU5UX0NIVU5LX1NJWkUiLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0VGV4dENvbnRlbnQiLCJnZXRTdHJ1Y3RUcmVlIiwiX2Rlc3Ryb3kiLCJ3YWl0T24iLCJmb3JjZSIsImNvbXBsZXRlZCIsInJlc2V0U3RhdHMiLCJfc3RhcnRSZW5kZXJQYWdlIiwiX3JlbmRlclBhZ2VDaHVuayIsIm9wZXJhdG9yTGlzdENodW5rIiwiYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUiLCJzdHJlYW1SZWFkZXIiLCJkZWxheSIsImN1ckNhY2hlS2V5IiwiY3VySW50ZW50U3RhdGUiLCJ3ZWJXb3JrZXIiLCJmYWtlV29ya2VySWQiLCJpc1dvcmtlckRpc2FibGVkIiwid29ya2VyUG9ydHMiLCJfaXNTYW1lT3JpZ2luIiwib3RoZXJVcmwiLCJfY3JlYXRlQ0ROV3JhcHBlciIsIndyYXBwZXIiLCJjcmVhdGVPYmplY3RVUkwiLCJmcm9tUG9ydCIsImluaXRpYWxpemVGcm9tUG9ydCIsIm1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlciIsInNldHVwRmFrZVdvcmtlciIsInRlcm1pbmF0ZUVhcmx5Iiwic2VuZFRlc3QiLCJ0ZXN0T2JqIiwiX3NldHVwRmFrZVdvcmtlckdsb2JhbCIsIldvcmtlck1lc3NhZ2VIYW5kbGVyIiwid29ya2VySGFuZGxlciIsInNldHVwIiwiY2FjaGVkUG9ydCIsInBkZmpzV29ya2VyIiwibG9hZGVyIiwibWV0aG9kUHJvbWlzZXMiLCJwYWdlQ2FjaGUiLCJwYWdlUHJvbWlzZXMiLCJwYWdlUmVmQ2FjaGUiLCJwYXNzd29yZENhcGFiaWxpdHkiLCJmYWN0b3J5IiwiZm9udExvYWRlciIsIl9wYXJhbXMiLCJkZXN0cm95Q2FwYWJpbGl0eSIsIl9uZXR3b3JrU3RyZWFtIiwiX2Z1bGxSZWFkZXIiLCJfbGFzdFByb2dyZXNzIiwic2V0dXBNZXNzYWdlSGFuZGxlciIsImNhY2hlU2ltcGxlTWV0aG9kIiwiY2FjaGVkUHJvbWlzZSIsImlzT3BMaXN0IiwibW9kaWZpZWRJZHNIYXNoIiwiY2FjaGVLZXlCdWYiLCJ0ZXJtaW5hdGVkIiwic2luayIsInJlYWR5UmVhc29uIiwiX251bVBhZ2VzIiwiaHRtbEZvclhmYSIsInVwZGF0ZVBhc3N3b3JkIiwiZXJyIiwiZXhwb3J0ZWREYXRhIiwiZXhwb3J0ZWRFcnJvciIsImZvbnRBZGRlZCIsImltYWdlUmVmIiwicGFnZVByb3h5IiwiZGF0YUxlbiIsInJlZlN0ciIsInJlc3VsdHMiLCJjbGVhbnVwU3VjY2Vzc2Z1bCIsIlJlbmRlclRhc2siLCJvbkNvbnRpbnVlIiwiZm9ybSIsInJBRiIsImNhbnZhc0luVXNlIiwiV2Vha1NldCIsIm9wZXJhdG9yTGlzdElkeCIsInJ1bm5pbmciLCJncmFwaGljc1JlYWR5Q2FsbGJhY2siLCJncmFwaGljc1JlYWR5IiwiX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbGxlZCIsIl9jYW5jZWxCb3VuZCIsIl9jb250aW51ZUJvdW5kIiwiX2NvbnRpbnVlIiwiX3NjaGVkdWxlTmV4dEJvdW5kIiwiX3NjaGVkdWxlTmV4dCIsIl9uZXh0Qm91bmQiLCJfbmV4dCIsIl9jYW52YXMiLCJfY2FudmFzQ29udGV4dCIsIl9lbmFibGVIV0EiLCJfZGVwZW5kZW5jeVRyYWNrZXIiLCJfb3BlcmF0aW9uc0ZpbHRlciIsImluaXQiLCJnZXROZXh0QnJlYWtQb2ludCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlT3BlcmF0b3JMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYnVpbGQiLCJDb2xvclBpY2tlciIsImJ1dHRvblN3YXRjaCIsImRlZmF1bHRDb2xvciIsImRyb3Bkb3duIiwiZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQiLCJpc01haW5Db2xvclBpY2tlciIsIm9wZW5Ecm9wZG93bkFDIiwibDEwbkNvbG9yIiwiX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCIsIl9jb2xvclNlbGVjdEZyb21LZXlib2FyZCIsIl9tb3ZlVG9OZXh0IiwiX21vdmVUb1ByZXZpb3VzIiwiX21vdmVUb0JlZ2lubmluZyIsIl9tb3ZlVG9FbmQiLCJibHVlIiwiZ3JlZW4iLCJwaW5rIiwicmVkIiwieWVsbG93Iiwib3BlbkRyb3Bkb3duIiwia2V5RG93biIsInN3YXRjaCIsImFyaWFIaWRkZW4iLCJyZW5kZXJNYWluRHJvcGRvd24iLCJnZXREcm9wZG93blJvb3QiLCJhcmlhT3JpZW50YXRpb24iLCJhcmlhTGFiZWxsZWRCeSIsInJvbGUiLCJhcmlhTXVsdGlTZWxlY3RhYmxlIiwiYXJpYVNlbGVjdGVkIiwiY29sb3JTZWxlY3QiLCJ1cGRhdGVDb2xvciIsImlzRHJvcGRvd25WaXNpYmxlIiwibmV4dFNpYmxpbmciLCJwcmV2aW91c1NpYmxpbmciLCJkZXRhaWwiLCJCYXNpY0NvbG9yUGlja2VyIiwiY29sb3JUeXBlIiwiY29sb3JWYWx1ZSIsImVzX2l0ZXJhdG9yX2ZpbmQiLCJlc19pdGVyYXRvcl9mbGF0X21hcCIsIm1ha2VDb2xvckNvbXAiLCJzY2FsZUFuZENsYW1wIiwiQ29sb3JDb252ZXJ0ZXJzIiwiQ01ZS19HIiwiR19DTVlLIiwiR19SR0IiLCJHX3JnYiIsIkdfSFRNTCIsIkciLCJSR0JfRyIsIlJHQl9yZ2IiLCJSR0JfSFRNTCIsIlRfSFRNTCIsIlRfcmdiIiwiQ01ZS19SR0IiLCJDTVlLX3JnYiIsIkNNWUtfSFRNTCIsImNvbXBvbmVudHMiLCJSR0JfQ01ZSyIsIkRhdGVGb3JtYXRzIiwiVGltZUZvcm1hdHMiLCJCYXNlU1ZHRmFjdG9yeSIsInNraXBEaW1lbnNpb25zIiwiX2NyZWF0ZVNWRyIsIkRPTVNWR0ZhY3RvcnkiLCJhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFIiwiR2V0RWxlbWVudHNCeU5hbWVTZXQiLCJUSU1FWk9ORV9PRkZTRVQiLCJnZXRUaW1lem9uZU9mZnNldCIsIkFubm90YXRpb25FbGVtZW50RmFjdG9yeSIsIkxpbmtBbm5vdGF0aW9uRWxlbWVudCIsIlRleHRBbm5vdGF0aW9uRWxlbWVudCIsImZpZWxkVHlwZSIsIlRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsInJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsImNoZWNrQm94IiwiQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIkNob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlBvcHVwQW5ub3RhdGlvbkVsZW1lbnQiLCJGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IiwiTGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQiLCJDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJDYXJldEFubm90YXRpb25FbGVtZW50IiwiSW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCIsIlN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IiwiU3RhbXBBbm5vdGF0aW9uRWxlbWVudCIsIkZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uRWxlbWVudCIsInVwZGF0ZXMiLCJoYXNCb3JkZXIiLCJwb3B1cEVsZW1lbnQiLCJpc1JlbmRlcmFibGUiLCJpZ25vcmVCb3JkZXIiLCJjcmVhdGVRdWFkcmlsYXRlcmFscyIsImRvd25sb2FkTWFuYWdlciIsImltYWdlUmVzb3VyY2VzUGF0aCIsInJlbmRlckZvcm1zIiwic3ZnRmFjdG9yeSIsImVuYWJsZUNvbW1lbnQiLCJlbmFibGVTY3JpcHRpbmciLCJfZmllbGRPYmplY3RzIiwiZmllbGRPYmplY3RzIiwiX2NyZWF0ZUNvbnRhaW5lciIsIl9jcmVhdGVRdWFkcmlsYXRlcmFscyIsIl9oYXNQb3B1cERhdGEiLCJfaXNFZGl0YWJsZSIsImlzRWRpdGFibGUiLCJoYXNQb3B1cERhdGEiLCJjb21tZW50VGV4dCIsImNvbW1lbnREYXRhIiwiaGFzQ29tbWVudEJ1dHRvbiIsImhhc1BvcHVwRWxlbWVudCIsInF1YWRQb2ludHMiLCJpbmtMaXN0cyIsImlua0xpc3QiLCJfbm9ybWFsaXplUG9pbnQiLCJyZW1vdmVQb3B1cCIsIm5ld1BvcHVwIiwic2V0UmVjdEVkaXRlZCIsIl9jcmVhdGVQb3B1cCIsInJlc2V0RWRpdGVkIiwiY3VycmVudFJlY3QiLCJzZXRSb3RhdGlvbiIsImFsdGVybmF0aXZlVGV4dCIsIm5vUm90YXRlIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJfY29tbW9uQWN0aW9ucyIsInNldENvbG9yIiwianNOYW1lIiwic3R5bGVOYW1lIiwiY29sb3JBcnJheSIsIm5vVmlldyIsIm5vUHJpbnQiLCJ1c2VyTmFtZSIsInJlYWRvbmx5IiwiX3NldFJlcXVpcmVkIiwidGV4dENvbG9yIiwiX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCIsImFjdGlvbnMiLCJqc0V2ZW50IiwiY29tbW9uQWN0aW9ucyIsIl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyIsImV2ZW50UHJveHkiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwic3ZnQnVmZmVyIiwiY2xpcFBhdGgiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwiYmFja2dyb3VuZEltYWdlIiwicG9wdXBEYXRhIiwidGl0bGVPYmoiLCJwYXJlbnRSZWN0IiwiX2NvbW1lbnRNYW5hZ2VyIiwiZXh0cmFQb3B1cEVsZW1lbnQiLCJfZ2V0RWxlbWVudHNCeU5hbWUiLCJza2lwSWQiLCJmaWVsZHMiLCJmaWVsZE9iaiIsImV4cG9ydFZhbHVlcyIsImV4cG9ydFZhbHVlIiwiZG9tRWxlbWVudCIsImdldEVsZW1lbnRzQnlOYW1lIiwibWF5YmVTaG93IiwiZm9yY2VIaWRlIiwiZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCIsImFkZEhpZ2hsaWdodEFyZWEiLCJ0cmlnZ2VycyIsIl9lZGl0T25Eb3VibGVDbGljayIsImFubm90YXRpb25FZGl0b3JUeXBlIiwiRWRpdG9yQW5ub3RhdGlvbkVsZW1lbnQiLCJjcmVhdGVPclVwZGF0ZVBvcHVwIiwicmVuZGVyQ29tbWVudEJ1dHRvbiIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsIl9iaW5kTmFtZWRBY3Rpb24iLCJvdmVybGFpZFRleHQiLCJhdHRhY2htZW50IiwiYmluZEF0dGFjaG1lbnQiLCJhdHRhY2htZW50RGVzdCIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzIiwiX2dldEtleU1vZGlmaWVyIiwiX3NldEV2ZW50TGlzdGVuZXIiLCJlbGVtZW50RGF0YSIsImJhc2VOYW1lIiwiZXZlbnROYW1lIiwidmFsdWVHZXR0ZXIiLCJtb2RpZmllciIsImZvY3VzZWQiLCJfc2V0RXZlbnRMaXN0ZW5lcnMiLCJCbHVyIiwiRm9jdXMiLCJfc2V0QmFja2dyb3VuZENvbG9yIiwiX3NldFRleHRTdHlsZSIsIlRFWFRfQUxJR05NRU5UIiwiZm9udENvbG9yIiwiZGVmYXVsdEFwcGVhcmFuY2VEYXRhIiwiY29tcHV0ZWRGb250U2l6ZSIsInJvdW5kVG9PbmVEZWNpbWFsIiwibXVsdGlMaW5lIiwibnVtYmVyT2ZMaW5lcyIsInRleHRBbGlnbm1lbnQiLCJ0ZXh0QWxpZ24iLCJpc1JlcXVpcmVkIiwiaGFzQXBwZWFyYW5jZSIsImZpZWxkVmFsdWUiLCJzZXRQcm9wZXJ0eU9uU2libGluZ3MiLCJrZXlJblN0b3JhZ2UiLCJtYXhMZW4iLCJjaGFyTGltaXQiLCJmaWVsZEZvcm1hdHRlZFZhbHVlcyIsImZvcm1hdHRlZFZhbHVlIiwiY29tYiIsInVzZXJWYWx1ZSIsImxhc3RDb21taXR0ZWRWYWx1ZSIsImNvbW1pdEtleSIsImRvTm90U2Nyb2xsIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwicmVhZE9ubHkiLCJkYXRldGltZUZvcm1hdCIsImRhdGV0aW1lVHlwZSIsInRpbWVTdGVwIiwiaGFzRGF0ZU9yVGltZSIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwic2Nyb2xsTGVmdCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJ0b0lTT1N0cmluZyIsInNlbFJhbmdlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ3aWxsQ29tbWl0Iiwic2VsU3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbEVuZCIsInNlbGVjdGlvbkVuZCIsIl9ibHVyTGlzdGVuZXIiLCJLZXlzdHJva2UiLCJpbnB1dFR5cGUiLCJjaGFuZ2UiLCJmaWVsZFdpZHRoIiwiY29tYldpZHRoIiwibGV0dGVyU3BhY2luZyIsInZlcnRpY2FsQWxpZ24iLCJjaGVja2JveCIsImN1ckNoZWNrZWQiLCJidXR0b25WYWx1ZSIsInJhZGlvIiwicGRmQnV0dG9uVmFsdWUiLCJsaW5rRWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJhZGRBbkVtcHR5RW50cnkiLCJjb21ibyIsIm11bHRpU2VsZWN0IiwibXVsdGlwbGUiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwiaXNFeHBvcnQiLCJzZWxlY3RlZFZhbHVlcyIsImdldEl0ZW1zIiwibXVsdGlwbGVTZWxlY3Rpb24iLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImluZGljZXMiLCJlZGl0YWJsZSIsImNoYW5nZUV4IiwiY3JlYXRlUG9wdXAiLCJQb3B1cEVsZW1lbnQiLCJib3VuZEtleURvd24iLCJib3VuZEhpZGUiLCJib3VuZFNob3ciLCJib3VuZFRvZ2dsZSIsImRhdGVPYmoiLCJwaW5uZWQiLCJwb3B1cEFib3J0Q29udHJvbGxlciIsImNvbW1lbnRCdXR0b24iLCJ3YXNWaXNpYmxlIiwiZmlyc3RFbGVtZW50IiwidHJpZ2dlciIsImFkZEV2ZW50TGlzdGVuZXJzIiwic2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uIiwiaGFzT3duQnV0dG9uIiwidG9nZ2xlUG9wdXAiLCJzaG93UG9wdXAiLCJoaWRlUG9wdXAiLCJwYXJlbnRDb250YWluZXIiLCJ1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24iLCJhZnRlciIsIm91dGxpbmVDb2xvciIsImhlYWRlciIsImRhdGVUaW1lIiwibWFrZVBvcHVwQ29udGVudCIsInBvcHVwTGluZXMiLCJwb3B1cENvbnRlbnQiLCJsaW5lQXR0cmlidXRlcyIsInNldFBvc2l0aW9uIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJ0ZXh0UG9zaXRpb24iLCJsaW5lU3BhbiIsImxpbmVDb29yZGluYXRlcyIsInNxdWFyZSIsImNpcmNsZSIsInBvbHlsaW5lIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwic3ZnRWxlbWVudE5hbWUiLCJ2ZXJ0aWNlcyIsInBvaW50cyIsInBvbHlsaW5lc0dyb3VwRWxlbWVudCIsInBvbHlsaW5lcyIsInRoaWNrbmVzcyIsIm1hcmsiLCJ1bmRlcmxpbmUiLCJzdHJpa2VvdXQiLCJkb3dubG9hZCIsIkFubm90YXRpb25MYXllciIsImFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiZWRpdGFibGVBbm5vdGF0aW9ucyIsInN0cnVjdFRyZWVMYXllciIsImFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJfYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsImhhc0VkaXRhYmxlQW5ub3RhdGlvbnMiLCJhcHBlbmRFbGVtZW50IiwicG9wdXBFbGVtZW50cyIsImNvbnRlbnRFbGVtZW50IiwiYXJpYUF0dHJpYnV0ZXMiLCJnZXRBcmlhQXR0cmlidXRlcyIsIm1vdmVFbGVtZW50SW5ET00iLCJhbm5vdGF0aW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsImFkZExpbmtBbm5vdGF0aW9ucyIsIl9kZWZhdWx0Qm9yZGVyU3R5bGUiLCJyZXBsYWNlV2l0aCIsImVkaXRhYmxlQW5ub3RhdGlvbiIsIl9oYXNOb0NhbnZhcyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbnMiLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJodG1sRWxlbWVudCIsInJhd1dpZHRoIiwiRU9MX1BBVFRFUk4iLCJGcmVlVGV4dEVkaXRvciIsImVkaXRvckRpdklkIiwiZWRpdE1vZGVBQyIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiX2NvbG9yUGlja2VyIiwidXBkYXRlRm9udFNpemUiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwiY29sIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJlZGl0b3JEaXZLZXlkb3duIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZQYXN0ZSIsImlubmVyVGV4dCIsImV4dHJhY3RUZXh0IiwicHJldkNoaWxkIiwiY2hpbGROb2RlcyIsImdldE5vZGVDb250ZW50Iiwic2F2ZWREaXNwbGF5Iiwic2F2ZWRWaXNpYmlsaXR5Iiwic2F2ZWRUZXh0IiwibmV3VGV4dCIsInRyaW1FbmQiLCJzZXRUZXh0Iiwic2V0Q29udGVudCIsIm5vZGVWYWx1ZSIsImRlc2VyaWFsaXplQ29udGVudCIsImRlbGV0ZUZyb21Eb2N1bWVudCIsImluc2VydE5vZGUiLCJjb2xsYXBzZVRvU3RhcnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwiYnVmZmVyQmVmb3JlIiwiYnVmZmVyQWZ0ZXIiLCJuZXdSYW5nZSIsIlJhbmdlIiwiYmVmb3JlTGVuZ3RoIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInJlcGxhY2VDaGlsZHJlbiIsInNlcmlhbGl6ZUNvbnRlbnQiLCJwYWRkaW5nIiwiaGFzRWxlbWVudENoYW5nZWQiLCJPdXRsaW5lIiwidG9TVkdQYXRoIiwiX3JvdGF0aW9uIiwiX3Jlc2NhbGUiLCJfcmVzY2FsZUFuZFN3YXAiLCJfdHJhbnNsYXRlIiwic3ZnUm91bmQiLCJfbm9ybWFsaXplUGFnZVBvaW50IiwiY3JlYXRlQmV6aWVyUG9pbnRzIiwiRnJlZURyYXdPdXRsaW5lciIsImlubmVyTWFyZ2luIiwibGFzdCIsIm1pbl9kaXN0Iiwic2NhbGVGYWN0b3IiLCJNSU5fRElTVCIsIk1JTl9ESUZGIiwiTUlOIiwiZ2V0TGFzdENvb3JkcyIsImxhc3RUb3AiLCJsYXN0Qm90dG9tIiwiZGlmZlgiLCJkaWZmWSIsImRpZmZEIiwiblgiLCJuWSIsInRoWCIsInRoWSIsInRvU1ZHUGF0aFR3b1BvaW50cyIsInRvU1ZHUGF0aEVuZCIsInRvU1ZHUGF0aFN0YXJ0IiwibGFzdFRvcFgiLCJsYXN0VG9wWSIsImxhc3RCb3R0b21YIiwibGFzdEJvdHRvbVkiLCJuZXdGcmVlRHJhd091dGxpbmUiLCJvdXRsaW5lIiwiRnJlZURyYXdPdXRsaW5lIiwiZ2V0T3V0bGluZXMiLCJnZXRPdXRsaW5lVHdvUG9pbnRzIiwiTiIsImdldE91dGxpbmVFbmQiLCJnZXRPdXRsaW5lU3RhcnQiLCJmaXJzdFBvaW50IiwibGFzdFBvaW50IiwiY29tcHV0ZU1pbk1heCIsImZpcnN0UG9pbnRYIiwiZmlyc3RQb2ludFkiLCJsYXN0UG9pbnRYIiwibGFzdFBvaW50WSIsImx0ckNhbGxiYWNrIiwiYmV6aWVyQmJveCIsIm5ld091dGxpbmVyIiwiZ2V0TmV3T3V0bGluZSIsIm91dGxpbmVyIiwiSGlnaGxpZ2h0T3V0bGluZXIiLCJ2ZXJ0aWNhbEVkZ2VzIiwiaW50ZXJ2YWxzIiwiTlVNQkVSX09GX0RJR0lUUyIsIkVQU0lMT04iLCJzaGlmdGVkTWluWCIsInNoaWZ0ZWRNaW5ZIiwibGFzdEVkZ2UiLCJlZGdlIiwib3V0bGluZVZlcnRpY2FsRWRnZXMiLCJicmVha0VkZ2UiLCJlZGdlcyIsImFsbEVkZ2VzIiwiZWRnZTEiLCJlZGdlMiIsIm91dGxpbmVzIiwiSGlnaGxpZ2h0T3V0bGluZSIsImJpbmFyeVNlYXJjaCIsIm1pZGRsZSIsInk0IiwicG9seWdvbiIsInByZXZYIiwicHJldlkiLCJjbGFzc05hbWVzRm9yT3V0bGluaW5nIiwiRnJlZUhpZ2hsaWdodE91dGxpbmVyIiwiRnJlZUhpZ2hsaWdodE91dGxpbmUiLCJIaWdobGlnaHRFZGl0b3IiLCJjbGlwUGF0aElkIiwiZm9jdXNPdXRsaW5lcyIsImhpZ2hsaWdodERpdiIsImhpZ2hsaWdodE91dGxpbmVzIiwiaXNGcmVlSGlnaGxpZ2h0Iiwib3V0bGluZUlkIiwiX2RlZmF1bHRPcGFjaXR5IiwiX2RlZmF1bHRUaGlja25lc3MiLCJfZnJlZUhpZ2hsaWdodElkIiwiX2ZyZWVIaWdobGlnaHQiLCJfZnJlZUhpZ2hsaWdodENsaXBJZCIsIl9tb3ZlQ2FyZXQiLCJoaWdobGlnaHRJZCIsImNyZWF0ZUZyZWVPdXRsaW5lcyIsImFkZFRvRHJhd0xheWVyIiwiY3JlYXRlT3V0bGluZXMiLCJudW1iZXJPZkNvbG9ycyIsIm91dGxpbmVyRm9yT3V0bGluZSIsImV4dHJhVGhpY2tuZXNzIiwiZHJhd0xheWVyIiwiZmluYWxpemVEcmF3IiwiZHJhd091dGxpbmUiLCJyb290Q2xhc3MiLCJoaWdobGlnaHRPdXRsaW5lIiwiZnJlZSIsInVwZGF0ZVByb3BlcnRpZXMiLCJyb3RhdGVCYm94IiwidXBkYXRlVGhpY2tuZXNzIiwic2V0Q29sb3JBbmRPcGFjaXR5Iiwib3BhIiwic2F2ZWRPcGFjaXR5Iiwic2F2ZWRUaGlja25lc3MiLCJzZXRUaGlja25lc3MiLCJ0aCIsImNoYW5nZVRoaWNrbmVzcyIsImdldFJvdGF0aW9uIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjbGVhbkRyYXdMYXllciIsIm11c3RCZVNlbGVjdGVkIiwiZHJhdyIsInBvaW50ZXJvdmVyIiwiaG92ZXJlZCIsInBvaW50ZXJsZWF2ZSIsInNldENhcmV0Iiwic2VyaWFsaXplQm94ZXMiLCJzZXJpYWxpemVPdXRsaW5lcyIsInN0YXJ0SGlnaGxpZ2h0aW5nIiwiZW5kSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0TW92ZSIsIkRyYXdpbmdPcHRpb25zIiwic3ZnUHJvcGVydGllcyIsInVwZGF0ZVByb3BlcnR5IiwidXBkYXRlU1ZHUHJvcGVydHkiLCJ0b1NWR1Byb3BlcnRpZXMiLCJ1cGRhdGVBbGwiLCJEcmF3aW5nRWRpdG9yIiwiZHJhd091dGxpbmVzIiwibXVzdEJlQ29tbWl0dGVkIiwiX2N1cnJlbnREcmF3SWQiLCJfY3VycmVudFBhcmVudCIsImN1cnJlbnREcmF3IiwiY3VycmVudERyYXdpbmdBQyIsImN1cnJlbnREcmF3aW5nT3B0aW9ucyIsImN1cnJlbnRQb2ludGVySWQiLCJjdXJyZW50UG9pbnRlclR5cGUiLCJjdXJyZW50UG9pbnRlcklkcyIsImN1cnJlbnRNb3ZlVGltZXN0YW1wIiwiX0lOTkVSX01BUkdJTiIsIl9kcmF3SWQiLCJfYWRkT3V0bGluZXMiLCJjcmVhdGVEcmF3T3V0bGluZXMiLCJkcmF3SWQiLCJkcmF3aW5nT3B0aW9ucyIsIl9kcmF3aW5nT3B0aW9ucyIsImRlZmF1bHRQcm9wZXJ0aWVzIiwiY3JlYXRlRHJhd2luZyIsInVwZGF0ZUJib3giLCJfbWVyZ2VTVkdQcm9wZXJ0aWVzIiwiZGVmYXVsdFNWR1Byb3BlcnRpZXMiLCJwMUtleXMiLCJnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMiLCJfb3B0aW9ucyIsInR5cGVzTWFwIiwic3VwcG9ydE11bHRpcGxlRHJhd2luZ3MiLCJwcm9wZXJ0eU5hbWUiLCJfZGVmYXVsdERyYXdpbmdPcHRpb25zIiwiX3VwZGF0ZVByb3BlcnR5Iiwic2F2ZWRWYWx1ZSIsImdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXMiLCJjb252ZXJ0VG9EcmF3U3BhY2UiLCJyb3RhdGVCb3giLCJnZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXMiLCJfeCIsIl95IiwiZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzIiwibW92aW5nIiwidXBkYXRlUGFyZW50IiwiY29udmVydFRvUGFyZW50U3BhY2UiLCJwVyIsInBIIiwidXBkYXRlUm90YXRpb24iLCJ1cGRhdGVQYXJlbnREaW1lbnNpb25zIiwib25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmciLCJkcmF3RGl2IiwiY3JlYXRlRHJhd2VySW5zdGFuY2UiLCJfcGFyZW50V2lkdGgiLCJfcGFyZW50SGVpZ2h0Iiwic3RhcnREcmF3aW5nIiwiX2lzTFRSIiwiX2VuZERyYXciLCJpc0NhbmNlbGxhYmxlIiwicmVtb3ZlTGFzdEVsZW1lbnQiLCJfZHJhd01vdmUiLCJ0aW1lU3RhbXAiLCJzdGFydE5ldyIsIl9jbGVhbnVwIiwibGFzdEVsZW1lbnQiLCJnZXRMYXN0RWxlbWVudCIsInNldExhc3RFbGVtZW50IiwiaXNBYm9ydGVkIiwiY3JlYXRlRHJhd2luZ09wdGlvbnMiLCJfZGF0YSIsImRlc2VyaWFsaXplRHJhdyIsIl9wYWdlWCIsIl9wYWdlWSIsIl9wYWdlV2lkdGgiLCJfcGFnZUhlaWdodCIsIl9pbm5lcldpZHRoIiwic2VyaWFsaXplRHJhdyIsIklua0RyYXdPdXRsaW5lciIsImxhc3RTVkdQYXRoIiwibGFzdEluZGV4IiwiSW5rRHJhd091dGxpbmUiLCJub3JtYWxpemVQb2ludCIsImZpcnN0WCIsImZpcnN0WSIsInNlY29uZFgiLCJzZWNvbmRZIiwiYzF4IiwiYzF5IiwiYzJ4IiwiYzJ5IiwiY3VycmVudFJvdGF0aW9uIiwiY29tcHV0ZUJib3giLCJzZXJpYWxpemVkTGluZXMiLCJzZXJpYWxpemVkUG9pbnRzIiwiZ2V0QkJveFdpdGhOb01hcmdpbiIsInJlc2NhbGVGbiIsIm5ld0xpbmVzIiwiZ2V0TWFyZ2luQ29tcG9uZW50cyIsIm1hcmdpbiIsIm1hcmdpblgiLCJtYXJnaW5ZIiwib2xkTWFyZ2luWCIsIm9sZE1hcmdpblkiLCJuZXdNYXJnaW5YIiwibmV3TWFyZ2luWSIsImRpZmZNYXJnaW5YIiwiZGlmZk1hcmdpblkiLCJyb3RhdGlvblRyYW5zZm9ybSIsInMxeCIsInMxeSIsInMyeCIsInMyeSIsIm5ld1BhcmVudFdpZHRoIiwibmV3UGFyZW50SGVpZ2h0IiwiSW5rRHJhd2luZ09wdGlvbnMiLCJ2aWV3ZXJQYXJhbWV0ZXJzIiwiX3ZpZXdQYXJhbWV0ZXJzIiwiSW5rRWRpdG9yIiwiQ29udG91ckRyYXdPdXRsaW5lIiwiQkFTRV9IRUFERVJfTEVOR1RIIiwiUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSIiwiU2lnbmF0dXJlRXh0cmFjdG9yIiwiUEFSQU1FVEVSUyIsInNpZ21hU0ZhY3RvciIsInNpZ21hUiIsImtlcm5lbFNpemUiLCJuZWlnaGJvckluZGV4VG9JZCIsImkwIiwiajAiLCJuZWlnaGJvcklkVG9JbmRleCIsImNsb2Nrd2lzZU5vblplcm8iLCJrayIsInNoaWZ0SSIsInNoaWZ0SiIsImNvdW50ZXJDbG9ja3dpc2VOb25aZXJvIiwiZmluZENvbnRvdXJzIiwidGhyZXNob2xkIiwibmJkIiwibG5iZCIsImNvbnRvdXJzIiwiaWoiLCJwaXgiLCJpMiIsImoyIiwiaXNIb2xlIiwiY29udG91ciIsImNvbnRvdXIwIiwiaTEiLCJqMSIsImkzIiwiajMiLCJpNCIsImo0IiwiaWozIiwiZG91Z2xhc1BldWNrZXJIZWxwZXIiLCJheCIsImF5IiwiYWJ4IiwiYWJ5IiwiZGlzdCIsIm5hYngiLCJuYWJ5IiwiYWEiLCJpbnZTIiwicGhpIiwiYXRhbiIsImNvc1BoaSIsInNpblBoaSIsInRtYXgiLCJwb2x5IiwicGFydGlhbFBoaSIsImRtYXgiLCJkb3VnbGFzUGV1Y2tlciIsImJpbGF0ZXJhbEZpbHRlciIsInNpZ21hUyIsImtlcm5lbCIsInNpZ21hUzIiLCJoYWxmU2l6ZSIsImV4cCIsInJhbmdlVmFsdWVzIiwic2lnbWFSMiIsIm91dCIsImhpc3RvZ3JhbSIsIm5vcm0iLCJuZWlnaGJvdXIiLCJnZXRIaXN0b2dyYW0iLCJ0b1VpbnQ4IiwiZ3Vlc3NUaHJlc2hvbGQiLCJNIiwiTCIsInNwb3MiLCJnZXRHcmF5UGl4ZWxzIiwib3JpZ2luYWxCaXRtYXAiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0IiwibG9nMiIsImlzdGVwcyIsImdyYXlJbWFnZSIsInVpbnQ4QnVmIiwiZXh0cmFjdENvbnRvdXJzRnJvbVRleHQiLCJmb250U3R5bGUiLCJTQ0FMRSIsImNvbnRvdXJMaXN0IiwicHJvY2Vzc0RyYXduTGluZXMiLCJjdXJ2ZXMiLCJtdXN0U21vb3RoIiwiYXJlQ29udG91cnMiLCJsaW5lc0FuZFBvaW50cyIsInhTY2FsZSIsInlTY2FsZSIsIm5ld0N1cnZlcyIsInJlZHVjZWRQb2ludHMiLCJuZXdQb2ludHMiLCJjb21wcmVzc1NpZ25hdHVyZSIsIm1pbkRpZmYiLCJtYXhEaWZmIiwib3V0bGluZXNMZW5ndGgiLCJkeCIsImJ1ZmZlclR5cGUiLCJoZWFkZXJMZW5ndGgiLCJCWVRFU19QRVJfRUxFTUVOVCIsIkNvbXByZXNzaW9uU3RyZWFtIiwid3JpdGVyIiwiZ2V0V3JpdGVyIiwiQnVmZmVyQ3RvciIsImRpZmZzIiwiUmVzcG9uc2UiLCJyZWFkYWJsZSIsImRlY29tcHJlc3NTaWduYXR1cmUiLCJzaWduYXR1cmVEYXRhIiwiRGVjb21wcmVzc2lvblN0cmVhbSIsIm51bWJlck9mRHJhd2luZ3MiLCJkaWZmc09mZnNldCIsIlNpZ25hdHVyZU9wdGlvbnMiLCJEcmF3blNpZ25hdHVyZU9wdGlvbnMiLCJTaWduYXR1cmVFZGl0b3IiLCJpc0V4dHJhY3RlZCIsInNpZ25hdHVyZVVVSUQiLCJfZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucyIsImhhc0Rlc2NyaXB0aW9uIiwiaGFzRGVzY3JpcHRpb25TdGF0cyIsImhhc05vQWx0VGV4dCIsInV1aWQiLCJoZWlnaHRJblBhZ2UiLCJhZGRTaWduYXR1cmUiLCJzZXRVdWlkIiwiZ2V0U2lnbmF0dXJlUHJldmlldyIsIm91dGxpbmVEYXRhIiwiaGFzQmVlblNhdmVkIiwiZ2V0RnJvbUltYWdlIiwiZ2V0RnJvbVRleHQiLCJmb250SW5mbyIsImdldERyYXduU2lnbmF0dXJlIiwiaXNTaWduYXR1cmUiLCJhbHQiLCJTdGFtcEVkaXRvciIsImJpdG1hcElkIiwiYml0bWFwUHJvbWlzZSIsImJpdG1hcFVybCIsImJpdG1hcEZpbGUiLCJiaXRtYXBGaWxlTmFtZSIsIm1pc3NpbmdDYW52YXMiLCJyZXNpemVUaW1lb3V0SWQiLCJoYXNCZWVuQWRkZWRJblVuZG9TdGFjayIsInBhc3RlRWRpdG9yIiwiZ2V0QXNGaWxlIiwiaGFzQWx0VGV4dFN0YXRzIiwiZ2V0Qml0bWFwRmV0Y2hlZCIsImZyb21JZCIsImdldEJpdG1hcERvbmUiLCJhbHRfdGV4dF9tb2RhbCIsImFsdF90ZXh0X3R5cGUiLCJtbEd1ZXNzQWx0VGV4dCIsInVwZGF0ZUFsdFRleHREYXRhIiwiaXNFbmFibGVkRm9yIiwiY29weUNhbnZhcyIsImd1ZXNzIiwiY2hhbm5lbHMiLCJnZXRCaXRtYXAiLCJhY2NlcHQiLCJmaWxlcyIsImNsaWNrIiwiZHJhd0JpdG1hcCIsIk1BWF9SQVRJTyIsIm1heERhdGFEaW1lbnNpb24iLCJtYXhQcmV2aWV3RGltZW5zaW9uIiwiYml0bWFwV2lkdGgiLCJiaXRtYXBIZWlnaHQiLCJvdXRwdXRTY2FsZSIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwic2NhbGVCaXRtYXAiLCJib3hEaW0iLCJib3hEaW1XaWR0aCIsImJveERpbUhlaWdodCIsInBhdHRlcm5DdHgiLCJkYXRhV2lkdGgiLCJkYXRhSGVpZ2h0Iiwib2Zmc2NyZWVuQ3R4Iiwic2VyaWFsaXplQml0bWFwIiwidG9VcmwiLCJ0b0RhdGFVUkwiLCJzdHJ1Y3RQYXJlbnQiLCJfc3RydWN0VHJlZSIsImNoYW5nZXMiLCJpc1NhbWUiLCJpc1NhbWVBbHRUZXh0Iiwic3RhbXBzIiwiYXJlYSIsInByZXZEYXRhIiwiaXNTYW1lUGFnZUluZGV4IiwiQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiYWxsb3dDbGljayIsImNsaWNrQUMiLCJlZGl0b3JGb2N1c1RpbWVvdXRJZCIsImhhZFBvaW50ZXJEb3duIiwiaXNEaXNhYmxpbmciLCJpc0VuYWJsaW5nIiwiZHJhd2luZ0FDIiwiZm9jdXNlZEVsZW1lbnQiLCJ0ZXh0U2VsZWN0aW9uQUMiLCJ0ZXh0TGF5ZXJEYmxDbGlja0FDIiwibGFzdFBvaW50ZXJEb3duVGltZXN0YW1wIiwiX2luaXRpYWxpemVkIiwiaXNJbnZpc2libGUiLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsInRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMiLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiYWxsRWRpdG9yc0l0ZXJhdG9yIiwiYW5ub3RhdGlvbkVsZW1lbnRJZHMiLCJEQkxfQ0xJQ0tfVEhSRVNIT0xEIiwiZWxlbWVudHNGcm9tUG9pbnQiLCJjaGFuZ2VkQW5ub3RhdGlvbnMiLCJyZXNldEFubm90YXRpb25zIiwiZWRpdGFibGVzIiwiY3VycmVudEFjdGl2ZSIsInRleHRMYXllclBvaW50ZXJEb3duIiwiYXR0YWNoIiwicmVtb3ZlUG9pbnRlckluVGV4dExheWVyIiwiY3VycmVudEVkaXRvclR5cGUiLCJjcmVhdGVOZXdFZGl0b3IiLCJnZXRDZW50ZXJQb2ludCIsImN1cnJlbnRNb2RlIiwic3RhcnREcmF3aW5nU2Vzc2lvbiIsInBhdXNlIiwib2xkUm90YXRpb24iLCJEcmF3TGF5ZXIiLCJtYXBwaW5nIiwidG9VcGRhdGUiLCJfc3ZnRmFjdG9yeSIsInNldEJveCIsImNyZWF0ZVNWRyIsImNyZWF0ZUNsaXBQYXRoIiwicGF0aElkIiwiY2xpcFBhdGhVc2UiLCJpc1BhdGhVcGRhdGFibGUiLCJoYXNDbGlwIiwidXNlIiwibXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zIiwibWFza0lkIiwidXNlMSIsInVzZTIiLCJjbG9uZU5vZGUiLCJlbGVtZW50T3JJZCIsInBhdGhFbGVtZW50IiwiX3BkZmpzVGVzdGluZ1V0aWxzIiwicGRmanNMaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfjs-dist/legacy/build/pdf.mjs\n");

/***/ })

};
;